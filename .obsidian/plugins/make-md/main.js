/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t3, e3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e3() : typeof define == "function" && define.amd ? define(e3) : (t3 = typeof globalThis != "undefined" ? globalThis : t3 || self).dayjs = e3();
    }(exports, function() {
      "use strict";
      var t3 = 1e3, e3 = 6e4, n2 = 36e5, r3 = "millisecond", i3 = "second", s3 = "minute", u3 = "hour", a3 = "day", o3 = "week", f4 = "month", h3 = "quarter", c3 = "year", d3 = "date", l3 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
        var e4 = ["th", "st", "nd", "rd"], n3 = t4 % 100;
        return "[" + t4 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
      } }, m3 = function(t4, e4, n3) {
        var r4 = String(t4);
        return !r4 || r4.length >= e4 ? t4 : "" + Array(e4 + 1 - r4.length).join(n3) + t4;
      }, v3 = { s: m3, z: function(t4) {
        var e4 = -t4.utcOffset(), n3 = Math.abs(e4), r4 = Math.floor(n3 / 60), i4 = n3 % 60;
        return (e4 <= 0 ? "+" : "-") + m3(r4, 2, "0") + ":" + m3(i4, 2, "0");
      }, m: function t4(e4, n3) {
        if (e4.date() < n3.date())
          return -t4(n3, e4);
        var r4 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i4 = e4.clone().add(r4, f4), s4 = n3 - i4 < 0, u4 = e4.clone().add(r4 + (s4 ? -1 : 1), f4);
        return +(-(r4 + (n3 - i4) / (s4 ? i4 - u4 : u4 - i4)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(t4) {
        return { M: f4, y: c3, w: o3, d: a3, D: d3, h: u3, m: s3, s: i3, ms: r3, Q: h3 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return t4 === void 0;
      } }, g4 = "en", D2 = {};
      D2[g4] = M3;
      var p3 = function(t4) {
        return t4 instanceof _3;
      }, S2 = function t4(e4, n3, r4) {
        var i4;
        if (!e4)
          return g4;
        if (typeof e4 == "string") {
          var s4 = e4.toLowerCase();
          D2[s4] && (i4 = s4), n3 && (D2[s4] = n3, i4 = s4);
          var u4 = e4.split("-");
          if (!i4 && u4.length > 1)
            return t4(u4[0]);
        } else {
          var a4 = e4.name;
          D2[a4] = e4, i4 = a4;
        }
        return !r4 && i4 && (g4 = i4), i4 || !r4 && g4;
      }, w4 = function(t4, e4) {
        if (p3(t4))
          return t4.clone();
        var n3 = typeof e4 == "object" ? e4 : {};
        return n3.date = t4, n3.args = arguments, new _3(n3);
      }, O3 = v3;
      O3.l = S2, O3.i = p3, O3.w = function(t4, e4) {
        return w4(t4, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
      };
      var _3 = function() {
        function M4(t4) {
          this.$L = S2(t4.locale, null, true), this.parse(t4);
        }
        var m4 = M4.prototype;
        return m4.parse = function(t4) {
          this.$d = function(t5) {
            var e4 = t5.date, n3 = t5.utc;
            if (e4 === null)
              return new Date(NaN);
            if (O3.u(e4))
              return new Date();
            if (e4 instanceof Date)
              return new Date(e4);
            if (typeof e4 == "string" && !/Z$/i.test(e4)) {
              var r4 = e4.match($3);
              if (r4) {
                var i4 = r4[2] - 1 || 0, s4 = (r4[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r4[1], i4, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s4)) : new Date(r4[1], i4, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s4);
              }
            }
            return new Date(e4);
          }(t4), this.$x = t4.x || {}, this.init();
        }, m4.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, m4.$utils = function() {
          return O3;
        }, m4.isValid = function() {
          return !(this.$d.toString() === l3);
        }, m4.isSame = function(t4, e4) {
          var n3 = w4(t4);
          return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
        }, m4.isAfter = function(t4, e4) {
          return w4(t4) < this.startOf(e4);
        }, m4.isBefore = function(t4, e4) {
          return this.endOf(e4) < w4(t4);
        }, m4.$g = function(t4, e4, n3) {
          return O3.u(t4) ? this[e4] : this.set(n3, t4);
        }, m4.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m4.valueOf = function() {
          return this.$d.getTime();
        }, m4.startOf = function(t4, e4) {
          var n3 = this, r4 = !!O3.u(e4) || e4, h4 = O3.p(t4), l4 = function(t5, e5) {
            var i4 = O3.w(n3.$u ? Date.UTC(n3.$y, e5, t5) : new Date(n3.$y, e5, t5), n3);
            return r4 ? i4 : i4.endOf(a3);
          }, $4 = function(t5, e5) {
            return O3.w(n3.toDate()[t5].apply(n3.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
          }, y4 = this.$W, M5 = this.$M, m5 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
          switch (h4) {
            case c3:
              return r4 ? l4(1, 0) : l4(31, 11);
            case f4:
              return r4 ? l4(1, M5) : l4(0, M5 + 1);
            case o3:
              var g5 = this.$locale().weekStart || 0, D3 = (y4 < g5 ? y4 + 7 : y4) - g5;
              return l4(r4 ? m5 - D3 : m5 + (6 - D3), M5);
            case a3:
            case d3:
              return $4(v4 + "Hours", 0);
            case u3:
              return $4(v4 + "Minutes", 1);
            case s3:
              return $4(v4 + "Seconds", 2);
            case i3:
              return $4(v4 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m4.endOf = function(t4) {
          return this.startOf(t4, false);
        }, m4.$set = function(t4, e4) {
          var n3, o4 = O3.p(t4), h4 = "set" + (this.$u ? "UTC" : ""), l4 = (n3 = {}, n3[a3] = h4 + "Date", n3[d3] = h4 + "Date", n3[f4] = h4 + "Month", n3[c3] = h4 + "FullYear", n3[u3] = h4 + "Hours", n3[s3] = h4 + "Minutes", n3[i3] = h4 + "Seconds", n3[r3] = h4 + "Milliseconds", n3)[o4], $4 = o4 === a3 ? this.$D + (e4 - this.$W) : e4;
          if (o4 === f4 || o4 === c3) {
            var y4 = this.clone().set(d3, 1);
            y4.$d[l4]($4), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
          } else
            l4 && this.$d[l4]($4);
          return this.init(), this;
        }, m4.set = function(t4, e4) {
          return this.clone().$set(t4, e4);
        }, m4.get = function(t4) {
          return this[O3.p(t4)]();
        }, m4.add = function(r4, h4) {
          var d4, l4 = this;
          r4 = Number(r4);
          var $4 = O3.p(h4), y4 = function(t4) {
            var e4 = w4(l4);
            return O3.w(e4.date(e4.date() + Math.round(t4 * r4)), l4);
          };
          if ($4 === f4)
            return this.set(f4, this.$M + r4);
          if ($4 === c3)
            return this.set(c3, this.$y + r4);
          if ($4 === a3)
            return y4(1);
          if ($4 === o3)
            return y4(7);
          var M5 = (d4 = {}, d4[s3] = e3, d4[u3] = n2, d4[i3] = t3, d4)[$4] || 1, m5 = this.$d.getTime() + r4 * M5;
          return O3.w(m5, this);
        }, m4.subtract = function(t4, e4) {
          return this.add(-1 * t4, e4);
        }, m4.format = function(t4) {
          var e4 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l3;
          var r4 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i4 = O3.z(this), s4 = this.$H, u4 = this.$m, a4 = this.$M, o4 = n3.weekdays, f5 = n3.months, h4 = function(t5, n4, i5, s5) {
            return t5 && (t5[n4] || t5(e4, r4)) || i5[n4].slice(0, s5);
          }, c4 = function(t5) {
            return O3.s(s4 % 12 || 12, t5, "0");
          }, d4 = n3.meridiem || function(t5, e5, n4) {
            var r5 = t5 < 12 ? "AM" : "PM";
            return n4 ? r5.toLowerCase() : r5;
          }, $4 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: O3.s(a4 + 1, 2, "0"), MMM: h4(n3.monthsShort, a4, f5, 3), MMMM: h4(f5, a4), D: this.$D, DD: O3.s(this.$D, 2, "0"), d: String(this.$W), dd: h4(n3.weekdaysMin, this.$W, o4, 2), ddd: h4(n3.weekdaysShort, this.$W, o4, 3), dddd: o4[this.$W], H: String(s4), HH: O3.s(s4, 2, "0"), h: c4(1), hh: c4(2), a: d4(s4, u4, true), A: d4(s4, u4, false), m: String(u4), mm: O3.s(u4, 2, "0"), s: String(this.$s), ss: O3.s(this.$s, 2, "0"), SSS: O3.s(this.$ms, 3, "0"), Z: i4 };
          return r4.replace(y3, function(t5, e5) {
            return e5 || $4[t5] || i4.replace(":", "");
          });
        }, m4.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m4.diff = function(r4, d4, l4) {
          var $4, y4 = O3.p(d4), M5 = w4(r4), m5 = (M5.utcOffset() - this.utcOffset()) * e3, v4 = this - M5, g5 = O3.m(this, M5);
          return g5 = ($4 = {}, $4[c3] = g5 / 12, $4[f4] = g5, $4[h3] = g5 / 3, $4[o3] = (v4 - m5) / 6048e5, $4[a3] = (v4 - m5) / 864e5, $4[u3] = v4 / n2, $4[s3] = v4 / e3, $4[i3] = v4 / t3, $4)[y4] || v4, l4 ? g5 : O3.a(g5);
        }, m4.daysInMonth = function() {
          return this.endOf(f4).$D;
        }, m4.$locale = function() {
          return D2[this.$L];
        }, m4.locale = function(t4, e4) {
          if (!t4)
            return this.$L;
          var n3 = this.clone(), r4 = S2(t4, e4, true);
          return r4 && (n3.$L = r4), n3;
        }, m4.clone = function() {
          return O3.w(this.$d, this);
        }, m4.toDate = function() {
          return new Date(this.valueOf());
        }, m4.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m4.toISOString = function() {
          return this.$d.toISOString();
        }, m4.toString = function() {
          return this.$d.toUTCString();
        }, M4;
      }(), T5 = _3.prototype;
      return w4.prototype = T5, [["$ms", r3], ["$s", i3], ["$m", s3], ["$H", u3], ["$W", a3], ["$M", f4], ["$y", c3], ["$D", d3]].forEach(function(t4) {
        T5[t4[1]] = function(e4) {
          return this.$g(e4, t4[0], t4[1]);
        };
      }), w4.extend = function(t4, e4) {
        return t4.$i || (t4(e4, _3, w4), t4.$i = true), w4;
      }, w4.locale = S2, w4.isDayjs = p3, w4.unix = function(t4) {
        return w4(1e3 * t4);
      }, w4.en = D2[g4], w4.Ls = D2, w4.p = {}, w4;
    });
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v3) {
          return exports2[id] = previous ? previous(id, v3) : v3;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p3 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p3))
            d3[p3] = b3[p3];
      };
      __extends2 = function(d3, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p3 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p3))
              t3[p3] = s3[p3];
        }
        return t3;
      };
      __rest2 = function(s3, e3) {
        var t3 = {};
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
            t3[p3] = s3[p3];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
            if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
              t3[p3[i3]] = s3[p3[i3]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key2, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d3 = decorators[i3])
              r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key2, r3) : d3(target, key2)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key2, r3), r3;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _3 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f4, y3, t3, g4;
        return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
          return this;
        }), g4;
        function verb(n2) {
          return function(v3) {
            return step([n2, v3]);
          };
        }
        function step(op) {
          if (f4)
            throw new TypeError("Generator is already executing.");
          while (g4 && (g4 = 0, op[0] && (_3 = 0)), _3)
            try {
              if (f4 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _3.label++;
                  return { value: op[1], done: false };
                case 5:
                  _3.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _3.ops.pop();
                  _3.trys.pop();
                  continue;
                default:
                  if (!(t3 = _3.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _3 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _3.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _3.label < t3[1]) {
                    _3.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _3.label < t3[2]) {
                    _3.label = t3[2];
                    _3.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _3.ops.pop();
                  _3.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _3);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f4 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m3, o3) {
        for (var p3 in m3)
          if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p3))
            __createBinding2(o3, m3, p3);
      };
      __createBinding2 = Object.create ? function(o3, m3, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        var desc = Object.getOwnPropertyDescriptor(m3, k4);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k4];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m3, k4, k22) {
        if (k22 === void 0)
          k22 = k4;
        o3[k22] = m3[k4];
      };
      __values2 = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
        if (m3)
          return m3.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o3, n2) {
        var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m3)
          return o3;
        var i3 = m3.call(o3), r3, ar = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m3 = i3["return"]))
              m3.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
          ar = ar.concat(__read2(arguments[i3]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k4 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j4 = 0, jl = a3.length; j4 < jl; j4++, k4++)
            r3[k4] = a3[j4];
        return r3;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
            if (ar || !(i3 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i3);
              ar[i3] = from[i3];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v3) {
        return this instanceof __await2 ? (this.v = v3, this) : new __await2(v3);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g4 = generator.apply(thisArg, _arguments || []), i3, q4 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g4[n2])
            i3[n2] = function(v3) {
              return new Promise(function(a3, b3) {
                q4.push([n2, v3, a3, b3]) > 1 || resume(n2, v3);
              });
            };
        }
        function resume(n2, v3) {
          try {
            step(g4[n2](v3));
          } catch (e3) {
            settle(q4[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await2 ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q4[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f4, v3) {
          if (f4(v3), q4.shift(), q4.length)
            resume(q4[0][0], q4[0][1]);
        }
      };
      __asyncDelegator2 = function(o3) {
        var i3, p3;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f4) {
          i3[n2] = o3[n2] ? function(v3) {
            return (p3 = !p3) ? { value: __await2(o3[n2](v3)), done: n2 === "return" } : f4 ? f4(v3) : v3;
          } : f4;
        }
      };
      __asyncValues2 = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o3[Symbol.asyncIterator], i3;
        return m3 ? m3.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v3) {
            return new Promise(function(resolve, reject) {
              v3 = o3[n2](v3), settle(resolve, reject, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject, d3, v3) {
          Promise.resolve(v3).then(function(v4) {
            resolve({ value: v4, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k4 in mod)
            if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4))
              __createBinding2(result, mod, k4);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f4) {
        if (kind === "a" && !f4)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f4) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f4)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// node_modules/dayjs/plugin/relativeTime.js
var require_relativeTime = __commonJS({
  "node_modules/dayjs/plugin/relativeTime.js"(exports, module2) {
    !function(r3, e3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e3() : typeof define == "function" && define.amd ? define(e3) : (r3 = typeof globalThis != "undefined" ? globalThis : r3 || self).dayjs_plugin_relativeTime = e3();
    }(exports, function() {
      "use strict";
      return function(r3, e3, t3) {
        r3 = r3 || {};
        var n2 = e3.prototype, o3 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
        function i3(r4, e4, t4, o4) {
          return n2.fromToBase(r4, e4, t4, o4);
        }
        t3.en.relativeTime = o3, n2.fromToBase = function(e4, n3, i4, d4, u3) {
          for (var f4, a3, s3, l3 = i4.$locale().relativeTime || o3, h3 = r3.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m3 = h3.length, c3 = 0; c3 < m3; c3 += 1) {
            var y3 = h3[c3];
            y3.d && (f4 = d4 ? t3(e4).diff(i4, y3.d, true) : i4.diff(e4, y3.d, true));
            var p3 = (r3.rounding || Math.round)(Math.abs(f4));
            if (s3 = f4 > 0, p3 <= y3.r || !y3.r) {
              p3 <= 1 && c3 > 0 && (y3 = h3[c3 - 1]);
              var v3 = l3[y3.l];
              u3 && (p3 = u3("" + p3)), a3 = typeof v3 == "string" ? v3.replace("%d", p3) : v3(p3, n3, y3.l, s3);
              break;
            }
          }
          if (n3)
            return a3;
          var M3 = s3 ? l3.future : l3.past;
          return typeof M3 == "function" ? M3(a3) : M3.replace("%s", a3);
        }, n2.to = function(r4, e4) {
          return i3(r4, e4, this, true);
        }, n2.from = function(r4, e4) {
          return i3(r4, e4, this);
        };
        var d3 = function(r4) {
          return r4.$u ? t3.utc() : t3();
        };
        n2.toNow = function(r4) {
          return this.to(d3(this), r4);
        }, n2.fromNow = function(r4) {
          return this.from(d3(this), r4);
        };
      };
    });
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames4() {
        var classes = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          var arg = arguments[i3];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames4.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key2 in arg) {
              if (hasOwn.call(arg, key2) && arg[key2]) {
                classes.push(key2);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames4.default = classNames4;
        module2.exports = classNames4;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames4;
        });
      } else {
        window.classNames = classNames4;
      }
    })();
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module2) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a3, b3) {
      if (a3 === b3)
        return true;
      if (a3 && b3 && typeof a3 == "object" && typeof b3 == "object") {
        if (a3.constructor !== b3.constructor)
          return false;
        var length, i3, keys;
        if (Array.isArray(a3)) {
          length = a3.length;
          if (length != b3.length)
            return false;
          for (i3 = length; i3-- !== 0; )
            if (!equal(a3[i3], b3[i3]))
              return false;
          return true;
        }
        var it;
        if (hasMap && a3 instanceof Map && b3 instanceof Map) {
          if (a3.size !== b3.size)
            return false;
          it = a3.entries();
          while (!(i3 = it.next()).done)
            if (!b3.has(i3.value[0]))
              return false;
          it = a3.entries();
          while (!(i3 = it.next()).done)
            if (!equal(i3.value[1], b3.get(i3.value[0])))
              return false;
          return true;
        }
        if (hasSet && a3 instanceof Set && b3 instanceof Set) {
          if (a3.size !== b3.size)
            return false;
          it = a3.entries();
          while (!(i3 = it.next()).done)
            if (!b3.has(i3.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b3)) {
          length = a3.length;
          if (length != b3.length)
            return false;
          for (i3 = length; i3-- !== 0; )
            if (a3[i3] !== b3[i3])
              return false;
          return true;
        }
        if (a3.constructor === RegExp)
          return a3.source === b3.source && a3.flags === b3.flags;
        if (a3.valueOf !== Object.prototype.valueOf)
          return a3.valueOf() === b3.valueOf();
        if (a3.toString !== Object.prototype.toString)
          return a3.toString() === b3.toString();
        keys = Object.keys(a3);
        length = keys.length;
        if (length !== Object.keys(b3).length)
          return false;
        for (i3 = length; i3-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b3, keys[i3]))
            return false;
        if (hasElementType && a3 instanceof Element)
          return false;
        for (i3 = length; i3-- !== 0; ) {
          if ((keys[i3] === "_owner" || keys[i3] === "__v" || keys[i3] === "__o") && a3.$$typeof) {
            continue;
          }
          if (!equal(a3[keys[i3]], b3[keys[i3]]))
            return false;
        }
        return true;
      }
      return a3 !== a3 && b3 !== b3;
    }
    module2.exports = function isEqual3(a3, b3) {
      try {
        return equal(a3, b3);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MakeMDPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/components/Spaces/FileTreeView.tsx
var import_obsidian10 = require("obsidian");

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var o;
var r;
var f = {};
var e = [];
var c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function a(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function h(l3, u3, i3) {
  var t3, o3, r3, f4 = {};
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f4[r3] = u3[r3];
  if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i3), typeof l3 == "function" && l3.defaultProps != null)
    for (r3 in l3.defaultProps)
      f4[r3] === void 0 && (f4[r3] = l3.defaultProps[r3]);
  return v(l3, f4, t3, o3, null);
}
function v(n2, i3, t3, o3, r3) {
  var f4 = { type: n2, props: i3, key: t3, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r3 == null ? ++u : r3 };
  return r3 == null && l.vnode != null && l.vnode(f4), f4;
}
function y() {
  return { current: null };
}
function p(n2) {
  return n2.children;
}
function d(n2, l3) {
  this.props = n2, this.context = l3;
}
function _(n2, l3) {
  if (l3 == null)
    return n2.__ ? _(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if ((u3 = n2.__k[l3]) != null && u3.__e != null)
      return u3.__e;
  return typeof n2.type == "function" ? _(n2) : null;
}
function k(n2) {
  var l3, u3;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return k(n2);
  }
}
function b(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
  for (var n2; g.__r = t.length; )
    n2 = t.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), t = [], n2.some(function(n3) {
      var l3, u3, i3, t3, o3, r3;
      n3.__d && (o3 = (t3 = (l3 = n3).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = s({}, t3)).__v = t3.__v + 1, j(r3, t3, i3, l3.__n, r3.ownerSVGElement !== void 0, t3.__h != null ? [o3] : null, u3, o3 == null ? _(t3) : o3, t3.__h), z(u3, t3), t3.__e != o3 && k(t3)));
    });
}
function w(n2, l3, u3, i3, t3, o3, r3, c3, s3, a3) {
  var h3, y3, d3, k4, b3, g4, w4, x4 = i3 && i3.__k || e, C3 = x4.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if ((k4 = u3.__k[h3] = (k4 = l3[h3]) == null || typeof k4 == "boolean" ? null : typeof k4 == "string" || typeof k4 == "number" || typeof k4 == "bigint" ? v(null, k4, null, null, k4) : Array.isArray(k4) ? v(p, { children: k4 }, null, null, null) : k4.__b > 0 ? v(k4.type, k4.props, k4.key, k4.ref ? k4.ref : null, k4.__v) : k4) != null) {
      if (k4.__ = u3, k4.__b = u3.__b + 1, (d3 = x4[h3]) === null || d3 && k4.key == d3.key && k4.type === d3.type)
        x4[h3] = void 0;
      else
        for (y3 = 0; y3 < C3; y3++) {
          if ((d3 = x4[y3]) && k4.key == d3.key && k4.type === d3.type) {
            x4[y3] = void 0;
            break;
          }
          d3 = null;
        }
      j(n2, k4, d3 = d3 || f, t3, o3, r3, c3, s3, a3), b3 = k4.__e, (y3 = k4.ref) && d3.ref != y3 && (w4 || (w4 = []), d3.ref && w4.push(d3.ref, null, k4), w4.push(y3, k4.__c || b3, k4)), b3 != null ? (g4 == null && (g4 = b3), typeof k4.type == "function" && k4.__k === d3.__k ? k4.__d = s3 = m(k4, s3, n2) : s3 = A(n2, k4, d3, x4, b3, s3), typeof u3.type == "function" && (u3.__d = s3)) : s3 && d3.__e == s3 && s3.parentNode != n2 && (s3 = _(d3));
    }
  for (u3.__e = g4, h3 = C3; h3--; )
    x4[h3] != null && N(x4[h3], x4[h3]);
  if (w4)
    for (h3 = 0; h3 < w4.length; h3++)
      M(w4[h3], w4[++h3], w4[++h3]);
}
function m(n2, l3, u3) {
  for (var i3, t3 = n2.__k, o3 = 0; t3 && o3 < t3.length; o3++)
    (i3 = t3[o3]) && (i3.__ = n2, l3 = typeof i3.type == "function" ? m(i3, l3, u3) : A(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function x(n2, l3) {
  return l3 = l3 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    x(n3, l3);
  }) : l3.push(n2)), l3;
}
function A(n2, l3, u3, i3, t3, o3) {
  var r3, f4, e3;
  if (l3.__d !== void 0)
    r3 = l3.__d, l3.__d = void 0;
  else if (u3 == null || t3 != o3 || t3.parentNode == null)
    n:
      if (o3 == null || o3.parentNode !== n2)
        n2.appendChild(t3), r3 = null;
      else {
        for (f4 = o3, e3 = 0; (f4 = f4.nextSibling) && e3 < i3.length; e3 += 1)
          if (f4 == t3)
            break n;
        n2.insertBefore(t3, o3), r3 = o3;
      }
  return r3 !== void 0 ? r3 : t3.nextSibling;
}
function C(n2, l3, u3, i3, t3) {
  var o3;
  for (o3 in u3)
    o3 === "children" || o3 === "key" || o3 in l3 || H(n2, o3, null, u3[o3], i3);
  for (o3 in l3)
    t3 && typeof l3[o3] != "function" || o3 === "children" || o3 === "key" || o3 === "value" || o3 === "checked" || u3[o3] === l3[o3] || H(n2, o3, l3[o3], u3[o3], i3);
}
function $(n2, l3, u3) {
  l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = u3 == null ? "" : typeof u3 != "number" || c.test(l3) ? u3 : u3 + "px";
}
function H(n2, l3, u3, i3, t3) {
  var o3;
  n:
    if (l3 === "style")
      if (typeof u3 == "string")
        n2.style.cssText = u3;
      else {
        if (typeof i3 == "string" && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || $(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || $(n2.style, l3, u3[l3]);
      }
    else if (l3[0] === "o" && l3[1] === "n")
      o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? i3 || n2.addEventListener(l3, o3 ? T : I, o3) : n2.removeEventListener(l3, o3 ? T : I, o3);
    else if (l3 !== "dangerouslySetInnerHTML") {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l3 !== "href" && l3 !== "list" && l3 !== "form" && l3 !== "tabIndex" && l3 !== "download" && l3 in n2)
        try {
          n2[l3] = u3 == null ? "" : u3;
          break n;
        } catch (n3) {
        }
      typeof u3 == "function" || (u3 == null || u3 === false && l3.indexOf("-") == -1 ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function I(n2) {
  this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function T(n2) {
  this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function j(n2, u3, i3, t3, o3, r3, f4, e3, c3) {
  var a3, h3, v3, y3, _3, k4, b3, g4, m3, x4, A4, C3, $3, H3, I3, T5 = u3.type;
  if (u3.constructor !== void 0)
    return null;
  i3.__h != null && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, r3 = [e3]), (a3 = l.__b) && a3(u3);
  try {
    n:
      if (typeof T5 == "function") {
        if (g4 = u3.props, m3 = (a3 = T5.contextType) && t3[a3.__c], x4 = a3 ? m3 ? m3.props.value : a3.__ : t3, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in T5 && T5.prototype.render ? u3.__c = h3 = new T5(g4, x4) : (u3.__c = h3 = new d(g4, x4), h3.constructor = T5, h3.render = O), m3 && m3.sub(h3), h3.props = g4, h3.state || (h3.state = {}), h3.context = x4, h3.__n = t3, v3 = h3.__d = true, h3.__h = [], h3._sb = []), h3.__s == null && (h3.__s = h3.state), T5.getDerivedStateFromProps != null && (h3.__s == h3.state && (h3.__s = s({}, h3.__s)), s(h3.__s, T5.getDerivedStateFromProps(g4, h3.__s))), y3 = h3.props, _3 = h3.state, v3)
          T5.getDerivedStateFromProps == null && h3.componentWillMount != null && h3.componentWillMount(), h3.componentDidMount != null && h3.__h.push(h3.componentDidMount);
        else {
          if (T5.getDerivedStateFromProps == null && g4 !== y3 && h3.componentWillReceiveProps != null && h3.componentWillReceiveProps(g4, x4), !h3.__e && h3.shouldComponentUpdate != null && h3.shouldComponentUpdate(g4, h3.__s, x4) === false || u3.__v === i3.__v) {
            for (h3.props = g4, h3.state = h3.__s, u3.__v !== i3.__v && (h3.__d = false), h3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), A4 = 0; A4 < h3._sb.length; A4++)
              h3.__h.push(h3._sb[A4]);
            h3._sb = [], h3.__h.length && f4.push(h3);
            break n;
          }
          h3.componentWillUpdate != null && h3.componentWillUpdate(g4, h3.__s, x4), h3.componentDidUpdate != null && h3.__h.push(function() {
            h3.componentDidUpdate(y3, _3, k4);
          });
        }
        if (h3.context = x4, h3.props = g4, h3.__v = u3, h3.__P = n2, C3 = l.__r, $3 = 0, "prototype" in T5 && T5.prototype.render) {
          for (h3.state = h3.__s, h3.__d = false, C3 && C3(u3), a3 = h3.render(h3.props, h3.state, h3.context), H3 = 0; H3 < h3._sb.length; H3++)
            h3.__h.push(h3._sb[H3]);
          h3._sb = [];
        } else
          do {
            h3.__d = false, C3 && C3(u3), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
          } while (h3.__d && ++$3 < 25);
        h3.state = h3.__s, h3.getChildContext != null && (t3 = s(s({}, t3), h3.getChildContext())), v3 || h3.getSnapshotBeforeUpdate == null || (k4 = h3.getSnapshotBeforeUpdate(y3, _3)), I3 = a3 != null && a3.type === p && a3.key == null ? a3.props.children : a3, w(n2, Array.isArray(I3) ? I3 : [I3], u3, i3, t3, o3, r3, f4, e3, c3), h3.base = u3.__e, u3.__h = null, h3.__h.length && f4.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
      } else
        r3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = L(i3.__e, u3, i3, t3, o3, r3, f4, c3);
    (a3 = l.diffed) && a3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || r3 != null) && (u3.__e = e3, u3.__h = !!c3, r3[r3.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function z(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function L(l3, u3, i3, t3, o3, r3, e3, c3) {
  var s3, h3, v3, y3 = i3.props, p3 = u3.props, d3 = u3.type, k4 = 0;
  if (d3 === "svg" && (o3 = true), r3 != null) {
    for (; k4 < r3.length; k4++)
      if ((s3 = r3[k4]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : s3.nodeType === 3)) {
        l3 = s3, r3[k4] = null;
        break;
      }
  }
  if (l3 == null) {
    if (d3 === null)
      return document.createTextNode(p3);
    l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p3.is && p3), r3 = null, c3 = false;
  }
  if (d3 === null)
    y3 === p3 || c3 && l3.data === p3 || (l3.data = p3);
  else {
    if (r3 = r3 && n.call(l3.childNodes), h3 = (y3 = i3.props || f).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c3) {
      if (r3 != null)
        for (y3 = {}, k4 = 0; k4 < l3.attributes.length; k4++)
          y3[l3.attributes[k4].name] = l3.attributes[k4].value;
      (v3 || h3) && (v3 && (h3 && v3.__html == h3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if (C(l3, p3, y3, o3, c3), v3)
      u3.__k = [];
    else if (k4 = u3.props.children, w(l3, Array.isArray(k4) ? k4 : [k4], u3, i3, t3, o3 && d3 !== "foreignObject", r3, e3, r3 ? r3[0] : i3.__k && _(i3, 0), c3), r3 != null)
      for (k4 = r3.length; k4--; )
        r3[k4] != null && a(r3[k4]);
    c3 || ("value" in p3 && (k4 = p3.value) !== void 0 && (k4 !== l3.value || d3 === "progress" && !k4 || d3 === "option" && k4 !== y3.value) && H(l3, "value", k4, y3.value, false), "checked" in p3 && (k4 = p3.checked) !== void 0 && k4 !== l3.checked && H(l3, "checked", k4, y3.checked, false));
  }
  return l3;
}
function M(n2, u3, i3) {
  try {
    typeof n2 == "function" ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function N(n2, u3, i3) {
  var t3, o3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || M(t3, null, u3)), (t3 = n2.__c) != null) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (o3 = 0; o3 < t3.length; o3++)
      t3[o3] && N(t3[o3], u3, i3 || typeof n2.type != "function");
  i3 || n2.__e == null || a(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function O(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function P(u3, i3, t3) {
  var o3, r3, e3;
  l.__ && l.__(u3, i3), r3 = (o3 = typeof t3 == "function") ? null : t3 && t3.__k || i3.__k, e3 = [], j(i3, u3 = (!o3 && t3 || i3).__k = h(p, null, [u3]), r3 || f, f, i3.ownerSVGElement !== void 0, !o3 && t3 ? [t3] : r3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, e3, !o3 && t3 ? t3 : r3 ? r3.__e : i3.firstChild, o3), z(e3, u3);
}
function S(n2, l3) {
  P(n2, l3, S);
}
function q(l3, u3, i3) {
  var t3, o3, r3, f4 = s({}, l3.props);
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f4[r3] = u3[r3];
  return arguments.length > 2 && (f4.children = arguments.length > 3 ? n.call(arguments, 2) : i3), v(l3.type, f4, t3 || l3.key, o3 || l3.ref, null);
}
function B(n2, l3) {
  var u3 = { __c: l3 = "__cC" + r++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(b);
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = e.slice, l = { __e: function(n2, l3, u3, i3) {
  for (var t3, o3, r3; l3 = l3.__; )
    if ((t3 = l3.__c) && !t3.__)
      try {
        if ((o3 = t3.constructor) && o3.getDerivedStateFromError != null && (t3.setState(o3.getDerivedStateFromError(n2)), r3 = t3.__d), t3.componentDidCatch != null && (t3.componentDidCatch(n2, i3 || {}), r3 = t3.__d), r3)
          return t3.__E = t3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return n2 != null && n2.constructor === void 0;
}, d.prototype.setState = function(n2, l3) {
  var u3;
  u3 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), typeof n2 == "function" && (n2 = n2(s({}, u3), this.props)), n2 && s(u3, n2), n2 != null && this.__v && (l3 && this._sb.push(l3), b(this));
}, d.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), b(this));
}, d.prototype.render = p, t = [], g.__r = 0, r = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function d2(t3, u3) {
  l.__h && l.__h(r2, t3, o2 || u3), o2 = 0;
  var i3 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t3 >= i3.__.length && i3.__.push({ __V: c2 }), i3.__[t3];
}
function p2(n2) {
  return o2 = 1, y2(B2, n2);
}
function y2(n2, u3, i3) {
  var o3 = d2(t2++, 2);
  if (o3.t = n2, !o3.__c && (o3.__ = [i3 ? i3(u3) : B2(void 0, u3), function(n3) {
    var t3 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t3, n3);
    t3 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r2, !r2.u)) {
    r2.u = true;
    var f4 = r2.shouldComponentUpdate;
    r2.shouldComponentUpdate = function(n3, t3, r3) {
      if (!o3.__c.__H)
        return true;
      var u4 = o3.__c.__H.__.filter(function(n4) {
        return n4.__c;
      });
      if (u4.every(function(n4) {
        return !n4.__N;
      }))
        return !f4 || f4.call(this, n3, t3, r3);
      var i4 = false;
      return u4.forEach(function(n4) {
        if (n4.__N) {
          var t4 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t4 !== n4.__[0] && (i4 = true);
        }
      }), !(!i4 && o3.__c.props === n3) && (!f4 || f4.call(this, n3, t3, r3));
    };
  }
  return o3.__N || o3.__;
}
function h2(u3, i3) {
  var o3 = d2(t2++, 3);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__H.__h.push(o3));
}
function s2(u3, i3) {
  var o3 = d2(t2++, 4);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__h.push(o3));
}
function _2(n2) {
  return o2 = 5, F(function() {
    return { current: n2 };
  }, []);
}
function A2(n2, t3, r3) {
  o2 = 6, s2(function() {
    return typeof n2 == "function" ? (n2(t3()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t3(), function() {
      return n2.current = null;
    }) : void 0;
  }, r3 == null ? r3 : r3.concat(n2));
}
function F(n2, r3) {
  var u3 = d2(t2++, 7);
  return z2(u3.__H, r3) ? (u3.__V = n2(), u3.i = r3, u3.__h = n2, u3.__V) : u3.__;
}
function T2(n2, t3) {
  return o2 = 8, F(function() {
    return n2;
  }, t3);
}
function q2(n2) {
  var u3 = r2.context[n2.__c], i3 = d2(t2++, 9);
  return i3.c = n2, u3 ? (i3.__ == null && (i3.__ = true, u3.sub(r2)), u3.props.value) : n2.__;
}
function x2(t3, r3) {
  l.useDebugValue && l.useDebugValue(r3 ? r3(t3) : t3);
}
function V() {
  var n2 = d2(t2++, 11);
  if (!n2.__) {
    for (var u3 = r2.__v; u3 !== null && !u3.__m && u3.__ !== null; )
      u3 = u3.__;
    var i3 = u3.__m || (u3.__m = [0, 0]);
    n2.__ = "P" + i3[0] + "-" + i3[1]++;
  }
  return n2.__;
}
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o3 = t3.__c;
  o3 && o3.__H && (o3.__H.__h.length && (f2.push(o3) !== 1 && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = typeof requestAnimationFrame == "function";
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  typeof u3 == "function" && (n2.__c = void 0, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}
function z2(n2, t3) {
  return !n2 || n2.length !== t3.length || t3.some(function(t4, r3) {
    return t4 !== n2[r3];
  });
}
function B2(n2, t3) {
  return typeof t3 == "function" ? t3(n2) : t3;
}

// node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if (e3 !== "__source" && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if (r3 !== "__source" && n2[r3] !== t3[r3])
      return true;
  return false;
}
function E(n2, t3) {
  return n2 === t3 && (n2 !== 0 || 1 / n2 == 1 / t3) || n2 != n2 && t3 != t3;
}
function w3(n2) {
  this.props = n2;
}
function R(n2, e3) {
  function r3(n3) {
    var t3 = this.props.ref, r4 = t3 == n3.ref;
    return !r4 && t3 && (t3.call ? t3(null) : t3.current = null), e3 ? !e3(this.props, n3) || !r4 : C2(this.props, n3);
  }
  function u3(e4) {
    return this.shouldComponentUpdate = r3, h(n2, e4);
  }
  return u3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u3.prototype.isReactComponent = true, u3.__f = true, u3;
}
(w3.prototype = new d()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function k3(n2) {
  function t3(t4) {
    var e3 = g3({}, t4);
    return delete e3.ref, n2(e3, t4.ref || null);
  }
  return t3.$$typeof = N2, t3.render = t3, t3.prototype.isReactComponent = t3.__f = true, t3.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t3;
}
var A3 = function(n2, t3) {
  return n2 == null ? null : x(x(n2).map(t3));
};
var O2 = { map: A3, forEach: A3, count: function(n2) {
  return n2 ? x(n2).length : 0;
}, only: function(n2) {
  var t3 = x(n2);
  if (t3.length !== 1)
    throw "Children.only";
  return t3[0];
}, toArray: x };
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o3 = t3; o3 = o3.__; )
      if ((u3 = o3.__c) && u3.__c)
        return t3.__e == null && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    typeof n3.__c == "function" && n3.__c();
  }), n2.__c.__H = null), (n2 = g3({}, n2)).__c != null && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F2(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function M2(n2) {
  var e3, r3, u3;
  function o3(o4) {
    if (e3 || (e3 = n2()).then(function(n3) {
      r3 = n3.default || n3;
    }, function(n3) {
      u3 = n3;
    }), u3)
      throw u3;
    if (!r3)
      throw e3;
    return h(r3, o4);
  }
  return o3.displayName = "Lazy", o3.__f = true, o3;
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && n2.__h === true && (n2.type = null), I2 && I2(n2);
}, (D.prototype = new d()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  r3.t == null && (r3.t = []), r3.t.push(e3);
  var u3 = F2(r3.__v), o3 = false, i3 = function() {
    o3 || (o3 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = t3.__h === true;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D.prototype.componentWillUnmount = function() {
  this.t = [];
}, D.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o3 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o3.__O = o3.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && h(p, null, n2.fallback);
  return i3 && (i3.__h = null), [h(p, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.o.size))
    for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    P(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), P(h(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = h($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new d()).__a = function(n2) {
  var t3 = this, e3 = F2(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o3 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o3) : o3();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = x(n2.children);
  n2.revealOrder && n2.revealOrder[0] === "b" && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z3 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
var B3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = typeof document != "undefined";
var Z = function(n2) {
  return (typeof Symbol != "undefined" && typeof Symbol() == "symbol" ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
function Y(n2, t3, e3) {
  return t3.__k == null && (t3.textContent = ""), P(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
function q3(n2, t3, e3) {
  return S(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
d.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(d.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G && (n2 = G(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u3 = e3;
  if (typeof t3 == "string") {
    var o3 = t3.indexOf("-") === -1;
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && i3 === "children" && t3 === "noscript" || i3 === "value" && "defaultValue" in e3 && l3 == null || (i3 === "defaultValue" && "value" in e3 && e3.value == null ? i3 = "value" : i3 === "download" && l3 === true ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o3 && B3.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : l3 === null && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    t3 == "select" && u3.multiple && Array.isArray(u3.value) && (u3.value = x(e3.children).forEach(function(n3) {
      n3.props.selected = u3.value.indexOf(n3.props.value) != -1;
    })), t3 == "select" && u3.defaultValue != null && (u3.value = x(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? u3.defaultValue.indexOf(n3.props.value) != -1 : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, e3.className != null && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z3, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};
var rn = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
  return X.__n[n2.__c].props.value;
} } } };
function on(n2) {
  return h.bind(null, n2);
}
function ln(n2) {
  return !!n2 && n2.$$typeof === z3;
}
function cn(n2) {
  return ln(n2) ? q.apply(null, arguments) : n2;
}
function fn(n2) {
  return !!n2.__k && (P(null, n2), true);
}
function an(n2) {
  return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
}
var sn = function(n2, t3) {
  return n2(t3);
};
var hn = function(n2, t3) {
  return n2(t3);
};
var vn = p;
function dn(n2) {
  n2();
}
function pn(n2) {
  return n2;
}
function mn() {
  return [false, dn];
}
var yn = s2;
function _n(n2, t3) {
  var e3 = t3(), r3 = p2({ h: { __: e3, v: t3 } }), u3 = r3[0].h, o3 = r3[1];
  return s2(function() {
    u3.__ = e3, u3.v = t3, E(u3.__, t3()) || o3({ h: u3 });
  }, [n2, e3, t3]), h2(function() {
    return E(u3.__, u3.v()) || o3({ h: u3 }), n2(function() {
      E(u3.__, u3.v()) || o3({ h: u3 });
    });
  }, [n2]), e3;
}
var bn = { useState: p2, useId: V, useReducer: y2, useEffect: h2, useLayoutEffect: s2, useInsertionEffect: yn, useTransition: mn, useDeferredValue: pn, useSyncExternalStore: _n, startTransition: dn, useRef: _2, useImperativeHandle: A2, useMemo: F, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: O2, render: Y, hydrate: q3, unmountComponentAtNode: fn, createPortal: j3, createElement: h, createContext: B, createFactory: on, cloneElement: cn, createRef: y, Fragment: p, isValidElement: ln, findDOMNode: an, Component: d, PureComponent: w3, memo: R, forwardRef: k3, flushSync: hn, unstable_batchedUpdates: sn, StrictMode: vn, Suspense: D, SuspenseList: V2, lazy: M2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: rn };

// node_modules/preact/compat/client.mjs
function createRoot(container) {
  return {
    render(children) {
      Y(children, container);
    },
    unmount() {
      fn(container);
    }
  };
}

// node_modules/recoil/es/recoil.js
function isPromise(p3) {
  return !!p3 && typeof p3.then === "function";
}
var Recoil_isPromise = isPromise;
function nullthrows(x4, message) {
  if (x4 != null) {
    return x4;
  }
  throw new Error(message !== null && message !== void 0 ? message : "Got unexpected null or undefined");
}
var Recoil_nullthrows = nullthrows;
var Canceled = class {
};
var CANCELED = new Canceled();
var loadableAccessors = {
  valueMaybe() {
    return void 0;
  },
  valueOrThrow() {
    const error = new Error(`Loadable expected value, but in "${this.state}" state`);
    throw error;
  },
  errorMaybe() {
    return void 0;
  },
  errorOrThrow() {
    const error = new Error(`Loadable expected error, but in "${this.state}" state`);
    throw error;
  },
  promiseMaybe() {
    return void 0;
  },
  promiseOrThrow() {
    const error = new Error(`Loadable expected promise, but in "${this.state}" state`);
    throw error;
  },
  is(other) {
    return other.state === this.state && other.contents === this.contents;
  },
  map(map) {
    if (this.state === "hasError") {
      return this;
    }
    if (this.state === "hasValue") {
      try {
        const next = map(this.contents);
        return Recoil_isPromise(next) ? loadableWithPromise(next.then((value) => ({
          __value: value
        }))) : loadableWithValue(next);
      } catch (e3) {
        return Recoil_isPromise(e3) ? loadableWithPromise(e3.next(() => map(this.contents))) : loadableWithError(e3);
      }
    }
    if (this.state === "loading") {
      return loadableWithPromise(this.contents.then((value) => ({
        __value: map(value.__value)
      })).catch((e3) => {
        if (Recoil_isPromise(e3)) {
          return e3.then(() => map(this.contents));
        }
        throw e3;
      }));
    }
    const error = new Error("Invalid Loadable state");
    throw error;
  }
};
function loadableWithValue(value) {
  return Object.freeze({
    state: "hasValue",
    contents: value,
    ...loadableAccessors,
    getValue() {
      return this.contents;
    },
    toPromise() {
      return Promise.resolve(this.contents);
    },
    valueMaybe() {
      return this.contents;
    },
    valueOrThrow() {
      return this.contents;
    }
  });
}
function loadableWithError(error) {
  return Object.freeze({
    state: "hasError",
    contents: error,
    ...loadableAccessors,
    getValue() {
      throw this.contents;
    },
    toPromise() {
      return Promise.reject(this.contents);
    },
    errorMaybe() {
      return this.contents;
    },
    errorOrThrow() {
      return this.contents;
    }
  });
}
function loadableWithPromise(promise) {
  return Object.freeze({
    state: "loading",
    contents: promise,
    ...loadableAccessors,
    getValue() {
      throw this.contents.then(({
        __value
      }) => __value);
    },
    toPromise() {
      return this.contents.then(({
        __value
      }) => __value);
    },
    promiseMaybe() {
      return this.contents.then(({
        __value
      }) => __value);
    },
    promiseOrThrow() {
      return this.contents.then(({
        __value
      }) => __value);
    }
  });
}
function loadableLoading() {
  return loadableWithPromise(new Promise(() => {
  }));
}
function loadableAll(inputs) {
  return inputs.every((i3) => i3.state === "hasValue") ? loadableWithValue(inputs.map((i3) => i3.contents)) : inputs.some((i3) => i3.state === "hasError") ? loadableWithError(Recoil_nullthrows(inputs.find((i3) => i3.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : loadableWithPromise(Promise.all(inputs.map((i3) => i3.contents)).then((value) => ({
    __value: value
  })));
}
var Recoil_Loadable = {
  loadableWithValue,
  loadableWithError,
  loadableWithPromise,
  loadableLoading,
  loadableAll,
  Canceled,
  CANCELED
};
var _useMutableSource;
var useMutableSource = (_useMutableSource = bn.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : bn.unstable_useMutableSource;
function mutableSourceExists() {
  return useMutableSource && !(typeof window !== "undefined" && window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE);
}
var Recoil_mutableSource = {
  mutableSourceExists,
  useMutableSource
};
var {
  mutableSourceExists: mutableSourceExists$1
} = Recoil_mutableSource;
var gks = (/* @__PURE__ */ new Map()).set("recoil_hamt_2020", true).set("recoil_memory_managament_2020", true).set("recoil_suppress_rerender_in_callback", true);
function Recoil_gkx(gk) {
  var _gks$get;
  if (gk === "recoil_early_rendering_2021" && !mutableSourceExists$1()) {
    return false;
  }
  return (_gks$get = gks.get(gk)) !== null && _gks$get !== void 0 ? _gks$get : false;
}
Recoil_gkx.setPass = (gk) => {
  gks.set(gk, true);
};
Recoil_gkx.setFail = (gk) => {
  gks.set(gk, false);
};
var Recoil_gkx_1 = Recoil_gkx;
function recoverableViolation(message, projectName, {
  error
} = {}) {
  if (true) {
    console.error(message, error);
  }
  return null;
}
var recoverableViolation_1 = recoverableViolation;
var Recoil_recoverableViolation = recoverableViolation_1;
function setByAddingToSet(set, v3) {
  const next = new Set(set);
  next.add(v3);
  return next;
}
function setByDeletingFromSet(set, v3) {
  const next = new Set(set);
  next.delete(v3);
  return next;
}
function mapBySettingInMap(map, k4, v3) {
  const next = new Map(map);
  next.set(k4, v3);
  return next;
}
function mapByUpdatingInMap(map, k4, updater) {
  const next = new Map(map);
  next.set(k4, updater(next.get(k4)));
  return next;
}
function mapByDeletingFromMap(map, k4) {
  const next = new Map(map);
  next.delete(k4);
  return next;
}
function mapByDeletingMultipleFromMap(map, ks) {
  const next = new Map(map);
  ks.forEach((k4) => next.delete(k4));
  return next;
}
var Recoil_CopyOnWrite = {
  setByAddingToSet,
  setByDeletingFromSet,
  mapBySettingInMap,
  mapByUpdatingInMap,
  mapByDeletingFromMap,
  mapByDeletingMultipleFromMap
};
function* filterIterable(iterable, predicate) {
  let index = 0;
  for (const value of iterable) {
    if (predicate(value, index++)) {
      yield value;
    }
  }
}
var Recoil_filterIterable = filterIterable;
function mapIterable(iterable, callback) {
  return function* () {
    let index = 0;
    for (const value of iterable) {
      yield callback(value, index++);
    }
  }();
}
var Recoil_mapIterable = mapIterable;
function sprintf(format2, ...args) {
  let index = 0;
  return format2.replace(/%s/g, () => String(args[index++]));
}
var sprintf_1 = sprintf;
function expectationViolation(format2, ...args) {
  if (true) {
    const message = sprintf_1.call(null, format2, ...args);
    const error = new Error(message);
    error.name = "Expectation Violation";
    console.error(error);
  }
}
var expectationViolation_1 = expectationViolation;
var Recoil_expectationViolation = expectationViolation_1;
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var AbstractRecoilValue = class {
  constructor(newKey) {
    _defineProperty(this, "key", void 0);
    this.key = newKey;
  }
};
var RecoilState = class extends AbstractRecoilValue {
};
var RecoilValueReadOnly = class extends AbstractRecoilValue {
};
function isRecoilValue(x4) {
  return x4 instanceof RecoilState || x4 instanceof RecoilValueReadOnly;
}
var Recoil_RecoilValue = {
  AbstractRecoilValue,
  RecoilState,
  RecoilValueReadOnly,
  isRecoilValue
};
var Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;
var Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;
var Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;
var Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;
var Recoil_RecoilValue$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AbstractRecoilValue: Recoil_RecoilValue_1,
  RecoilState: Recoil_RecoilValue_2,
  RecoilValueReadOnly: Recoil_RecoilValue_3,
  isRecoilValue: Recoil_RecoilValue_4
});
var DefaultValue = class {
};
var DEFAULT_VALUE = new DefaultValue();
var RecoilValueNotReady = class extends Error {
  constructor(key2) {
    super(`Tried to set the value of Recoil selector ${key2} using an updater function, but it is an async selector in a pending or error state; this is not supported.`);
  }
};
var nodes = /* @__PURE__ */ new Map();
var recoilValues = /* @__PURE__ */ new Map();
function recoilValuesForKeys(keys) {
  return Recoil_mapIterable(keys, (key2) => Recoil_nullthrows(recoilValues.get(key2)));
}
function registerNode(node) {
  if (nodes.has(node.key)) {
    const message = `Duplicate atom key "${node.key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;
    console.warn(message);
  }
  nodes.set(node.key, node);
  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);
  recoilValues.set(node.key, recoilValue);
  return recoilValue;
}
var NodeMissingError = class extends Error {
};
function getNode(key2) {
  const node = nodes.get(key2);
  if (node == null) {
    throw new NodeMissingError(`Missing definition for RecoilValue: "${key2}""`);
  }
  return node;
}
function getNodeMaybe(key2) {
  return nodes.get(key2);
}
var configDeletionHandlers = /* @__PURE__ */ new Map();
function deleteNodeConfigIfPossible(key2) {
  var _node$shouldDeleteCon;
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  const node = nodes.get(key2);
  if (node === null || node === void 0 ? void 0 : (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) === null || _node$shouldDeleteCon === void 0 ? void 0 : _node$shouldDeleteCon.call(node)) {
    var _getConfigDeletionHan;
    nodes.delete(key2);
    (_getConfigDeletionHan = getConfigDeletionHandler(key2)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();
    configDeletionHandlers.delete(key2);
  }
}
function setConfigDeletionHandler(key2, fn3) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  if (fn3 === void 0) {
    configDeletionHandlers.delete(key2);
  } else {
    configDeletionHandlers.set(key2, fn3);
  }
}
function getConfigDeletionHandler(key2) {
  return configDeletionHandlers.get(key2);
}
var Recoil_Node = {
  nodes,
  recoilValues,
  registerNode,
  getNode,
  getNodeMaybe,
  deleteNodeConfigIfPossible,
  setConfigDeletionHandler,
  getConfigDeletionHandler,
  recoilValuesForKeys,
  NodeMissingError,
  DefaultValue,
  DEFAULT_VALUE,
  RecoilValueNotReady
};
var RetentionZone = class {
};
function retentionZone() {
  return new RetentionZone();
}
var Recoil_RetentionZone = {
  RetentionZone,
  retentionZone
};
var {
  setByAddingToSet: setByAddingToSet$1
} = Recoil_CopyOnWrite;
var {
  getNode: getNode$1,
  getNodeMaybe: getNodeMaybe$1,
  recoilValuesForKeys: recoilValuesForKeys$1
} = Recoil_Node;
var {
  RetentionZone: RetentionZone$1
} = Recoil_RetentionZone;
var emptySet = Object.freeze(/* @__PURE__ */ new Set());
var ReadOnlyRecoilValueError = class extends Error {
};
function initializeRetentionForNode(store, nodeKey, retainedBy) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return () => void 0;
  }
  const {
    nodesRetainedByZone: nodesRetainedByZone2
  } = store.getState().retention;
  function addToZone(zone) {
    let set = nodesRetainedByZone2.get(zone);
    if (!set) {
      nodesRetainedByZone2.set(zone, set = /* @__PURE__ */ new Set());
    }
    set.add(nodeKey);
  }
  if (retainedBy instanceof RetentionZone$1) {
    addToZone(retainedBy);
  } else if (Array.isArray(retainedBy)) {
    for (const zone of retainedBy) {
      addToZone(zone);
    }
  }
  return () => {
    if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
      return;
    }
    const nodesRetainedByZone3 = store.getState().retention.nodesRetainedByZone;
    function deleteFromZone(zone) {
      const set = nodesRetainedByZone3.get(zone);
      if (set) {
        set.delete(nodeKey);
      }
      if (set && set.size === 0) {
        nodesRetainedByZone3.delete(zone);
      }
    }
    if (retainedBy instanceof RetentionZone$1) {
      deleteFromZone(retainedBy);
    } else if (Array.isArray(retainedBy)) {
      for (const zone of retainedBy) {
        deleteFromZone(zone);
      }
    }
  };
}
function initializeNodeIfNewToStore(store, treeState, key2, trigger) {
  const storeState = store.getState();
  if (storeState.nodeCleanupFunctions.has(key2)) {
    return;
  }
  const config = getNode$1(key2);
  const retentionCleanup = initializeRetentionForNode(store, key2, config.retainedBy);
  const nodeCleanup = config.init(store, treeState, trigger);
  storeState.nodeCleanupFunctions.set(key2, () => {
    nodeCleanup();
    retentionCleanup();
  });
}
function cleanUpNode(store, key2) {
  var _state$nodeCleanupFun;
  const state = store.getState();
  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key2)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();
  state.nodeCleanupFunctions.delete(key2);
}
function getNodeLoadable(store, state, key2) {
  initializeNodeIfNewToStore(store, state, key2, "get");
  return getNode$1(key2).get(store, state);
}
function peekNodeLoadable(store, state, key2) {
  return getNode$1(key2).peek(store, state);
}
function setUnvalidatedAtomValue_DEPRECATED(state, key2, newValue) {
  var _node$invalidate;
  const node = getNodeMaybe$1(key2);
  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
  return {
    ...state,
    atomValues: state.atomValues.clone().delete(key2),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key2, newValue),
    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key2)
  };
}
function setNodeValue(store, state, key2, newValue) {
  const node = getNode$1(key2);
  if (node.set == null) {
    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key2}`);
  }
  const set = node.set;
  initializeNodeIfNewToStore(store, state, key2, "set");
  return set(store, state, newValue);
}
function peekNodeInfo(store, state, key2) {
  var _graph$nodeDeps$get, _storeState$nodeToCom, _storeState$nodeToCom2;
  const storeState = store.getState();
  const graph2 = store.getGraph(state.version);
  const type = storeState.knownAtoms.has(key2) ? "atom" : storeState.knownSelectors.has(key2) ? "selector" : void 0;
  const downstreamNodes = Recoil_filterIterable(getDownstreamNodes(store, state, /* @__PURE__ */ new Set([key2])), (nodeKey) => nodeKey !== key2);
  return {
    loadable: peekNodeLoadable(store, state, key2),
    isActive: storeState.knownAtoms.has(key2) || storeState.knownSelectors.has(key2),
    isSet: type === "selector" ? false : state.atomValues.has(key2),
    isModified: state.dirtyAtoms.has(key2),
    type,
    deps: recoilValuesForKeys$1((_graph$nodeDeps$get = graph2.nodeDeps.get(key2)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []),
    subscribers: {
      nodes: recoilValuesForKeys$1(downstreamNodes),
      components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key2)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({
        name
      }))
    }
  };
}
function getDownstreamNodes(store, state, keys) {
  const visitedNodes = /* @__PURE__ */ new Set();
  const visitingNodes = Array.from(keys);
  const graph2 = store.getGraph(state.version);
  for (let key2 = visitingNodes.pop(); key2; key2 = visitingNodes.pop()) {
    var _graph$nodeToNodeSubs;
    visitedNodes.add(key2);
    const subscribedNodes = (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(key2)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;
    for (const downstreamNode of subscribedNodes) {
      if (!visitedNodes.has(downstreamNode)) {
        visitingNodes.push(downstreamNode);
      }
    }
  }
  return visitedNodes;
}
var Recoil_FunctionalCore = {
  getNodeLoadable,
  peekNodeLoadable,
  setNodeValue,
  cleanUpNode,
  setUnvalidatedAtomValue_DEPRECATED,
  peekNodeInfo,
  getDownstreamNodes,
  initializeNodeIfNewToStore
};
var {
  CANCELED: CANCELED$1
} = Recoil_Loadable;
var {
  getDownstreamNodes: getDownstreamNodes$1,
  getNodeLoadable: getNodeLoadable$1,
  setNodeValue: setNodeValue$1
} = Recoil_FunctionalCore;
var {
  getNodeMaybe: getNodeMaybe$2
} = Recoil_Node;
var {
  DefaultValue: DefaultValue$1,
  RecoilValueNotReady: RecoilValueNotReady$1
} = Recoil_Node;
var {
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  isRecoilValue: isRecoilValue$1
} = Recoil_RecoilValue$1;
function getRecoilValueAsLoadable(store, {
  key: key2
}, treeState = store.getState().currentTree) {
  var _storeState$nextTree, _storeState$previousT;
  const storeState = store.getState();
  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation("Tried to read from a discarded tree");
  }
  const loadable = getNodeLoadable$1(store, treeState, key2);
  if (loadable.state === "loading") {
    loadable.contents.catch(() => {
      return CANCELED$1;
    });
  }
  return loadable;
}
function applyAtomValueWrites(atomValues, writes) {
  const result = atomValues.clone();
  writes.forEach((v3, k4) => {
    if (v3.state === "hasValue" && v3.contents instanceof DefaultValue$1) {
      result.delete(k4);
    } else {
      result.set(k4, v3);
    }
  });
  return result;
}
function valueFromValueOrUpdater(store, state, {
  key: key2
}, valueOrUpdater) {
  if (typeof valueOrUpdater === "function") {
    const current = getNodeLoadable$1(store, state, key2);
    if (current.state === "loading") {
      throw new RecoilValueNotReady$1(key2);
    } else if (current.state === "hasError") {
      throw current.contents;
    }
    return valueOrUpdater(current.contents);
  } else {
    return valueOrUpdater;
  }
}
function applyAction(store, state, action) {
  if (action.type === "set") {
    const {
      recoilValue,
      valueOrUpdater
    } = action;
    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);
    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);
    for (const [key2, loadable] of writes.entries()) {
      writeLoadableToTreeState(state, key2, loadable);
    }
  } else if (action.type === "setLoadable") {
    const {
      recoilValue: {
        key: key2
      },
      loadable
    } = action;
    writeLoadableToTreeState(state, key2, loadable);
  } else if (action.type === "markModified") {
    const {
      recoilValue: {
        key: key2
      }
    } = action;
    state.dirtyAtoms.add(key2);
  } else if (action.type === "setUnvalidated") {
    var _node$invalidate;
    const {
      recoilValue: {
        key: key2
      },
      unvalidatedValue
    } = action;
    const node = getNodeMaybe$2(key2);
    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
    state.atomValues.delete(key2);
    state.nonvalidatedAtoms.set(key2, unvalidatedValue);
    state.dirtyAtoms.add(key2);
  } else {
    Recoil_recoverableViolation(`Unknown action ${action.type}`);
  }
}
function writeLoadableToTreeState(state, key2, loadable) {
  if (loadable.state === "hasValue" && loadable.contents instanceof DefaultValue$1) {
    state.atomValues.delete(key2);
  } else {
    state.atomValues.set(key2, loadable);
  }
  state.dirtyAtoms.add(key2);
  state.nonvalidatedAtoms.delete(key2);
}
function applyActionsToStore(store, actions) {
  store.replaceState((state) => {
    const newState = copyTreeState(state);
    for (const action of actions) {
      applyAction(store, newState, action);
    }
    invalidateDownstreams(store, newState);
    return newState;
  });
}
function queueOrPerformStateUpdate(store, action) {
  if (batchStack.length) {
    const actionsByStore = batchStack[batchStack.length - 1];
    let actions = actionsByStore.get(store);
    if (!actions) {
      actionsByStore.set(store, actions = []);
    }
    actions.push(action);
  } else {
    applyActionsToStore(store, [action]);
  }
}
var batchStack = [];
function batchStart() {
  const actionsByStore = /* @__PURE__ */ new Map();
  batchStack.push(actionsByStore);
  return () => {
    for (const [store, actions] of actionsByStore) {
      applyActionsToStore(store, actions);
    }
    const popped = batchStack.pop();
    if (popped !== actionsByStore) {
      Recoil_recoverableViolation("Incorrect order of batch popping");
    }
  };
}
function copyTreeState(state) {
  return {
    ...state,
    atomValues: state.atomValues.clone(),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),
    dirtyAtoms: new Set(state.dirtyAtoms)
  };
}
function invalidateDownstreams(store, state) {
  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);
  for (const key2 of downstreams) {
    var _getNodeMaybe, _getNodeMaybe$invalid;
    (_getNodeMaybe = getNodeMaybe$2(key2)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);
  }
}
function setRecoilValue(store, recoilValue, valueOrUpdater) {
  queueOrPerformStateUpdate(store, {
    type: "set",
    recoilValue,
    valueOrUpdater
  });
}
function setRecoilValueLoadable(store, recoilValue, loadable) {
  if (loadable instanceof DefaultValue$1) {
    return setRecoilValue(store, recoilValue, loadable);
  }
  queueOrPerformStateUpdate(store, {
    type: "setLoadable",
    recoilValue,
    loadable
  });
}
function markRecoilValueModified(store, recoilValue) {
  queueOrPerformStateUpdate(store, {
    type: "markModified",
    recoilValue
  });
}
function setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {
  queueOrPerformStateUpdate(store, {
    type: "setUnvalidated",
    recoilValue,
    unvalidatedValue
  });
}
var subscriptionID = 0;
function subscribeToRecoilValue(store, {
  key: key2
}, callback, componentDebugName = null) {
  const subID = subscriptionID++;
  const storeState = store.getState();
  if (!storeState.nodeToComponentSubscriptions.has(key2)) {
    storeState.nodeToComponentSubscriptions.set(key2, /* @__PURE__ */ new Map());
  }
  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key2)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : "<not captured>", callback]);
  if (Recoil_gkx_1("recoil_early_rendering_2021")) {
    const nextTree = store.getState().nextTree;
    if (nextTree && nextTree.dirtyAtoms.has(key2)) {
      callback(nextTree);
    }
  }
  return {
    release: () => {
      const storeState2 = store.getState();
      const subs = storeState2.nodeToComponentSubscriptions.get(key2);
      if (subs === void 0 || !subs.has(subID)) {
        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key2}. This is a bug in Recoil.`);
        return;
      }
      subs.delete(subID);
      if (subs.size === 0) {
        storeState2.nodeToComponentSubscriptions.delete(key2);
      }
    }
  };
}
var Recoil_RecoilValueInterface = {
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setRecoilValueLoadable,
  markRecoilValueModified,
  setUnvalidatedRecoilValue,
  subscribeToRecoilValue,
  isRecoilValue: isRecoilValue$1,
  applyAtomValueWrites,
  batchStart,
  writeLoadableToTreeState,
  invalidateDownstreams,
  copyTreeState,
  invalidateDownstreams_FOR_TESTING: invalidateDownstreams
};
var {
  unstable_batchedUpdates
} = bn;
var ReactBatchedUpdates = {
  unstable_batchedUpdates
};
var {
  unstable_batchedUpdates: unstable_batchedUpdates$1
} = ReactBatchedUpdates;
var Recoil_ReactBatchedUpdates = {
  unstable_batchedUpdates: unstable_batchedUpdates$1
};
var {
  batchStart: batchStart$1
} = Recoil_RecoilValueInterface;
var {
  unstable_batchedUpdates: unstable_batchedUpdates$2
} = Recoil_ReactBatchedUpdates;
var batcher = unstable_batchedUpdates$2;
var setBatcher = (newBatcher) => {
  batcher = newBatcher;
};
var getBatcher = () => batcher;
var batchUpdates = (callback) => {
  batcher(() => {
    let batchEnd = () => void 0;
    try {
      batchEnd = batchStart$1();
      callback();
    } finally {
      batchEnd();
    }
  });
};
var Recoil_Batching = {
  getBatcher,
  setBatcher,
  batchUpdates
};
function enqueueExecution(s3, f4) {
  f4();
}
var Recoil_Queue = {
  enqueueExecution
};
function differenceSets(set, ...setsWithValuesToRemove) {
  const ret = /* @__PURE__ */ new Set();
  FIRST:
    for (const value of set) {
      for (const otherSet of setsWithValuesToRemove) {
        if (otherSet.has(value)) {
          continue FIRST;
        }
      }
      ret.add(value);
    }
  return ret;
}
var Recoil_differenceSets = differenceSets;
function mapMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  map.forEach((value, key2) => {
    result.set(key2, callback(value, key2));
  });
  return result;
}
var Recoil_mapMap = mapMap;
function graph() {
  return {
    nodeDeps: /* @__PURE__ */ new Map(),
    nodeToNodeSubscriptions: /* @__PURE__ */ new Map()
  };
}
function cloneGraph(graph2) {
  return {
    nodeDeps: Recoil_mapMap(graph2.nodeDeps, (s3) => new Set(s3)),
    nodeToNodeSubscriptions: Recoil_mapMap(graph2.nodeToNodeSubscriptions, (s3) => new Set(s3))
  };
}
function mergeDependencyMapIntoGraph(deps, graph2, olderGraph) {
  const {
    nodeDeps,
    nodeToNodeSubscriptions
  } = graph2;
  deps.forEach((upstreams, downstream) => {
    const existingUpstreams = nodeDeps.get(downstream);
    if (existingUpstreams && olderGraph && existingUpstreams !== olderGraph.nodeDeps.get(downstream)) {
      return;
    }
    nodeDeps.set(downstream, new Set(upstreams));
    const addedUpstreams = existingUpstreams == null ? upstreams : Recoil_differenceSets(upstreams, existingUpstreams);
    addedUpstreams.forEach((upstream) => {
      if (!nodeToNodeSubscriptions.has(upstream)) {
        nodeToNodeSubscriptions.set(upstream, /* @__PURE__ */ new Set());
      }
      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));
      existing.add(downstream);
    });
    if (existingUpstreams) {
      const removedUpstreams = Recoil_differenceSets(existingUpstreams, upstreams);
      removedUpstreams.forEach((upstream) => {
        if (!nodeToNodeSubscriptions.has(upstream)) {
          return;
        }
        const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));
        existing.delete(downstream);
        if (existing.size === 0) {
          nodeToNodeSubscriptions.delete(upstream);
        }
      });
    }
  });
}
function saveDependencyMapToStore(dependencyMap, store, version) {
  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;
  const storeState = store.getState();
  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation("Tried to save dependencies to a discarded tree");
  }
  const graph2 = store.getGraph(version);
  mergeDependencyMapIntoGraph(dependencyMap, graph2);
  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {
    const currentGraph = store.getGraph(storeState.currentTree.version);
    mergeDependencyMapIntoGraph(dependencyMap, currentGraph, graph2);
  }
  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {
    var _storeState$nextTree2;
    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;
    if (nextVersion !== void 0) {
      const nextGraph = store.getGraph(nextVersion);
      mergeDependencyMapIntoGraph(dependencyMap, nextGraph, graph2);
    }
  }
}
function mergeDepsIntoDependencyMap(from, into) {
  from.forEach((upstreamDeps, downstreamNode) => {
    if (!into.has(downstreamNode)) {
      into.set(downstreamNode, /* @__PURE__ */ new Set());
    }
    const deps = Recoil_nullthrows(into.get(downstreamNode));
    upstreamDeps.forEach((dep) => deps.add(dep));
  });
}
function addToDependencyMap(downstream, upstream, dependencyMap) {
  if (!dependencyMap.has(downstream)) {
    dependencyMap.set(downstream, /* @__PURE__ */ new Set());
  }
  Recoil_nullthrows(dependencyMap.get(downstream)).add(upstream);
}
var Recoil_Graph = {
  addToDependencyMap,
  cloneGraph,
  graph,
  mergeDepsIntoDependencyMap,
  saveDependencyMapToStore
};
function createCommonjsModule(fn3, module2) {
  return module2 = { exports: {} }, fn3(module2, module2.exports), module2.exports;
}
var hamt_1 = createCommonjsModule(function(module2) {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var hamt = {};
  var SIZE = 5;
  var BUCKET_SIZE = Math.pow(2, SIZE);
  var MASK = BUCKET_SIZE - 1;
  var MAX_INDEX_NODE = BUCKET_SIZE / 2;
  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;
  var nothing = {};
  var constant = function constant2(x4) {
    return function() {
      return x4;
    };
  };
  var hash3 = hamt.hash = function(str) {
    var type = typeof str === "undefined" ? "undefined" : _typeof(str);
    if (type === "number")
      return str;
    if (type !== "string")
      str += "";
    var hash4 = 0;
    for (var i3 = 0, len = str.length; i3 < len; ++i3) {
      var c3 = str.charCodeAt(i3);
      hash4 = (hash4 << 5) - hash4 + c3 | 0;
    }
    return hash4;
  };
  var popcount = function popcount2(x4) {
    x4 -= x4 >> 1 & 1431655765;
    x4 = (x4 & 858993459) + (x4 >> 2 & 858993459);
    x4 = x4 + (x4 >> 4) & 252645135;
    x4 += x4 >> 8;
    x4 += x4 >> 16;
    return x4 & 127;
  };
  var hashFragment = function hashFragment2(shift, h3) {
    return h3 >>> shift & MASK;
  };
  var toBitmap = function toBitmap2(x4) {
    return 1 << x4;
  };
  var fromBitmap = function fromBitmap2(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  };
  var arrayUpdate = function arrayUpdate2(mutate2, at, v3, arr) {
    var out = arr;
    if (!mutate2) {
      var len = arr.length;
      out = new Array(len);
      for (var i3 = 0; i3 < len; ++i3) {
        out[i3] = arr[i3];
      }
    }
    out[at] = v3;
    return out;
  };
  var arraySpliceOut = function arraySpliceOut2(mutate2, at, arr) {
    var newLen = arr.length - 1;
    var i3 = 0;
    var g4 = 0;
    var out = arr;
    if (mutate2) {
      i3 = g4 = at;
    } else {
      out = new Array(newLen);
      while (i3 < at) {
        out[g4++] = arr[i3++];
      }
    }
    ++i3;
    while (i3 <= newLen) {
      out[g4++] = arr[i3++];
    }
    if (mutate2) {
      out.length = newLen;
    }
    return out;
  };
  var arraySpliceIn = function arraySpliceIn2(mutate2, at, v3, arr) {
    var len = arr.length;
    if (mutate2) {
      var _i = len;
      while (_i >= at) {
        arr[_i--] = arr[_i];
      }
      arr[at] = v3;
      return arr;
    }
    var i3 = 0, g4 = 0;
    var out = new Array(len + 1);
    while (i3 < at) {
      out[g4++] = arr[i3++];
    }
    out[at] = v3;
    while (i3 < len) {
      out[++g4] = arr[i3++];
    }
    return out;
  };
  var LEAF = 1;
  var COLLISION = 2;
  var INDEX = 3;
  var ARRAY = 4;
  var empty = {
    __hamt_isEmpty: true
  };
  var isEmptyNode = function isEmptyNode2(x4) {
    return x4 === empty || x4 && x4.__hamt_isEmpty;
  };
  var Leaf = function Leaf2(edit, hash4, key2, value) {
    return {
      type: LEAF,
      edit,
      hash: hash4,
      key: key2,
      value,
      _modify: Leaf__modify
    };
  };
  var Collision = function Collision2(edit, hash4, children) {
    return {
      type: COLLISION,
      edit,
      hash: hash4,
      children,
      _modify: Collision__modify
    };
  };
  var IndexedNode = function IndexedNode2(edit, mask, children) {
    return {
      type: INDEX,
      edit,
      mask,
      children,
      _modify: IndexedNode__modify
    };
  };
  var ArrayNode = function ArrayNode2(edit, size2, children) {
    return {
      type: ARRAY,
      edit,
      size: size2,
      children,
      _modify: ArrayNode__modify
    };
  };
  var isLeaf = function isLeaf2(node) {
    return node === empty || node.type === LEAF || node.type === COLLISION;
  };
  var expand = function expand2(edit, frag, child, bitmap, subNodes) {
    var arr = [];
    var bit = bitmap;
    var count2 = 0;
    for (var i3 = 0; bit; ++i3) {
      if (bit & 1)
        arr[i3] = subNodes[count2++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return ArrayNode(edit, count2 + 1, arr);
  };
  var pack = function pack2(edit, count2, removed, elements) {
    var children = new Array(count2 - 1);
    var g4 = 0;
    var bitmap = 0;
    for (var i3 = 0, len = elements.length; i3 < len; ++i3) {
      if (i3 !== removed) {
        var elem = elements[i3];
        if (elem && !isEmptyNode(elem)) {
          children[g4++] = elem;
          bitmap |= 1 << i3;
        }
      }
    }
    return IndexedNode(edit, bitmap, children);
  };
  var mergeLeaves = function mergeLeaves2(edit, shift, h1, n1, h22, n2) {
    if (h1 === h22)
      return Collision(edit, h1, [n2, n1]);
    var subH1 = hashFragment(shift, h1);
    var subH2 = hashFragment(shift, h22);
    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift + SIZE, h1, n1, h22, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
  };
  var updateCollisionList = function updateCollisionList2(mutate2, edit, keyEq, h3, list, f4, k4, size2) {
    var len = list.length;
    for (var i3 = 0; i3 < len; ++i3) {
      var child = list[i3];
      if (keyEq(k4, child.key)) {
        var value = child.value;
        var _newValue = f4(value);
        if (_newValue === value)
          return list;
        if (_newValue === nothing) {
          --size2.value;
          return arraySpliceOut(mutate2, i3, list);
        }
        return arrayUpdate(mutate2, i3, Leaf(edit, h3, k4, _newValue), list);
      }
    }
    var newValue = f4();
    if (newValue === nothing)
      return list;
    ++size2.value;
    return arrayUpdate(mutate2, len, Leaf(edit, h3, k4, newValue), list);
  };
  var canEditNode = function canEditNode2(edit, node) {
    return edit === node.edit;
  };
  var Leaf__modify = function Leaf__modify2(edit, keyEq, shift, f4, h3, k4, size2) {
    if (keyEq(k4, this.key)) {
      var _v = f4(this.value);
      if (_v === this.value)
        return this;
      else if (_v === nothing) {
        --size2.value;
        return empty;
      }
      if (canEditNode(edit, this)) {
        this.value = _v;
        return this;
      }
      return Leaf(edit, h3, k4, _v);
    }
    var v3 = f4();
    if (v3 === nothing)
      return this;
    ++size2.value;
    return mergeLeaves(edit, shift, this.hash, this, h3, Leaf(edit, h3, k4, v3));
  };
  var Collision__modify = function Collision__modify2(edit, keyEq, shift, f4, h3, k4, size2) {
    if (h3 === this.hash) {
      var canEdit = canEditNode(edit, this);
      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f4, k4, size2);
      if (list === this.children)
        return this;
      return list.length > 1 ? Collision(edit, this.hash, list) : list[0];
    }
    var v3 = f4();
    if (v3 === nothing)
      return this;
    ++size2.value;
    return mergeLeaves(edit, shift, this.hash, this, h3, Leaf(edit, h3, k4, v3));
  };
  var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift, f4, h3, k4, size2) {
    var mask = this.mask;
    var children = this.children;
    var frag = hashFragment(shift, h3);
    var bit = toBitmap(frag);
    var indx = fromBitmap(mask, bit);
    var exists = mask & bit;
    var current = exists ? children[indx] : empty;
    var child = current._modify(edit, keyEq, shift + SIZE, f4, h3, k4, size2);
    if (current === child)
      return this;
    var canEdit = canEditNode(edit, this);
    var bitmap = mask;
    var newChildren = void 0;
    if (exists && isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return empty;
      if (children.length <= 2 && isLeaf(children[indx ^ 1]))
        return children[indx ^ 1];
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else if (!exists && !isEmptyNode(child)) {
      if (children.length >= MAX_INDEX_NODE)
        return expand(edit, frag, child, mask, children);
      bitmap |= bit;
      newChildren = arraySpliceIn(canEdit, indx, child, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return IndexedNode(edit, bitmap, newChildren);
  };
  var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift, f4, h3, k4, size2) {
    var count2 = this.size;
    var children = this.children;
    var frag = hashFragment(shift, h3);
    var child = children[frag];
    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f4, h3, k4, size2);
    if (child === newChild)
      return this;
    var canEdit = canEditNode(edit, this);
    var newChildren = void 0;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count2;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count2;
      if (count2 <= MIN_ARRAY_NODE)
        return pack(edit, count2, frag, children);
      newChildren = arrayUpdate(canEdit, frag, empty, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count2;
      this.children = newChildren;
      return this;
    }
    return ArrayNode(edit, count2, newChildren);
  };
  empty._modify = function(edit, keyEq, shift, f4, h3, k4, size2) {
    var v3 = f4();
    if (v3 === nothing)
      return empty;
    ++size2.value;
    return Leaf(edit, h3, k4, v3);
  };
  function Map2(editable, edit, config, root, size2) {
    this._editable = editable;
    this._edit = edit;
    this._config = config;
    this._root = root;
    this._size = size2;
  }
  Map2.prototype.setTree = function(newRoot, newSize) {
    if (this._editable) {
      this._root = newRoot;
      this._size = newSize;
      return this;
    }
    return newRoot === this._root ? this : new Map2(this._editable, this._edit, this._config, newRoot, newSize);
  };
  var tryGetHash = hamt.tryGetHash = function(alt, hash4, key2, map) {
    var node = map._root;
    var shift = 0;
    var keyEq = map._config.keyEq;
    while (true) {
      switch (node.type) {
        case LEAF: {
          return keyEq(key2, node.key) ? node.value : alt;
        }
        case COLLISION: {
          if (hash4 === node.hash) {
            var children = node.children;
            for (var i3 = 0, len = children.length; i3 < len; ++i3) {
              var child = children[i3];
              if (keyEq(key2, child.key))
                return child.value;
            }
          }
          return alt;
        }
        case INDEX: {
          var frag = hashFragment(shift, hash4);
          var bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return alt;
        }
        case ARRAY: {
          node = node.children[hashFragment(shift, hash4)];
          if (node) {
            shift += SIZE;
            break;
          }
          return alt;
        }
        default:
          return alt;
      }
    }
  };
  Map2.prototype.tryGetHash = function(alt, hash4, key2) {
    return tryGetHash(alt, hash4, key2, this);
  };
  var tryGet = hamt.tryGet = function(alt, key2, map) {
    return tryGetHash(alt, map._config.hash(key2), key2, map);
  };
  Map2.prototype.tryGet = function(alt, key2) {
    return tryGet(alt, key2, this);
  };
  var getHash = hamt.getHash = function(hash4, key2, map) {
    return tryGetHash(void 0, hash4, key2, map);
  };
  Map2.prototype.getHash = function(hash4, key2) {
    return getHash(hash4, key2, this);
  };
  var get = hamt.get = function(key2, map) {
    return tryGetHash(void 0, map._config.hash(key2), key2, map);
  };
  Map2.prototype.get = function(key2, alt) {
    return tryGet(alt, key2, this);
  };
  var hasHash = hamt.has = function(hash4, key2, map) {
    return tryGetHash(nothing, hash4, key2, map) !== nothing;
  };
  Map2.prototype.hasHash = function(hash4, key2) {
    return hasHash(hash4, key2, this);
  };
  var has = hamt.has = function(key2, map) {
    return hasHash(map._config.hash(key2), key2, map);
  };
  Map2.prototype.has = function(key2) {
    return has(key2, this);
  };
  var defKeyCompare = function defKeyCompare2(x4, y3) {
    return x4 === y3;
  };
  hamt.make = function(config) {
    return new Map2(0, 0, {
      keyEq: config && config.keyEq || defKeyCompare,
      hash: config && config.hash || hash3
    }, empty, 0);
  };
  hamt.empty = hamt.make();
  var isEmpty = hamt.isEmpty = function(map) {
    return map && !!isEmptyNode(map._root);
  };
  Map2.prototype.isEmpty = function() {
    return isEmpty(this);
  };
  var modifyHash = hamt.modifyHash = function(f4, hash4, key2, map) {
    var size2 = {
      value: map._size
    };
    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f4, hash4, key2, size2);
    return map.setTree(newRoot, size2.value);
  };
  Map2.prototype.modifyHash = function(hash4, key2, f4) {
    return modifyHash(f4, hash4, key2, this);
  };
  var modify = hamt.modify = function(f4, key2, map) {
    return modifyHash(f4, map._config.hash(key2), key2, map);
  };
  Map2.prototype.modify = function(key2, f4) {
    return modify(f4, key2, this);
  };
  var setHash = hamt.setHash = function(hash4, key2, value, map) {
    return modifyHash(constant(value), hash4, key2, map);
  };
  Map2.prototype.setHash = function(hash4, key2, value) {
    return setHash(hash4, key2, value, this);
  };
  var set = hamt.set = function(key2, value, map) {
    return setHash(map._config.hash(key2), key2, value, map);
  };
  Map2.prototype.set = function(key2, value) {
    return set(key2, value, this);
  };
  var del = constant(nothing);
  var removeHash = hamt.removeHash = function(hash4, key2, map) {
    return modifyHash(del, hash4, key2, map);
  };
  Map2.prototype.removeHash = Map2.prototype.deleteHash = function(hash4, key2) {
    return removeHash(hash4, key2, this);
  };
  var remove = hamt.remove = function(key2, map) {
    return removeHash(map._config.hash(key2), key2, map);
  };
  Map2.prototype.remove = Map2.prototype.delete = function(key2) {
    return remove(key2, this);
  };
  var beginMutation = hamt.beginMutation = function(map) {
    return new Map2(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
  };
  Map2.prototype.beginMutation = function() {
    return beginMutation(this);
  };
  var endMutation = hamt.endMutation = function(map) {
    map._editable = map._editable && map._editable - 1;
    return map;
  };
  Map2.prototype.endMutation = function() {
    return endMutation(this);
  };
  var mutate = hamt.mutate = function(f4, map) {
    var transient = beginMutation(map);
    f4(transient);
    return endMutation(transient);
  };
  Map2.prototype.mutate = function(f4) {
    return mutate(f4, this);
  };
  var appk = function appk2(k4) {
    return k4 && lazyVisitChildren(k4[0], k4[1], k4[2], k4[3], k4[4]);
  };
  var lazyVisitChildren = function lazyVisitChildren2(len, children, i3, f4, k4) {
    while (i3 < len) {
      var child = children[i3++];
      if (child && !isEmptyNode(child))
        return lazyVisit(child, f4, [len, children, i3, f4, k4]);
    }
    return appk(k4);
  };
  var lazyVisit = function lazyVisit2(node, f4, k4) {
    switch (node.type) {
      case LEAF:
        return {
          value: f4(node),
          rest: k4
        };
      case COLLISION:
      case ARRAY:
      case INDEX:
        var children = node.children;
        return lazyVisitChildren(children.length, children, 0, f4, k4);
      default:
        return appk(k4);
    }
  };
  var DONE = {
    done: true
  };
  function MapIterator(v3) {
    this.v = v3;
  }
  MapIterator.prototype.next = function() {
    if (!this.v)
      return DONE;
    var v0 = this.v;
    this.v = appk(v0.rest);
    return v0;
  };
  MapIterator.prototype[Symbol.iterator] = function() {
    return this;
  };
  var visit = function visit2(map, f4) {
    return new MapIterator(lazyVisit(map._root, f4));
  };
  var buildPairs = function buildPairs2(x4) {
    return [x4.key, x4.value];
  };
  var entries = hamt.entries = function(map) {
    return visit(map, buildPairs);
  };
  Map2.prototype.entries = Map2.prototype[Symbol.iterator] = function() {
    return entries(this);
  };
  var buildKeys = function buildKeys2(x4) {
    return x4.key;
  };
  var keys = hamt.keys = function(map) {
    return visit(map, buildKeys);
  };
  Map2.prototype.keys = function() {
    return keys(this);
  };
  var buildValues = function buildValues2(x4) {
    return x4.value;
  };
  var values = hamt.values = Map2.prototype.values = function(map) {
    return visit(map, buildValues);
  };
  Map2.prototype.values = function() {
    return values(this);
  };
  var fold = hamt.fold = function(f4, z4, m3) {
    var root = m3._root;
    if (root.type === LEAF)
      return f4(z4, root.value, root.key);
    var toVisit = [root.children];
    var children = void 0;
    while (children = toVisit.pop()) {
      for (var i3 = 0, len = children.length; i3 < len; ) {
        var child = children[i3++];
        if (child && child.type) {
          if (child.type === LEAF)
            z4 = f4(z4, child.value, child.key);
          else
            toVisit.push(child.children);
        }
      }
    }
    return z4;
  };
  Map2.prototype.fold = function(f4, z4) {
    return fold(f4, z4, this);
  };
  var forEach = hamt.forEach = function(f4, map) {
    return fold(function(_3, value, key2) {
      return f4(value, key2, map);
    }, null, map);
  };
  Map2.prototype.forEach = function(f4) {
    return forEach(f4, this);
  };
  var count = hamt.count = function(map) {
    return map._size;
  };
  Map2.prototype.count = function() {
    return count(this);
  };
  Object.defineProperty(Map2.prototype, "size", {
    get: Map2.prototype.count
  });
  if (module2.exports) {
    module2.exports = hamt;
  } else {
    (void 0).hamt = hamt;
  }
});
var BuiltInMap = class {
  constructor(existing) {
    _defineProperty(this, "_map", void 0);
    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());
  }
  keys() {
    return this._map.keys();
  }
  entries() {
    return this._map.entries();
  }
  get(k4) {
    return this._map.get(k4);
  }
  has(k4) {
    return this._map.has(k4);
  }
  set(k4, v3) {
    this._map.set(k4, v3);
    return this;
  }
  delete(k4) {
    this._map.delete(k4);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._map);
  }
};
var HashArrayMappedTrieMap = class {
  constructor(existing) {
    _defineProperty(this, "_hamt", hamt_1.empty.beginMutation());
    if (existing instanceof HashArrayMappedTrieMap) {
      const h3 = existing._hamt.endMutation();
      existing._hamt = h3.beginMutation();
      this._hamt = h3.beginMutation();
    } else if (existing) {
      for (const [k4, v3] of existing.entries()) {
        this._hamt.set(k4, v3);
      }
    }
  }
  keys() {
    return this._hamt.keys();
  }
  entries() {
    return this._hamt.entries();
  }
  get(k4) {
    return this._hamt.get(k4);
  }
  has(k4) {
    return this._hamt.has(k4);
  }
  set(k4, v3) {
    this._hamt.set(k4, v3);
    return this;
  }
  delete(k4) {
    this._hamt.delete(k4);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._hamt);
  }
};
function persistentMap(existing) {
  if (Recoil_gkx_1("recoil_hamt_2020")) {
    return new HashArrayMappedTrieMap(existing);
  } else {
    return new BuiltInMap(existing);
  }
}
var Recoil_PersistentMap = {
  persistentMap
};
var Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;
var Recoil_PersistentMap$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  persistentMap: Recoil_PersistentMap_1
});
var {
  graph: graph$1
} = Recoil_Graph;
var {
  persistentMap: persistentMap$1
} = Recoil_PersistentMap$1;
var nextTreeStateVersion = 0;
var getNextTreeStateVersion = () => nextTreeStateVersion++;
function makeEmptyTreeState() {
  const version = getNextTreeStateVersion();
  return {
    version,
    stateID: version,
    transactionMetadata: {},
    dirtyAtoms: /* @__PURE__ */ new Set(),
    atomValues: persistentMap$1(),
    nonvalidatedAtoms: persistentMap$1()
  };
}
function makeEmptyStoreState() {
  const currentTree = makeEmptyTreeState();
  return {
    currentTree,
    nextTree: null,
    previousTree: null,
    commitDepth: 0,
    knownAtoms: /* @__PURE__ */ new Set(),
    knownSelectors: /* @__PURE__ */ new Set(),
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(currentTree.version, graph$1()),
    versionsUsedByComponent: /* @__PURE__ */ new Map(),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    nodeCleanupFunctions: /* @__PURE__ */ new Map()
  };
}
var Recoil_State = {
  makeEmptyTreeState,
  makeEmptyStoreState,
  getNextTreeStateVersion
};
function unionSets(...sets) {
  const result = /* @__PURE__ */ new Set();
  for (const set of sets) {
    for (const value of set) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_unionSets = unionSets;
function someSet(set, callback, context) {
  const iterator = set.entries();
  let current = iterator.next();
  while (!current.done) {
    const entry = current.value;
    if (callback.call(context, entry[1], entry[0], set)) {
      return true;
    }
    current = iterator.next();
  }
  return false;
}
var Recoil_someSet = someSet;
var {
  cleanUpNode: cleanUpNode$1
} = Recoil_FunctionalCore;
var {
  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,
  getNode: getNode$2
} = Recoil_Node;
var {
  RetentionZone: RetentionZone$2
} = Recoil_RetentionZone;
var emptySet$1 = /* @__PURE__ */ new Set();
function releaseRetainablesNowOnCurrentTree(store, retainables) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  if (storeState.nextTree) {
    Recoil_recoverableViolation("releaseNodesNowOnCurrentTree should only be called at the end of a batch");
    return;
  }
  const nodes2 = /* @__PURE__ */ new Set();
  for (const r3 of retainables) {
    if (r3 instanceof RetentionZone$2) {
      for (const n2 of nodesRetainedByZone(storeState, r3)) {
        nodes2.add(n2);
      }
    } else {
      nodes2.add(r3);
    }
  }
  const releasableNodes = findReleasableNodes(store, nodes2);
  for (const node of releasableNodes) {
    releaseNode(store, treeState, node);
  }
}
function findReleasableNodes(store, searchFromNodes) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const graph2 = store.getGraph(treeState.version);
  const releasableNodes = /* @__PURE__ */ new Set();
  const nonReleasableNodes = /* @__PURE__ */ new Set();
  findReleasableNodesInner(searchFromNodes);
  return releasableNodes;
  function findReleasableNodesInner(searchFromNodes2) {
    const releasableNodesFoundThisIteration = /* @__PURE__ */ new Set();
    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes2, releasableNodes, nonReleasableNodes);
    for (const node of downstreams) {
      var _storeState$retention;
      if (getNode$2(node).retainedBy === "recoilRoot") {
        nonReleasableNodes.add(node);
        continue;
      }
      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {
        nonReleasableNodes.add(node);
        continue;
      }
      if (zonesThatCouldRetainNode(node).some((z4) => storeState.retention.referenceCounts.get(z4))) {
        nonReleasableNodes.add(node);
        continue;
      }
      const nodeChildren = graph2.nodeToNodeSubscriptions.get(node);
      if (nodeChildren && Recoil_someSet(nodeChildren, (child) => nonReleasableNodes.has(child))) {
        nonReleasableNodes.add(node);
        continue;
      }
      releasableNodes.add(node);
      releasableNodesFoundThisIteration.add(node);
    }
    const parents = /* @__PURE__ */ new Set();
    for (const node of releasableNodesFoundThisIteration) {
      for (const parent of (_graph$nodeDeps$get = graph2.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {
        var _graph$nodeDeps$get;
        if (!releasableNodes.has(parent)) {
          parents.add(parent);
        }
      }
    }
    if (parents.size) {
      findReleasableNodesInner(parents);
    }
  }
}
function getDownstreamNodesInTopologicalOrder(store, treeState, nodes2, doNotDescendInto1, doNotDescendInto2) {
  const graph2 = store.getGraph(treeState.version);
  const answer = [];
  const visited = /* @__PURE__ */ new Set();
  while (nodes2.size > 0) {
    visit(Recoil_nullthrows(nodes2.values().next().value));
  }
  return answer;
  function visit(node) {
    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {
      nodes2.delete(node);
      return;
    }
    if (visited.has(node)) {
      return;
    }
    const children = graph2.nodeToNodeSubscriptions.get(node);
    if (children) {
      for (const child of children) {
        visit(child);
      }
    }
    visited.add(node);
    nodes2.delete(node);
    answer.push(node);
  }
}
function releaseNode(store, treeState, node) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  cleanUpNode$1(store, node);
  const storeState = store.getState();
  storeState.knownAtoms.delete(node);
  storeState.knownSelectors.delete(node);
  storeState.nodeTransactionSubscriptions.delete(node);
  storeState.retention.referenceCounts.delete(node);
  const zones = zonesThatCouldRetainNode(node);
  for (const zone of zones) {
    var _storeState$retention2;
    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);
  }
  treeState.atomValues.delete(node);
  treeState.dirtyAtoms.delete(node);
  treeState.nonvalidatedAtoms.delete(node);
  const graph2 = storeState.graphsByVersion.get(treeState.version);
  if (graph2) {
    const deps = graph2.nodeDeps.get(node);
    if (deps !== void 0) {
      graph2.nodeDeps.delete(node);
      for (const dep of deps) {
        var _graph$nodeToNodeSubs;
        (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);
      }
    }
    graph2.nodeToNodeSubscriptions.delete(node);
  }
  deleteNodeConfigIfPossible$1(node);
}
function nodesRetainedByZone(storeState, zone) {
  var _storeState$retention3;
  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;
}
function zonesThatCouldRetainNode(node) {
  const retainedBy = getNode$2(node).retainedBy;
  if (retainedBy === void 0 || retainedBy === "components" || retainedBy === "recoilRoot") {
    return [];
  } else if (retainedBy instanceof RetentionZone$2) {
    return [retainedBy];
  } else {
    return retainedBy;
  }
}
function scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {
  const state = store.getState();
  if (state.nextTree) {
    state.retention.retainablesToCheckForRelease.add(retainable);
  } else {
    releaseRetainablesNowOnCurrentTree(store, /* @__PURE__ */ new Set([retainable]));
  }
}
function updateRetainCount(store, retainable, delta) {
  var _map$get;
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;
  if (newCount === 0) {
    updateRetainCountToZero(store, retainable);
  } else {
    map.set(retainable, newCount);
  }
}
function updateRetainCountToZero(store, retainable) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  map.delete(retainable);
  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);
}
function releaseScheduledRetainablesNow(store) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  const state = store.getState();
  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);
  state.retention.retainablesToCheckForRelease.clear();
}
function retainedByOptionWithDefault(r3) {
  return r3 === void 0 ? "recoilRoot" : r3;
}
var Recoil_Retention = {
  updateRetainCount,
  updateRetainCountToZero,
  releaseScheduledRetainablesNow,
  retainedByOptionWithDefault
};
function* concatIterables(iters) {
  for (const iter of iters) {
    for (const val of iter) {
      yield val;
    }
  }
}
var Recoil_concatIterables = concatIterables;
var isSSR = typeof window === "undefined";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var Recoil_Environment = {
  isSSR,
  isReactNative
};
var {
  isSSR: isSSR$1
} = Recoil_Environment;
var {
  batchUpdates: batchUpdates$1
} = Recoil_Batching;
var {
  initializeNodeIfNewToStore: initializeNodeIfNewToStore$1,
  peekNodeInfo: peekNodeInfo$1
} = Recoil_FunctionalCore;
var {
  graph: graph$2
} = Recoil_Graph;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$1,
  recoilValues: recoilValues$1,
  recoilValuesForKeys: recoilValuesForKeys$2
} = Recoil_Node;
var {
  AbstractRecoilValue: AbstractRecoilValue$2,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,
  setRecoilValue: setRecoilValue$1,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1
} = Recoil_RecoilValueInterface;
var {
  updateRetainCount: updateRetainCount$1
} = Recoil_Retention;
var {
  getNextTreeStateVersion: getNextTreeStateVersion$1,
  makeEmptyStoreState: makeEmptyStoreState$1
} = Recoil_State;
var retainWarning = `
Recoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:

  const release = snapshot.retain();
  try {
    await useTheSnapshotAsynchronously(snapshot);
  } finally {
    release();
  }

This is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.
`;
var Snapshot = class {
  constructor(storeState) {
    _defineProperty(this, "_store", void 0);
    _defineProperty(this, "_refCount", 0);
    _defineProperty(this, "getLoadable", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return getRecoilValueAsLoadable$1(this._store, recoilValue);
    });
    _defineProperty(this, "getPromise", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return this.getLoadable(recoilValue).toPromise();
    });
    _defineProperty(this, "getNodes_UNSTABLE", (opt) => {
      this.checkRefCount_INTERNAL();
      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {
        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {
          return [];
        }
        const state = this._store.getState().currentTree;
        return recoilValuesForKeys$2(state.dirtyAtoms);
      }
      const knownAtoms = this._store.getState().knownAtoms;
      const knownSelectors = this._store.getState().knownSelectors;
      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([this._store.getState().knownAtoms, this._store.getState().knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({
        key: key2
      }) => !knownAtoms.has(key2) && !knownSelectors.has(key2));
    });
    _defineProperty(this, "getInfo_UNSTABLE", ({
      key: key2
    }) => {
      this.checkRefCount_INTERNAL();
      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key2);
    });
    _defineProperty(this, "map", (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mapper(mutableSnapshot);
      return cloneSnapshot(mutableSnapshot.getStore_INTERNAL());
    });
    _defineProperty(this, "asyncMap", async (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      await mapper(mutableSnapshot);
      return cloneSnapshot(mutableSnapshot.getStore_INTERNAL());
    });
    this._store = {
      getState: () => storeState,
      replaceState: (replacer) => {
        storeState.currentTree = replacer(storeState.currentTree);
      },
      getGraph: (version) => {
        const graphs = storeState.graphsByVersion;
        if (graphs.has(version)) {
          return Recoil_nullthrows(graphs.get(version));
        }
        const newGraph = graph$2();
        graphs.set(version, newGraph);
        return newGraph;
      },
      subscribeToTransactions: () => ({
        release: () => {
        }
      }),
      addTransactionMetadata: () => {
        throw new Error("Cannot subscribe to Snapshots");
      }
    };
    for (const nodeKey of this._store.getState().nodeCleanupFunctions.keys()) {
      initializeNodeIfNewToStore$1(this._store, storeState.currentTree, nodeKey, "get");
      updateRetainCount$1(this._store, nodeKey, 1);
    }
    this.retain();
    this.autorelease_INTERNAL();
  }
  retain() {
    if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
      return () => void 0;
    }
    this._refCount++;
    let released = false;
    return () => {
      if (!released) {
        released = true;
        this.release_INTERNAL();
      }
    };
  }
  autorelease_INTERNAL() {
    if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
      return;
    }
    if (!isSSR$1) {
      window.setTimeout(() => this.release_INTERNAL(), 0);
    }
  }
  release_INTERNAL() {
    if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
      return;
    }
    this._refCount--;
    if (this._refCount === 0)
      ;
  }
  checkRefCount_INTERNAL() {
    if (Recoil_gkx_1("recoil_memory_managament_2020") && this._refCount <= 0) {
      if (true) {
        Recoil_recoverableViolation(retainWarning);
      }
    }
  }
  getStore_INTERNAL() {
    this.checkRefCount_INTERNAL();
    return this._store;
  }
  getID() {
    this.checkRefCount_INTERNAL();
    return this.getID_INTERNAL();
  }
  getID_INTERNAL() {
    this.checkRefCount_INTERNAL();
    return this._store.getState().currentTree.stateID;
  }
};
function cloneStoreState(store, treeState, bumpVersion = false) {
  const storeState = store.getState();
  const version = bumpVersion ? getNextTreeStateVersion$1() : treeState.version;
  return {
    currentTree: bumpVersion ? {
      version,
      stateID: version,
      transactionMetadata: {
        ...treeState.transactionMetadata
      },
      dirtyAtoms: new Set(treeState.dirtyAtoms),
      atomValues: treeState.atomValues.clone(),
      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()
    } : treeState,
    commitDepth: 0,
    nextTree: null,
    previousTree: null,
    knownAtoms: new Set(storeState.knownAtoms),
    knownSelectors: new Set(storeState.knownSelectors),
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(version, store.getGraph(treeState.version)),
    versionsUsedByComponent: /* @__PURE__ */ new Map(),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    nodeCleanupFunctions: /* @__PURE__ */ new Map()
  };
}
function freshSnapshot(initializeState) {
  const snapshot = new Snapshot(makeEmptyStoreState$1());
  return initializeState != null ? snapshot.map(initializeState) : snapshot;
}
function cloneSnapshot(store, version = "current") {
  const storeState = store.getState();
  const treeState = version === "current" ? storeState.currentTree : Recoil_nullthrows(storeState.previousTree);
  return new Snapshot(cloneStoreState(store, treeState));
}
var MutableSnapshot = class extends Snapshot {
  constructor(snapshot, batch) {
    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true));
    _defineProperty(this, "_batch", void 0);
    _defineProperty(this, "set", (recoilState, newValueOrUpdater) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);
      });
    });
    _defineProperty(this, "reset", (recoilState) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);
      });
    });
    _defineProperty(this, "setUnvalidatedAtomValues_DEPRECATED", (values) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      batchUpdates$1(() => {
        for (const [k4, v3] of values.entries()) {
          updateRetainCount$1(store, k4, 1);
          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k4), v3);
        }
      });
    });
    this._batch = batch;
  }
};
var Recoil_Snapshot = {
  Snapshot,
  MutableSnapshot,
  freshSnapshot,
  cloneSnapshot
};
var Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;
var Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;
var Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;
var Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;
var Recoil_Snapshot$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Snapshot: Recoil_Snapshot_1,
  MutableSnapshot: Recoil_Snapshot_2,
  freshSnapshot: Recoil_Snapshot_3,
  cloneSnapshot: Recoil_Snapshot_4
});
var {
  getNextTreeStateVersion: getNextTreeStateVersion$2,
  makeEmptyStoreState: makeEmptyStoreState$2
} = Recoil_State;
var {
  cleanUpNode: cleanUpNode$2,
  getDownstreamNodes: getDownstreamNodes$2,
  setNodeValue: setNodeValue$2,
  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1
} = Recoil_FunctionalCore;
var {
  graph: graph$3
} = Recoil_Graph;
var {
  cloneGraph: cloneGraph$1
} = Recoil_Graph;
var {
  applyAtomValueWrites: applyAtomValueWrites$1
} = Recoil_RecoilValueInterface;
var {
  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1
} = Recoil_Retention;
var {
  freshSnapshot: freshSnapshot$1
} = Recoil_Snapshot$1;
var {
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState
} = bn;
function notInAContext() {
  throw new Error("This component must be used inside a <RecoilRoot> component.");
}
var defaultStore = Object.freeze({
  getState: notInAContext,
  replaceState: notInAContext,
  getGraph: notInAContext,
  subscribeToTransactions: notInAContext,
  addTransactionMetadata: notInAContext
});
var stateReplacerIsBeingExecuted = false;
function startNextTreeIfNeeded(store) {
  if (stateReplacerIsBeingExecuted) {
    throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");
  }
  const storeState = store.getState();
  if (storeState.nextTree === null) {
    if (Recoil_gkx_1("recoil_memory_managament_2020") && Recoil_gkx_1("recoil_release_on_cascading_update_killswitch_2021")) {
      if (storeState.commitDepth > 0) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
    const version = storeState.currentTree.version;
    const nextVersion = getNextTreeStateVersion$2();
    storeState.nextTree = {
      ...storeState.currentTree,
      version: nextVersion,
      stateID: nextVersion,
      dirtyAtoms: /* @__PURE__ */ new Set(),
      transactionMetadata: {}
    };
    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));
  }
}
var AppContext = bn.createContext({
  current: defaultStore
});
var useStoreRef = () => useContext(AppContext);
var MutableSourceContext = bn.createContext(null);
function useRecoilMutableSource() {
  const mutableSource = useContext(MutableSourceContext);
  if (mutableSource == null) {
    Recoil_expectationViolation("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks.");
  }
  return mutableSource;
}
function notifyComponents(store, storeState, treeState) {
  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);
  for (const key2 of dependentNodes) {
    const comps = storeState.nodeToComponentSubscriptions.get(key2);
    if (comps) {
      for (const [_subID, [_debugName, callback]] of comps) {
        callback(treeState);
      }
    }
  }
}
function sendEndOfBatchNotifications(store) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const dirtyAtoms = treeState.dirtyAtoms;
  if (dirtyAtoms.size) {
    for (const [key2, subscriptions] of storeState.nodeTransactionSubscriptions) {
      if (dirtyAtoms.has(key2)) {
        for (const [_3, subscription] of subscriptions) {
          subscription(store);
        }
      }
    }
    for (const [_3, subscription] of storeState.transactionSubscriptions) {
      subscription(store);
    }
    if (!Recoil_gkx_1("recoil_early_rendering_2021") || storeState.suspendedComponentResolvers.size) {
      notifyComponents(store, storeState, treeState);
      storeState.suspendedComponentResolvers.forEach((cb) => cb());
      storeState.suspendedComponentResolvers.clear();
    }
  }
  storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb) => cb(treeState));
  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);
}
function endBatch(storeRef) {
  const storeState = storeRef.current.getState();
  storeState.commitDepth++;
  try {
    const {
      nextTree
    } = storeState;
    if (nextTree === null) {
      return;
    }
    storeState.previousTree = storeState.currentTree;
    storeState.currentTree = nextTree;
    storeState.nextTree = null;
    sendEndOfBatchNotifications(storeRef.current);
    if (storeState.previousTree != null) {
      storeState.graphsByVersion.delete(storeState.previousTree.version);
    } else {
      Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected", "recoil");
    }
    storeState.previousTree = null;
    if (Recoil_gkx_1("recoil_memory_managament_2020")) {
      releaseScheduledRetainablesNow$1(storeRef.current);
    }
  } finally {
    storeState.commitDepth--;
  }
}
function Batcher({
  setNotifyBatcherOfChange
}) {
  const storeRef = useStoreRef();
  const [_3, setState] = useState([]);
  setNotifyBatcherOfChange(() => setState({}));
  useEffect(() => {
    Recoil_Queue.enqueueExecution("Batcher", () => {
      endBatch(storeRef);
    });
  });
  useEffect(() => {
    return () => {
      setNotifyBatcherOfChange(() => {
      });
    };
  }, [setNotifyBatcherOfChange]);
  return null;
}
if (true) {
  if (typeof window !== "undefined" && !window.$recoilDebugStates) {
    window.$recoilDebugStates = [];
  }
}
function initialStoreState_DEPRECATED(store, initializeState) {
  const initial = makeEmptyStoreState$2();
  initializeState({
    set: (atom2, value) => {
      const state = initial.currentTree;
      const writes = setNodeValue$2(store, state, atom2.key, value);
      const writtenNodes = new Set(writes.keys());
      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();
      for (const n2 of writtenNodes) {
        nonvalidatedAtoms.delete(n2);
      }
      initial.currentTree = {
        ...state,
        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),
        atomValues: applyAtomValueWrites$1(state.atomValues, writes),
        nonvalidatedAtoms
      };
    },
    setUnvalidatedAtomValues: (atomValues) => {
      atomValues.forEach((v3, k4) => {
        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k4, v3);
      });
    }
  });
  return initial;
}
function initialStoreState(initializeState) {
  const snapshot = freshSnapshot$1().map(initializeState);
  return snapshot.getStore_INTERNAL().getState();
}
var nextID = 0;
function RecoilRoot_INTERNAL({
  initializeState_DEPRECATED,
  initializeState,
  store_INTERNAL: storeProp,
  children
}) {
  var _createMutableSource;
  let storeState;
  const getGraph = (version) => {
    const graphs = storeState.current.graphsByVersion;
    if (graphs.has(version)) {
      return Recoil_nullthrows(graphs.get(version));
    }
    const newGraph = graph$3();
    graphs.set(version, newGraph);
    return newGraph;
  };
  const subscribeToTransactions = (callback, key2) => {
    if (key2 == null) {
      const {
        transactionSubscriptions
      } = storeRef.current.getState();
      const id = nextID++;
      transactionSubscriptions.set(id, callback);
      return {
        release: () => {
          transactionSubscriptions.delete(id);
        }
      };
    } else {
      const {
        nodeTransactionSubscriptions
      } = storeRef.current.getState();
      if (!nodeTransactionSubscriptions.has(key2)) {
        nodeTransactionSubscriptions.set(key2, /* @__PURE__ */ new Map());
      }
      const id = nextID++;
      Recoil_nullthrows(nodeTransactionSubscriptions.get(key2)).set(id, callback);
      return {
        release: () => {
          const subs = nodeTransactionSubscriptions.get(key2);
          if (subs) {
            subs.delete(id);
            if (subs.size === 0) {
              nodeTransactionSubscriptions.delete(key2);
            }
          }
        }
      };
    }
  };
  const addTransactionMetadata = (metadata) => {
    startNextTreeIfNeeded(storeRef.current);
    for (const k4 of Object.keys(metadata)) {
      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k4] = metadata[k4];
    }
  };
  const replaceState = (replacer) => {
    const storeState2 = storeRef.current.getState();
    startNextTreeIfNeeded(storeRef.current);
    const nextTree = Recoil_nullthrows(storeState2.nextTree);
    let replaced;
    try {
      stateReplacerIsBeingExecuted = true;
      replaced = replacer(nextTree);
    } finally {
      stateReplacerIsBeingExecuted = false;
    }
    if (replaced === nextTree) {
      return;
    }
    if (true) {
      if (typeof window !== "undefined") {
        window.$recoilDebugStates.push(replaced);
      }
    }
    storeState2.nextTree = replaced;
    if (Recoil_gkx_1("recoil_early_rendering_2021")) {
      notifyComponents(store, storeState2, replaced);
    }
    Recoil_nullthrows(notifyBatcherOfChange.current)();
  };
  const notifyBatcherOfChange = useRef(null);
  const setNotifyBatcherOfChange = useCallback((x4) => {
    notifyBatcherOfChange.current = x4;
  }, [notifyBatcherOfChange]);
  const createMutableSource = (_createMutableSource = bn.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : bn.unstable_createMutableSource;
  const store = storeProp !== null && storeProp !== void 0 ? storeProp : {
    getState: () => storeState.current,
    replaceState,
    getGraph,
    subscribeToTransactions,
    addTransactionMetadata
  };
  const storeRef = useRef(store);
  storeState = useRef(initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(store, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());
  const mutableSource = useMemo(() => createMutableSource ? createMutableSource(storeState, () => storeState.current.currentTree.version) : null, [createMutableSource, storeState]);
  useEffect(() => () => {
    for (const atomKey of storeRef.current.getState().knownAtoms) {
      cleanUpNode$2(storeRef.current, atomKey);
    }
  }, []);
  return /* @__PURE__ */ bn.createElement(AppContext.Provider, {
    value: storeRef
  }, /* @__PURE__ */ bn.createElement(MutableSourceContext.Provider, {
    value: mutableSource
  }, /* @__PURE__ */ bn.createElement(Batcher, {
    setNotifyBatcherOfChange
  }), children));
}
function RecoilRoot(props) {
  const {
    override,
    ...propsExceptOverride
  } = props;
  const ancestorStoreRef = useStoreRef();
  if (override === false && ancestorStoreRef.current !== defaultStore) {
    return props.children;
  }
  return /* @__PURE__ */ bn.createElement(RecoilRoot_INTERNAL, propsExceptOverride);
}
var Recoil_RecoilRoot_react = {
  useStoreRef,
  useRecoilMutableSource,
  RecoilRoot,
  notifyComponents_FOR_TESTING: notifyComponents,
  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications
};
var {
  loadableWithValue: loadableWithValue$1
} = Recoil_Loadable;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$2,
  getNode: getNode$3
} = Recoil_Node;
var {
  copyTreeState: copyTreeState$1,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,
  invalidateDownstreams: invalidateDownstreams$1,
  writeLoadableToTreeState: writeLoadableToTreeState$1
} = Recoil_RecoilValueInterface;
function isAtom(recoilValue) {
  return getNode$3(recoilValue.key).nodeType === "atom";
}
var TransactionInterfaceImpl = class {
  constructor(store, treeState) {
    _defineProperty(this, "_store", void 0);
    _defineProperty(this, "_treeState", void 0);
    _defineProperty(this, "_changes", void 0);
    _defineProperty(this, "get", (recoilValue) => {
      if (this._changes.has(recoilValue.key)) {
        return this._changes.get(recoilValue.key);
      }
      if (!isAtom(recoilValue)) {
        throw new Error("Reading selectors within atomicUpdate is not supported");
      }
      const loadable = getRecoilValueAsLoadable$2(this._store, recoilValue, this._treeState);
      if (loadable.state === "hasValue") {
        return loadable.contents;
      } else if (loadable.state === "hasError") {
        throw loadable.contents;
      } else {
        throw new Error(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);
      }
    });
    _defineProperty(this, "set", (recoilState, valueOrUpdater) => {
      if (!isAtom(recoilState)) {
        throw new Error("Setting selectors within atomicUpdate is not supported");
      }
      if (typeof valueOrUpdater === "function") {
        const current = this.get(recoilState);
        this._changes.set(recoilState.key, valueOrUpdater(current));
      } else {
        this._changes.set(recoilState.key, valueOrUpdater);
      }
    });
    _defineProperty(this, "reset", (recoilState) => {
      this.set(recoilState, DEFAULT_VALUE$2);
    });
    this._store = store;
    this._treeState = treeState;
    this._changes = /* @__PURE__ */ new Map();
  }
  newTreeState_INTERNAL() {
    if (this._changes.size === 0) {
      return this._treeState;
    }
    const newState = copyTreeState$1(this._treeState);
    for (const [k4, v3] of this._changes) {
      writeLoadableToTreeState$1(newState, k4, loadableWithValue$1(v3));
    }
    invalidateDownstreams$1(this._store, newState);
    return newState;
  }
};
function atomicUpdater(store) {
  return (fn3) => {
    store.replaceState((treeState) => {
      const changeset = new TransactionInterfaceImpl(store, treeState);
      fn3(changeset);
      return changeset.newTreeState_INTERNAL();
    });
  };
}
var Recoil_AtomicUpdates = {
  atomicUpdater
};
var Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;
var Recoil_AtomicUpdates$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  atomicUpdater: Recoil_AtomicUpdates_1
});
function filterMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  for (const [key2, value] of map) {
    if (callback(value, key2)) {
      result.set(key2, value);
    }
  }
  return result;
}
var Recoil_filterMap = filterMap;
function filterSet(set, callback) {
  const result = /* @__PURE__ */ new Set();
  for (const value of set) {
    if (callback(value)) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_filterSet = filterSet;
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
var invariant_1 = invariant;
var Recoil_invariant = invariant_1;
function mergeMaps(...maps) {
  const result = /* @__PURE__ */ new Map();
  for (let i3 = 0; i3 < maps.length; i3++) {
    const iterator = maps[i3].keys();
    let nextKey;
    while (!(nextKey = iterator.next()).done) {
      result.set(nextKey.value, maps[i3].get(nextKey.value));
    }
  }
  return result;
}
var Recoil_mergeMaps = mergeMaps;
function shallowArrayEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (a3.length !== b3.length) {
    return false;
  }
  for (let i3 = 0, l3 = a3.length; i3 < l3; i3++) {
    if (a3[i3] !== b3[i3]) {
      return false;
    }
  }
  return true;
}
var Recoil_shallowArrayEqual = shallowArrayEqual;
var UNKNOWN_FUNCTION = "<unknown>";
function stackTraceParser(stackString) {
  const lines = stackString.split("\n");
  return lines.reduce((stack, line) => {
    const parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
    if (parseResult) {
      stack.push(parseResult);
    }
    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
function parseChrome(line) {
  const parts = chromeRe.exec(line);
  if (!parts) {
    return null;
  }
  const isNative = parts[2] && parts[2].indexOf("native") === 0;
  const isEval = parts[2] && parts[2].indexOf("eval") === 0;
  const submatch = chromeEvalRe.exec(parts[2]);
  if (isEval && submatch != null) {
    parts[2] = submatch[1];
    parts[3] = submatch[2];
    parts[4] = submatch[3];
  }
  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}
var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinjs(line) {
  const parts = winjsRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGecko(line) {
  const parts = geckoRe.exec(line);
  if (!parts) {
    return null;
  }
  const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
  const submatch = geckoEvalRe.exec(parts[3]);
  if (isEval && submatch != null) {
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(",") : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}
var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
function parseJSC(line) {
  const parts = javaScriptCoreRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}
var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseNode(line) {
  const parts = nodeRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
var Recoil_stackTraceParser = stackTraceParser;
var {
  useRef: useRef$1
} = bn;
function useComponentName() {
  const nameRef = useRef$1();
  if (true) {
    if (Recoil_gkx_1("recoil_infer_component_names")) {
      var _nameRef$current;
      if (nameRef.current === void 0) {
        const frames = Recoil_stackTraceParser(new Error().stack);
        for (const {
          methodName
        } of frames) {
          if (!methodName.match(/\buse[^\b]+$/)) {
            return nameRef.current = methodName;
          }
        }
        nameRef.current = null;
      }
      return (_nameRef$current = nameRef.current) !== null && _nameRef$current !== void 0 ? _nameRef$current : "<unable to determine component name>";
    }
  }
  return "<component name not available>";
}
var Recoil_useComponentName = useComponentName;
var {
  atomicUpdater: atomicUpdater$1
} = Recoil_AtomicUpdates$1;
var {
  batchUpdates: batchUpdates$2
} = Recoil_Batching;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$3,
  getNode: getNode$4,
  nodes: nodes$1
} = Recoil_Node;
var {
  useRecoilMutableSource: useRecoilMutableSource$1,
  useStoreRef: useStoreRef$1
} = Recoil_RecoilRoot_react;
var {
  isRecoilValue: isRecoilValue$2
} = Recoil_RecoilValue$1;
var {
  AbstractRecoilValue: AbstractRecoilValue$3,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,
  setRecoilValue: setRecoilValue$2,
  setRecoilValueLoadable: setRecoilValueLoadable$1,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,
  subscribeToRecoilValue: subscribeToRecoilValue$1
} = Recoil_RecoilValueInterface;
var {
  updateRetainCount: updateRetainCount$2
} = Recoil_Retention;
var {
  RetentionZone: RetentionZone$3
} = Recoil_RetentionZone;
var {
  Snapshot: Snapshot$1,
  cloneSnapshot: cloneSnapshot$1
} = Recoil_Snapshot$1;
var {
  setByAddingToSet: setByAddingToSet$2
} = Recoil_CopyOnWrite;
var {
  isSSR: isSSR$2
} = Recoil_Environment;
var {
  mutableSourceExists: mutableSourceExists$2,
  useMutableSource: useMutableSource$1
} = Recoil_mutableSource;
var {
  useCallback: useCallback$1,
  useEffect: useEffect$1,
  useMemo: useMemo$1,
  useRef: useRef$2,
  useState: useState$1
} = bn;
var SUSPENSE_TIMEOUT_MS = 12e4;
function handleLoadable(loadable, recoilValue, storeRef) {
  if (loadable.state === "hasValue") {
    return loadable.contents;
  } else if (loadable.state === "loading") {
    const promise = new Promise((resolve) => {
      storeRef.current.getState().suspendedComponentResolvers.add(resolve);
    });
    throw promise;
  } else if (loadable.state === "hasError") {
    throw loadable.contents;
  } else {
    const err = new Error(`Invalid value of loadable atom "${recoilValue.key}"`);
    throw err;
  }
}
function validateRecoilValue(recoilValue, hookName) {
  if (!isRecoilValue$2(recoilValue)) {
    throw new Error(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);
  }
}
function useRecoilInterface_DEPRECATED() {
  const storeRef = useStoreRef$1();
  const [_3, forceUpdate] = useState$1([]);
  const recoilValuesUsed = useRef$2(/* @__PURE__ */ new Set());
  recoilValuesUsed.current = /* @__PURE__ */ new Set();
  const previousSubscriptions = useRef$2(/* @__PURE__ */ new Set());
  const subscriptions = useRef$2(/* @__PURE__ */ new Map());
  const unsubscribeFrom = useCallback$1((key2) => {
    const sub = subscriptions.current.get(key2);
    if (sub) {
      sub.release();
      subscriptions.current.delete(key2);
    }
  }, [subscriptions]);
  const componentName = Recoil_useComponentName();
  useEffect$1(() => {
    const store = storeRef.current;
    function updateState(_state, key2) {
      if (!subscriptions.current.has(key2)) {
        return;
      }
      forceUpdate([]);
    }
    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach((key2) => {
      if (subscriptions.current.has(key2)) {
        Recoil_expectationViolation(`Double subscription to RecoilValue "${key2}"`);
        return;
      }
      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key2), (state2) => {
        updateState(state2, key2);
      }, componentName);
      subscriptions.current.set(key2, sub);
      const state = store.getState();
      if (state.nextTree) {
        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
          updateState(store.getState(), key2);
        });
      } else {
        updateState(store.getState(), key2);
      }
    });
    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach((key2) => {
      unsubscribeFrom(key2);
    });
    previousSubscriptions.current = recoilValuesUsed.current;
  });
  useEffect$1(() => {
    const subs = subscriptions.current;
    return () => subs.forEach((_4, key2) => unsubscribeFrom(key2));
  }, [unsubscribeFrom]);
  return useMemo$1(() => {
    function useSetRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useSetRecoilState");
      }
      return (newValueOrUpdater) => {
        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
      };
    }
    function useResetRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useResetRecoilState");
      }
      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$3);
    }
    function useRecoilValueLoadable2(recoilValue) {
      var _storeState$nextTree;
      if (true) {
        validateRecoilValue(recoilValue, "useRecoilValueLoadable");
      }
      if (!recoilValuesUsed.current.has(recoilValue.key)) {
        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);
      }
      const storeState = storeRef.current.getState();
      return getRecoilValueAsLoadable$3(storeRef.current, recoilValue, Recoil_gkx_1("recoil_early_rendering_2021") ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);
    }
    function useRecoilValue2(recoilValue) {
      if (true) {
        validateRecoilValue(recoilValue, "useRecoilValue");
      }
      const loadable = useRecoilValueLoadable2(recoilValue);
      return handleLoadable(loadable, recoilValue, storeRef);
    }
    function useRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useRecoilState");
      }
      return [useRecoilValue2(recoilState), useSetRecoilState2(recoilState)];
    }
    function useRecoilStateLoadable2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useRecoilStateLoadable");
      }
      return [useRecoilValueLoadable2(recoilState), useSetRecoilState2(recoilState)];
    }
    return {
      getRecoilValue: useRecoilValue2,
      getRecoilValueLoadable: useRecoilValueLoadable2,
      getRecoilState: useRecoilState2,
      getRecoilStateLoadable: useRecoilStateLoadable2,
      getSetRecoilState: useSetRecoilState2,
      getResetRecoilState: useResetRecoilState2
    };
  }, [recoilValuesUsed, storeRef]);
}
var recoilComponentGetRecoilValueCount_FOR_TESTING = {
  current: 0
};
function useRecoilValueLoadable_MUTABLESOURCE(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValueLoadable");
  }
  const storeRef = useStoreRef$1();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree2;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = Recoil_gkx_1("recoil_early_rendering_2021") ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$3(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getLoadableWithTesting = useCallback$1(() => {
    if (true) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    return getLoadable();
  }, [getLoadable]);
  const componentName = Recoil_useComponentName();
  const subscribe = useCallback$1((_storeState, callback) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {
      if (!Recoil_gkx_1("recoil_suppress_rerender_in_callback")) {
        return callback();
      }
      const newLoadable = getLoadable();
      if (!prevLoadableRef.current.is(newLoadable)) {
        callback();
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName, getLoadable]);
  const source = useRecoilMutableSource$1();
  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);
  const prevLoadableRef = useRef$2(loadable);
  useEffect$1(() => {
    prevLoadableRef.current = loadable;
  });
  return loadable;
}
function useRecoilValueLoadable_LEGACY(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValueLoadable");
  }
  const storeRef = useStoreRef$1();
  const [_3, forceUpdate] = useState$1([]);
  const componentName = Recoil_useComponentName();
  useEffect$1(() => {
    const store = storeRef.current;
    const storeState = store.getState();
    const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state) => {
      var _prevLoadableRef$curr;
      if (!Recoil_gkx_1("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getRecoilValueAsLoadable$3(store, recoilValue, store.getState().currentTree);
      if (!((_prevLoadableRef$curr = prevLoadableRef.current) === null || _prevLoadableRef$curr === void 0 ? void 0 : _prevLoadableRef$curr.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    if (storeState.nextTree) {
      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
        prevLoadableRef.current = null;
        forceUpdate([]);
      });
    } else {
      var _prevLoadableRef$curr2;
      if (!Recoil_gkx_1("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getRecoilValueAsLoadable$3(store, recoilValue, store.getState().currentTree);
      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) === null || _prevLoadableRef$curr2 === void 0 ? void 0 : _prevLoadableRef$curr2.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }
    return subscription.release;
  }, [componentName, recoilValue, storeRef]);
  const loadable = getRecoilValueAsLoadable$3(storeRef.current, recoilValue);
  const prevLoadableRef = useRef$2(loadable);
  useEffect$1(() => {
    prevLoadableRef.current = loadable;
  });
  return loadable;
}
function useRecoilValueLoadable(recoilValue) {
  if (Recoil_gkx_1("recoil_memory_managament_2020")) {
    useRetain(recoilValue);
  }
  if (mutableSourceExists$2()) {
    return useRecoilValueLoadable_MUTABLESOURCE(recoilValue);
  } else {
    return useRecoilValueLoadable_LEGACY(recoilValue);
  }
}
function useRecoilValue(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValue");
  }
  const storeRef = useStoreRef$1();
  const loadable = useRecoilValueLoadable(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
function useSetRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useSetRecoilState");
  }
  const storeRef = useStoreRef$1();
  return useCallback$1((newValueOrUpdater) => {
    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
  }, [storeRef, recoilState]);
}
function useResetRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useResetRecoilState");
  }
  const storeRef = useStoreRef$1();
  return useCallback$1(() => {
    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$3);
  }, [storeRef, recoilState]);
}
function useRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useRecoilState");
  }
  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
}
function useRecoilStateLoadable(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useRecoilStateLoadable");
  }
  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];
}
function useTransactionSubscription(callback) {
  const storeRef = useStoreRef$1();
  useEffect$1(() => {
    const sub = storeRef.current.subscribeToTransactions(callback);
    return sub.release;
  }, [callback, storeRef]);
}
function externallyVisibleAtomValuesInState(state) {
  const atomValues = state.atomValues.toMap();
  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v3, k4) => {
    const node = getNode$4(k4);
    const persistence = node.persistence_UNSTABLE;
    return persistence != null && persistence.type !== "none" && v3.state === "hasValue";
  }), (v3) => v3.contents);
  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);
}
function useTransactionObservation_DEPRECATED(callback) {
  useTransactionSubscription(useCallback$1((store) => {
    let previousTree = store.getState().previousTree;
    const currentTree = store.getState().currentTree;
    if (!previousTree) {
      Recoil_recoverableViolation("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil");
      previousTree = store.getState().currentTree;
    }
    const atomValues = externallyVisibleAtomValuesInState(currentTree);
    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);
    const atomInfo = Recoil_mapMap(nodes$1, (node) => {
      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;
      return {
        persistence_UNSTABLE: {
          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : "none",
          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false
        }
      };
    });
    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, (k4) => atomValues.has(k4) || previousAtomValues.has(k4));
    callback({
      atomValues,
      previousAtomValues,
      atomInfo,
      modifiedAtoms,
      transactionMetadata: {
        ...currentTree.transactionMetadata
      }
    });
  }, [callback]));
}
function useRecoilTransactionObserver(callback) {
  useTransactionSubscription(useCallback$1((store) => {
    const snapshot = cloneSnapshot$1(store, "current");
    const previousSnapshot = cloneSnapshot$1(store, "previous");
    callback({
      snapshot,
      previousSnapshot
    });
  }, [callback]));
}
function usePrevious(value) {
  const ref = useRef$2();
  useEffect$1(() => {
    ref.current = value;
  });
  return ref.current;
}
function useRecoilSnapshot() {
  const storeRef = useStoreRef$1();
  const [snapshot, setSnapshot] = useState$1(() => cloneSnapshot$1(storeRef.current));
  const previousSnapshot = usePrevious(snapshot);
  const timeoutID = useRef$2();
  useEffect$1(() => {
    if (timeoutID.current && !isSSR$2) {
      window.clearTimeout(timeoutID.current);
    }
    return snapshot.retain();
  }, [snapshot]);
  useTransactionSubscription(useCallback$1((store) => setSnapshot(cloneSnapshot$1(store)), []));
  if (previousSnapshot !== snapshot && !isSSR$2) {
    if (timeoutID.current) {
      previousSnapshot === null || previousSnapshot === void 0 ? void 0 : previousSnapshot.release_INTERNAL();
      window.clearTimeout(timeoutID.current);
    }
    snapshot.retain();
    timeoutID.current = window.setTimeout(() => {
      snapshot.release_INTERNAL();
      timeoutID.current = null;
    }, SUSPENSE_TIMEOUT_MS);
  }
  return snapshot;
}
function useGotoRecoilSnapshot() {
  const storeRef = useStoreRef$1();
  return useCallback$1((snapshot) => {
    var _storeState$nextTree3;
    const storeState = storeRef.current.getState();
    const prev = (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree;
    const next = snapshot.getStore_INTERNAL().getState().currentTree;
    batchUpdates$2(() => {
      const keysToUpdate = /* @__PURE__ */ new Set();
      for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {
        for (const key2 of keys) {
          var _prev$atomValues$get, _next$atomValues$get;
          if (((_prev$atomValues$get = prev.atomValues.get(key2)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key2)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key2).shouldRestoreFromSnapshots) {
            keysToUpdate.add(key2);
          }
        }
      }
      keysToUpdate.forEach((key2) => {
        setRecoilValueLoadable$1(storeRef.current, new AbstractRecoilValue$3(key2), next.atomValues.has(key2) ? Recoil_nullthrows(next.atomValues.get(key2)) : DEFAULT_VALUE$3);
      });
      storeRef.current.replaceState((state) => {
        return {
          ...state,
          stateID: snapshot.getID_INTERNAL()
        };
      });
    });
  }, [storeRef]);
}
function useSetUnvalidatedAtomValues() {
  const storeRef = useStoreRef$1();
  return (values, transactionMetadata = {}) => {
    batchUpdates$2(() => {
      storeRef.current.addTransactionMetadata(transactionMetadata);
      values.forEach((value, key2) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key2), value));
    });
  };
}
var Sentinel = class {
};
var SENTINEL = new Sentinel();
function useRecoilCallback(fn3, deps) {
  const storeRef = useStoreRef$1();
  const gotoSnapshot = useGotoRecoilSnapshot();
  return useCallback$1((...args) => {
    function set(recoilState, newValueOrUpdater) {
      setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
    }
    function reset(recoilState) {
      setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$3);
    }
    const snapshot = cloneSnapshot$1(storeRef.current);
    const atomicUpdate = atomicUpdater$1(storeRef.current);
    let ret = SENTINEL;
    batchUpdates$2(() => {
      const errMsg = "useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";
      if (typeof fn3 !== "function") {
        throw new Error(errMsg);
      }
      const cb = fn3({
        set,
        reset,
        snapshot,
        gotoSnapshot,
        transact_UNSTABLE: atomicUpdate
      });
      if (typeof cb !== "function") {
        throw new Error(errMsg);
      }
      ret = cb(...args);
    });
    !!(ret instanceof Sentinel) ? true ? Recoil_invariant(false, "batchUpdates should return immediately") : Recoil_invariant(false) : void 0;
    return ret;
  }, deps != null ? [...deps, storeRef] : void 0);
}
function useRetain(toRetain) {
  if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
    return;
  }
  return useRetain_ACTUAL(toRetain);
}
function useRetain_ACTUAL(toRetain) {
  const array = Array.isArray(toRetain) ? toRetain : [toRetain];
  const retainables = array.map((a3) => a3 instanceof RetentionZone$3 ? a3 : a3.key);
  const storeRef = useStoreRef$1();
  useEffect$1(() => {
    if (!Recoil_gkx_1("recoil_memory_managament_2020")) {
      return;
    }
    const store = storeRef.current;
    if (timeoutID.current && !isSSR$2) {
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
    } else {
      for (const r3 of retainables) {
        updateRetainCount$2(store, r3, 1);
      }
    }
    return () => {
      for (const r3 of retainables) {
        updateRetainCount$2(store, r3, -1);
      }
    };
  }, [storeRef, ...retainables]);
  const timeoutID = useRef$2();
  const previousRetainables = usePrevious(retainables);
  if (!isSSR$2 && (previousRetainables === void 0 || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {
    const store = storeRef.current;
    for (const r3 of retainables) {
      updateRetainCount$2(store, r3, 1);
    }
    if (previousRetainables) {
      for (const r3 of previousRetainables) {
        updateRetainCount$2(store, r3, -1);
      }
    }
    if (timeoutID.current) {
      window.clearTimeout(timeoutID.current);
    }
    timeoutID.current = window.setTimeout(() => {
      timeoutID.current = null;
      for (const r3 of retainables) {
        updateRetainCount$2(store, r3, -1);
      }
    }, SUSPENSE_TIMEOUT_MS);
  }
}
function useRecoilTransaction(fn3, deps) {
  const storeRef = useStoreRef$1();
  return useMemo$1(() => (...args) => {
    const atomicUpdate = atomicUpdater$1(storeRef.current);
    atomicUpdate((transactionInterface) => {
      fn3(transactionInterface)(...args);
    });
  }, deps != null ? [...deps, storeRef] : void 0);
}
var Recoil_Hooks = {
  recoilComponentGetRecoilValueCount_FOR_TESTING,
  useGotoRecoilSnapshot,
  useRecoilCallback,
  useRecoilInterface: useRecoilInterface_DEPRECATED,
  useRecoilSnapshot,
  useRecoilState,
  useRecoilStateLoadable,
  useRecoilTransaction,
  useRecoilTransactionObserver,
  useRecoilValue,
  useRecoilValueLoadable,
  useRetain,
  useResetRecoilState,
  useSetRecoilState,
  useSetUnvalidatedAtomValues,
  useTransactionObservation_DEPRECATED,
  useTransactionSubscription_DEPRECATED: useTransactionSubscription
};
var {
  peekNodeInfo: peekNodeInfo$2
} = Recoil_FunctionalCore;
var {
  useStoreRef: useStoreRef$2
} = Recoil_RecoilRoot_react;
function useGetRecoilValueInfo() {
  const storeRef = useStoreRef$2();
  return ({
    key: key2
  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key2);
}
var Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;
var {
  RecoilRoot: RecoilRoot$1,
  useStoreRef: useStoreRef$3
} = Recoil_RecoilRoot_react;
var {
  useMemo: useMemo$2
} = bn;
function useRecoilBridgeAcrossReactRoots() {
  const store = useStoreRef$3().current;
  return useMemo$2(() => {
    function RecoilBridge({
      children
    }) {
      return /* @__PURE__ */ bn.createElement(RecoilRoot$1, {
        store_INTERNAL: store
      }, children);
    }
    return RecoilBridge;
  }, [store]);
}
var Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;
function isNode(object) {
  var _ownerDocument, _doc$defaultView;
  if (typeof window === "undefined") {
    return false;
  }
  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;
  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;
  return !!(object != null && (typeof defaultView.Node === "function" ? object instanceof defaultView.Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
}
var Recoil_isNode = isNode;
var {
  isReactNative: isReactNative$1,
  isSSR: isSSR$3
} = Recoil_Environment;
function shouldNotBeFrozen(value) {
  if (value === null || typeof value !== "object") {
    return true;
  }
  switch (typeof value.$$typeof) {
    case "symbol":
      return true;
    case "number":
      return true;
  }
  if (value["@@__IMMUTABLE_ITERABLE__@@"] != null || value["@@__IMMUTABLE_KEYED__@@"] != null || value["@@__IMMUTABLE_INDEXED__@@"] != null || value["@@__IMMUTABLE_ORDERED__@@"] != null || value["@@__IMMUTABLE_RECORD__@@"] != null) {
    return true;
  }
  if (Recoil_isNode(value)) {
    return true;
  }
  if (Recoil_isPromise(value)) {
    return true;
  }
  if (value instanceof Error) {
    return true;
  }
  if (ArrayBuffer.isView(value)) {
    return true;
  }
  if (!isSSR$3 && !isReactNative$1 && (value === window || value instanceof Window)) {
    return true;
  }
  return false;
}
function deepFreezeValue(value) {
  if (typeof value !== "object" || shouldNotBeFrozen(value)) {
    return;
  }
  Object.freeze(value);
  for (const key2 in value) {
    if (Object.prototype.hasOwnProperty.call(value, key2)) {
      const prop = value[key2];
      if (typeof prop === "object" && prop != null && !Object.isFrozen(prop)) {
        deepFreezeValue(prop);
      }
    }
  }
  Object.seal(value);
}
var Recoil_deepFreezeValue = deepFreezeValue;
var TIME_WARNING_THRESHOLD_MS = 15;
function stringify(x4, opt, key2) {
  if (typeof x4 === "string" && !x4.includes('"') && !x4.includes("\\")) {
    return `"${x4}"`;
  }
  switch (typeof x4) {
    case "undefined":
      return "";
    case "boolean":
      return x4 ? "true" : "false";
    case "number":
    case "symbol":
      return String(x4);
    case "string":
      return JSON.stringify(x4);
    case "function":
      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {
        throw new Error("Attempt to serialize function in a Recoil cache key");
      }
      return `__FUNCTION(${x4.name})__`;
  }
  if (x4 === null) {
    return "null";
  }
  if (typeof x4 !== "object") {
    var _JSON$stringify;
    return (_JSON$stringify = JSON.stringify(x4)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "";
  }
  if (Recoil_isPromise(x4)) {
    return "__PROMISE__";
  }
  if (Array.isArray(x4)) {
    return `[${x4.map((v3, i3) => stringify(v3, opt, i3.toString()))}]`;
  }
  if (typeof x4.toJSON === "function") {
    return stringify(x4.toJSON(key2), opt, key2);
  }
  if (x4 instanceof Map) {
    const obj = {};
    for (const [k4, v3] of x4) {
      obj[typeof k4 === "string" ? k4 : stringify(k4, opt)] = v3;
    }
    return stringify(obj, opt, key2);
  }
  if (x4 instanceof Set) {
    return stringify(Array.from(x4).sort((a3, b3) => stringify(a3, opt).localeCompare(stringify(b3, opt))), opt, key2);
  }
  if (Symbol !== void 0 && x4[Symbol.iterator] != null && typeof x4[Symbol.iterator] === "function") {
    return stringify(Array.from(x4), opt, key2);
  }
  return `{${Object.keys(x4).filter((key3) => x4[key3] !== void 0).sort().map((key3) => `${stringify(key3, opt)}:${stringify(x4[key3], opt, key3)}`).join(",")}}`;
}
function stableStringify(x4, opt = {
  allowFunctions: false
}) {
  if (true) {
    if (typeof window !== "undefined") {
      const startTime = window.performance ? window.performance.now() : 0;
      const str = stringify(x4, opt);
      const endTime = window.performance ? window.performance.now() : 0;
      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {
        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);
        console.warn(x4, str);
        console.groupEnd();
      }
      return str;
    }
  }
  return stringify(x4, opt);
}
var Recoil_stableStringify = stableStringify;
var TreeCache = class {
  constructor(options) {
    var _options$onHit, _options$onSet, _options$mapNodeValue;
    _defineProperty(this, "_numLeafs", void 0);
    _defineProperty(this, "_root", void 0);
    _defineProperty(this, "_onHit", void 0);
    _defineProperty(this, "_onSet", void 0);
    _defineProperty(this, "_mapNodeValue", void 0);
    this._numLeafs = 0;
    this._root = null;
    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {
    };
    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {
    };
    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val) => val;
  }
  size() {
    return this._numLeafs;
  }
  root() {
    return this._root;
  }
  get(getNodeValue, handlers) {
    var _this$getLeafNode;
    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;
  }
  getLeafNode(getNodeValue, handlers) {
    return findLeaf(this.root(), (nodeKey) => this._mapNodeValue(getNodeValue(nodeKey)), {
      onNodeVisit: (node) => {
        handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);
        if (node.type === "leaf") {
          this._onHit(node);
        }
      }
    });
  }
  set(route, value, handlers) {
    let leafNode;
    const newRoot = addLeaf(this.root(), route.map(([nodeKey, nodeValue]) => [nodeKey, this._mapNodeValue(nodeValue)]), null, value, null, {
      onNodeVisit: (node) => {
        handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);
        if (node.type === "leaf") {
          leafNode = node;
        }
      }
    });
    if (!this.root()) {
      this._root = newRoot;
    }
    this._numLeafs++;
    this._onSet(Recoil_nullthrows(leafNode));
  }
  delete(node) {
    if (!this.root()) {
      return false;
    }
    const root = Recoil_nullthrows(this.root());
    const existsInTree = pruneNodeFromTree(root, node, node.parent);
    if (!existsInTree) {
      return false;
    }
    if (node === root || root.type === "branch" && !root.branches.size) {
      this._root = null;
      this._numLeafs = 0;
      return true;
    }
    this._numLeafs -= countDownstreamLeaves(node);
    return true;
  }
  clear() {
    this._numLeafs = 0;
    this._root = null;
  }
};
var findLeaf = (root, getNodeValue, handlers) => {
  var _handlers$onNodeVisit;
  if (root == null) {
    return void 0;
  }
  handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, root);
  if (root.type === "leaf") {
    return root;
  }
  const nodeValue = getNodeValue(root.nodeKey);
  return findLeaf(root.branches.get(nodeValue), getNodeValue, handlers);
};
var addLeaf = (root, route, parent, value, branchKey, handlers) => {
  var _handlers$onNodeVisit2;
  let node;
  if (root == null) {
    if (route.length === 0) {
      node = {
        type: "leaf",
        value,
        parent,
        branchKey
      };
    } else {
      const [path, ...rest] = route;
      const [nodeKey, nodeValue] = path;
      node = {
        type: "branch",
        nodeKey,
        parent,
        branches: /* @__PURE__ */ new Map(),
        branchKey
      };
      node.branches.set(nodeValue, addLeaf(null, rest, node, value, nodeValue, handlers));
    }
  } else {
    node = root;
    if (route.length) {
      const [path, ...rest] = route;
      const [nodeKey, nodeValue] = path;
      !(root.type === "branch" && root.nodeKey === nodeKey) ? true ? Recoil_invariant(false, "Existing cache must have a branch midway through the route with matching node key") : Recoil_invariant(false) : void 0;
      root.branches.set(nodeValue, addLeaf(root.branches.get(nodeValue), rest, root, value, nodeValue, handlers));
    }
  }
  handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, node);
  return node;
};
var pruneNodeFromTree = (root, node, parent) => {
  if (!parent) {
    return root === node;
  }
  parent.branches.delete(node.branchKey);
  return pruneUpstreamBranches(root, parent, parent.parent);
};
var pruneUpstreamBranches = (root, branchNode, parent) => {
  if (!parent) {
    return root === branchNode;
  }
  if (branchNode.branches.size === 0) {
    parent.branches.delete(branchNode.branchKey);
  }
  return pruneUpstreamBranches(root, parent, parent.parent);
};
var countDownstreamLeaves = (node) => node.type === "leaf" ? 1 : Array.from(node.branches.values()).reduce((sum, currNode) => sum + countDownstreamLeaves(currNode), 0);
var Recoil_TreeCache = {
  TreeCache
};
var Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;
var Recoil_TreeCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  TreeCache: Recoil_TreeCache_1
});
var LRUCache = class {
  constructor(options) {
    var _options$mapKey;
    _defineProperty(this, "_maxSize", void 0);
    _defineProperty(this, "_size", void 0);
    _defineProperty(this, "_head", void 0);
    _defineProperty(this, "_tail", void 0);
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_keyMapper", void 0);
    this._maxSize = options.maxSize;
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v3) => v3;
  }
  head() {
    return this._head;
  }
  tail() {
    return this._tail;
  }
  size() {
    return this._size;
  }
  maxSize() {
    return this._maxSize;
  }
  has(key2) {
    return this._map.has(this._keyMapper(key2));
  }
  get(key2) {
    const mappedKey = this._keyMapper(key2);
    const node = this._map.get(mappedKey);
    if (!node) {
      return void 0;
    }
    this.set(key2, node.value);
    return node.value;
  }
  set(key2, val) {
    const mappedKey = this._keyMapper(key2);
    const existingNode = this._map.get(mappedKey);
    if (existingNode) {
      this.delete(key2);
    }
    const head = this.head();
    const node = {
      key: key2,
      right: head,
      left: null,
      value: val
    };
    if (head) {
      head.left = node;
    } else {
      this._tail = node;
    }
    this._map.set(mappedKey, node);
    this._head = node;
    this._size++;
    this._maybeDeleteLRU();
  }
  _maybeDeleteLRU() {
    if (this.size() > this.maxSize()) {
      this.deleteLru();
    }
  }
  deleteLru() {
    const tail = this.tail();
    if (tail) {
      this.delete(tail.key);
    }
  }
  delete(key2) {
    const mappedKey = this._keyMapper(key2);
    if (!this._size || !this._map.has(mappedKey)) {
      return;
    }
    const node = Recoil_nullthrows(this._map.get(mappedKey));
    const right2 = node.right;
    const left2 = node.left;
    if (right2) {
      right2.left = node.left;
    }
    if (left2) {
      left2.right = node.right;
    }
    if (node === this.head()) {
      this._head = right2;
    }
    if (node === this.tail()) {
      this._tail = left2;
    }
    this._map.delete(mappedKey);
    this._size--;
  }
  clear() {
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
  }
};
var Recoil_LRUCache = {
  LRUCache
};
var Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;
var Recoil_LRUCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LRUCache: Recoil_LRUCache_1
});
var {
  LRUCache: LRUCache$1
} = Recoil_LRUCache$1;
var {
  TreeCache: TreeCache$1
} = Recoil_TreeCache$1;
function treeCacheLRU(maxSize, mapNodeValue = (v3) => v3) {
  const lruCache = new LRUCache$1({
    maxSize
  });
  const cache = new TreeCache$1({
    mapNodeValue,
    onHit: (node) => {
      lruCache.set(node, true);
    },
    onSet: (node) => {
      const lruNode = lruCache.tail();
      lruCache.set(node, true);
      if (lruNode && cache.size() > maxSize) {
        cache.delete(lruNode.key);
      }
    }
  });
  return cache;
}
var Recoil_treeCacheLRU = treeCacheLRU;
var {
  TreeCache: TreeCache$2
} = Recoil_TreeCache$1;
var defaultPolicy = {
  equality: "reference",
  eviction: "keep-all",
  maxSize: Infinity
};
function treeCacheFromPolicy({
  equality = defaultPolicy.equality,
  eviction = defaultPolicy.eviction,
  maxSize = defaultPolicy.maxSize
} = defaultPolicy) {
  const valueMapper = getValueMapper(equality);
  const treeCache = getTreeCache(eviction, maxSize, valueMapper);
  return treeCache;
}
function getValueMapper(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw new Error(`Unrecognized equality policy ${equality}`);
}
function getTreeCache(eviction, maxSize, mapNodeValue) {
  switch (eviction) {
    case "keep-all":
      return new TreeCache$2({
        mapNodeValue
      });
    case "lru":
      return Recoil_treeCacheLRU(Recoil_nullthrows(maxSize), mapNodeValue);
    case "most-recent":
      return Recoil_treeCacheLRU(1, mapNodeValue);
  }
  throw new Error(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_treeCacheFromPolicy = treeCacheFromPolicy;
function startPerfBlock(_id) {
  return () => null;
}
var Recoil_PerformanceTimings = {
  startPerfBlock
};
var {
  CANCELED: CANCELED$2,
  Canceled: Canceled$1,
  loadableWithError: loadableWithError$1,
  loadableWithPromise: loadableWithPromise$1,
  loadableWithValue: loadableWithValue$2
} = Recoil_Loadable;
var {
  getNodeLoadable: getNodeLoadable$2,
  peekNodeLoadable: peekNodeLoadable$1,
  setNodeValue: setNodeValue$3
} = Recoil_FunctionalCore;
var {
  saveDependencyMapToStore: saveDependencyMapToStore$1
} = Recoil_Graph;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$4,
  RecoilValueNotReady: RecoilValueNotReady$2,
  getConfigDeletionHandler: getConfigDeletionHandler$1,
  registerNode: registerNode$1
} = Recoil_Node;
var {
  isRecoilValue: isRecoilValue$3
} = Recoil_RecoilValue$1;
var {
  AbstractRecoilValue: AbstractRecoilValue$4
} = Recoil_RecoilValue$1;
var {
  setRecoilValueLoadable: setRecoilValueLoadable$2
} = Recoil_RecoilValueInterface;
var {
  retainedByOptionWithDefault: retainedByOptionWithDefault$1
} = Recoil_Retention;
var {
  cloneSnapshot: cloneSnapshot$2
} = Recoil_Snapshot$1;
var {
  startPerfBlock: startPerfBlock$1
} = Recoil_PerformanceTimings;
var dependencyStack = [];
var waitingStores = /* @__PURE__ */ new Map();
var getNewExecutionId = (() => {
  let executionId = 0;
  return () => executionId++;
})();
function getInitialExecutionInfo() {
  return {
    depValuesDiscoveredSoFarDuringAsyncWork: null,
    latestLoadable: null,
    latestExecutionId: null,
    stateVersion: null
  };
}
function selector(options) {
  const {
    key: key2,
    get,
    cachePolicy_UNSTABLE: cachePolicy
  } = options;
  const set = options.set != null ? options.set : void 0;
  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {
    equality: "reference",
    eviction: "keep-all"
  });
  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);
  const executionInfoMap = /* @__PURE__ */ new Map();
  let liveStoresCount = 0;
  function selectorIsLive() {
    return !Recoil_gkx_1("recoil_memory_managament_2020") || liveStoresCount > 0;
  }
  function getExecutionInfo(store) {
    if (!executionInfoMap.has(store)) {
      executionInfoMap.set(store, getInitialExecutionInfo());
    }
    return Recoil_nullthrows(executionInfoMap.get(store));
  }
  function selectorInit(store) {
    liveStoresCount++;
    store.getState().knownSelectors.add(key2);
    return () => {
      liveStoresCount--;
      store.getState().knownSelectors.delete(key2);
      executionInfoMap.delete(store);
    };
  }
  function selectorShouldDeleteConfigOnRelease() {
    return getConfigDeletionHandler$1(key2) !== void 0 && !selectorIsLive();
  }
  function notifyStoreWhenAsyncSettles(store, loadable, executionId) {
    if (loadable.state === "loading") {
      let stores = waitingStores.get(executionId);
      if (stores == null) {
        waitingStores.set(executionId, stores = /* @__PURE__ */ new Set());
      }
      stores.add(store);
    }
  }
  function notifyStoresOfSettledAsync(newLoadable, executionId) {
    const stores = waitingStores.get(executionId);
    if (stores !== void 0) {
      for (const store of stores) {
        setRecoilValueLoadable$2(store, new AbstractRecoilValue$4(key2), newLoadable);
      }
      waitingStores.delete(executionId);
    }
  }
  function getCachedNodeLoadable(store, state, key3) {
    const isKeyPointingToSelector = store.getState().knownSelectors.has(key3);
    if (isKeyPointingToSelector && state.atomValues.has(key3)) {
      return Recoil_nullthrows(state.atomValues.get(key3));
    }
    const loadable = getNodeLoadable$2(store, state, key3);
    if (loadable.state !== "loading" && isKeyPointingToSelector) {
      state.atomValues.set(key3, loadable);
    }
    return loadable;
  }
  function wrapPendingPromise(store, promise, state, depValues, executionId) {
    return promise.then((value) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store, executionId);
        return CANCELED$2;
      }
      const loadable = loadableWithValue$2(value);
      maybeFreezeValue(value);
      setCache(state, depValuesToDepRoute(depValues), loadable);
      setDepsInStore(store, state, new Set(depValues.keys()), executionId);
      setLoadableInStoreToNotifyDeps(store, loadable, executionId);
      return {
        __value: value,
        __key: key2
      };
    }).catch((errorOrPromise) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store, executionId);
        return CANCELED$2;
      }
      if (isLatestExecution(store, executionId)) {
        updateExecutionInfoDepValues(depValues, store, executionId);
      }
      if (Recoil_isPromise(errorOrPromise)) {
        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionId);
      }
      const loadable = loadableWithError$1(errorOrPromise);
      maybeFreezeValue(errorOrPromise);
      setCache(state, depValuesToDepRoute(depValues), loadable);
      setDepsInStore(store, state, new Set(depValues.keys()), executionId);
      setLoadableInStoreToNotifyDeps(store, loadable, executionId);
      throw errorOrPromise;
    });
  }
  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionId) {
    return promise.then((resolvedDep) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store, executionId);
        return CANCELED$2;
      }
      if (resolvedDep instanceof Canceled$1) {
        Recoil_recoverableViolation("Selector was released while it had dependencies");
        return CANCELED$2;
      }
      const {
        __key: resolvedDepKey,
        __value: depValue
      } = resolvedDep !== null && resolvedDep !== void 0 ? resolvedDep : {};
      let bypassSelectorDepCacheOnReevaluation = true;
      if (resolvedDepKey != null) {
        state.atomValues.set(resolvedDepKey, loadableWithValue$2(depValue));
        bypassSelectorDepCacheOnReevaluation = false;
      }
      const cachedLoadable = getValFromCacheAndUpdatedDownstreamDeps(store, state);
      if (cachedLoadable && cachedLoadable.state === "hasValue") {
        setExecutionInfo(cachedLoadable, store);
        return {
          __value: cachedLoadable.contents,
          __key: key2
        };
      }
      if (!isLatestExecution(store, executionId)) {
        var _executionInfo$latest;
        const executionInfo = getExecutionInfoOfInProgressExecution(state);
        if ((executionInfo === null || executionInfo === void 0 ? void 0 : (_executionInfo$latest = executionInfo.latestLoadable) === null || _executionInfo$latest === void 0 ? void 0 : _executionInfo$latest.state) === "loading") {
          return executionInfo.latestLoadable.contents;
        }
      }
      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionId, bypassSelectorDepCacheOnReevaluation);
      if (isLatestExecution(store, executionId)) {
        updateExecutionInfoDepValues(depValues, store, executionId);
      }
      maybeFreezeLoadableContents(loadable);
      if (loadable.state !== "loading") {
        setCache(state, depValuesToDepRoute(depValues), loadable);
        setDepsInStore(store, state, new Set(depValues.keys()), executionId);
        setLoadableInStoreToNotifyDeps(store, loadable, executionId);
      }
      if (loadable.state === "hasError") {
        throw loadable.contents;
      }
      if (loadable.state === "hasValue") {
        return {
          __value: loadable.contents,
          __key: key2
        };
      }
      return loadable.contents;
    }).catch((error) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store, executionId);
        return CANCELED$2;
      }
      const loadable = loadableWithError$1(error);
      maybeFreezeValue(error);
      setCache(state, depValuesToDepRoute(existingDeps), loadableWithError$1(error));
      setDepsInStore(store, state, new Set(existingDeps.keys()), executionId);
      setLoadableInStoreToNotifyDeps(store, loadable, executionId);
      throw error;
    });
  }
  function setLoadableInStoreToNotifyDeps(store, loadable, executionId) {
    if (isLatestExecution(store, executionId)) {
      setExecutionInfo(loadable, store);
      notifyStoresOfSettledAsync(loadable, executionId);
    }
  }
  function setDepsInStore(store, state, deps, executionId) {
    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;
    if (isLatestExecution(store, executionId) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {
      var _store$getState$nextT, _store$getState3, _store$getState3$next;
      saveDependencyMapToStore$1(/* @__PURE__ */ new Map([[key2, deps]]), store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);
    }
  }
  function setNewDepInStore(store, state, deps, newDepKey, executionId) {
    deps.add(newDepKey);
    setDepsInStore(store, state, deps, executionId);
  }
  function evaluateSelectorGetter(store, state, executionId, bypassSelectorDepCache = false) {
    const endPerfBlock = startPerfBlock$1(key2);
    let result;
    let resultIsError = false;
    let loadable;
    const depValues = /* @__PURE__ */ new Map();
    const deps = /* @__PURE__ */ new Set();
    setDepsInStore(store, state, deps, executionId);
    function getRecoilValue(recoilValue) {
      const {
        key: depKey
      } = recoilValue;
      setNewDepInStore(store, state, deps, depKey, executionId);
      const depLoadable = bypassSelectorDepCache ? getNodeLoadable$2(store, state, depKey) : getCachedNodeLoadable(store, state, depKey);
      maybeFreezeLoadableContents(depLoadable);
      depValues.set(depKey, depLoadable);
      if (depLoadable.state === "hasValue") {
        return depLoadable.contents;
      }
      throw depLoadable.contents;
    }
    let gateCallback = false;
    const getCallback = (fn3) => {
      return (...args) => {
        if (!gateCallback) {
          throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");
        }
        const snapshot = cloneSnapshot$2(store);
        const cb = fn3({
          snapshot
        });
        if (typeof cb !== "function") {
          throw new Error("getCallback() expects a function that returns a function.");
        }
        return cb(...args);
      };
    };
    try {
      result = get({
        get: getRecoilValue,
        getCallback
      });
      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;
      gateCallback = true;
      if (Recoil_isPromise(result)) {
        result = wrapPendingPromise(store, result, state, depValues, executionId).finally(endPerfBlock);
      } else {
        endPerfBlock();
      }
    } catch (errorOrDepPromise) {
      result = errorOrDepPromise;
      if (Recoil_isPromise(result)) {
        result = wrapPendingDependencyPromise(store, result, state, depValues, executionId).finally(endPerfBlock);
      } else {
        resultIsError = true;
        endPerfBlock();
      }
    }
    if (resultIsError) {
      loadable = loadableWithError$1(result);
    } else if (Recoil_isPromise(result)) {
      loadable = loadableWithPromise$1(result);
    } else {
      loadable = loadableWithValue$2(result);
    }
    maybeFreezeLoadableContents(loadable);
    return [loadable, depValues];
  }
  function getValFromCacheAndUpdatedDownstreamDeps(store, state) {
    const depsAfterCacheDone = /* @__PURE__ */ new Set();
    const executionInfo = getExecutionInfo(store);
    const cachedVal = cache.get((nodeKey) => {
      !(typeof nodeKey === "string") ? true ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
      const loadable = getCachedNodeLoadable(store, state, nodeKey);
      return loadable.contents;
    }, {
      onNodeVisit: (node) => {
        if (node.type === "branch" && node.nodeKey !== key2 && typeof node.nodeKey === "string") {
          depsAfterCacheDone.add(node.nodeKey);
        }
      }
    });
    if (cachedVal) {
      setDepsInStore(store, state, depsAfterCacheDone, executionInfo.latestExecutionId);
    }
    return cachedVal;
  }
  function depValuesToDepRoute(depValues) {
    return Array.from(depValues.entries()).map(([key3, valLoadable]) => [key3, valLoadable.contents]);
  }
  function getValFromRunningNewExecutionAndUpdatedDeps(store, state) {
    const newExecutionId = getNewExecutionId();
    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionId);
    setExecutionInfo(loadable, store, newDepValues, newExecutionId, state);
    maybeSetCacheWithLoadable(state, depValuesToDepRoute(newDepValues), loadable);
    notifyStoreWhenAsyncSettles(store, loadable, newExecutionId);
    return loadable;
  }
  function getSelectorValAndUpdatedDeps(store, state) {
    const cachedVal = getValFromCacheAndUpdatedDownstreamDeps(store, state);
    if (cachedVal != null) {
      setExecutionInfo(cachedVal, store);
      return cachedVal;
    }
    const inProgressExecutionInfo = getExecutionInfoOfInProgressExecution(state);
    if (inProgressExecutionInfo) {
      const executionInfo = inProgressExecutionInfo;
      notifyStoreWhenAsyncSettles(store, Recoil_nullthrows(executionInfo.latestLoadable), Recoil_nullthrows(executionInfo.latestExecutionId));
      return Recoil_nullthrows(executionInfo.latestLoadable);
    }
    return getValFromRunningNewExecutionAndUpdatedDeps(store, state);
  }
  function getExecutionInfoOfInProgressExecution(state) {
    var _Array$from$find;
    const [, executionInfo] = (_Array$from$find = Array.from(executionInfoMap.entries()).find(([store, executionInfo2]) => {
      return executionInfo2.latestLoadable != null && executionInfo2.latestExecutionId != null && !haveAsyncDepsChanged(store, state);
    })) !== null && _Array$from$find !== void 0 ? _Array$from$find : [];
    return executionInfo;
  }
  const mapOfCheckedVersions = /* @__PURE__ */ new Map();
  function haveAsyncDepsChanged(store, state) {
    var _executionInfo$depVal, _mapOfCheckedVersions;
    const executionInfo = getExecutionInfo(store);
    const oldDepValues = (_executionInfo$depVal = executionInfo.depValuesDiscoveredSoFarDuringAsyncWork) !== null && _executionInfo$depVal !== void 0 ? _executionInfo$depVal : /* @__PURE__ */ new Map();
    const cachedDepValuesCheckedForThisVersion = Array(((_mapOfCheckedVersions = mapOfCheckedVersions.get(state.version)) !== null && _mapOfCheckedVersions !== void 0 ? _mapOfCheckedVersions : /* @__PURE__ */ new Map()).entries());
    const isCachedVersionSame = mapOfCheckedVersions.has(state.version) && cachedDepValuesCheckedForThisVersion.length === oldDepValues.size && cachedDepValuesCheckedForThisVersion.every(([nodeKey, nodeVal]) => {
      return oldDepValues.get(nodeKey) === nodeVal;
    });
    if (oldDepValues == null || state.version === executionInfo.stateVersion || isCachedVersionSame) {
      return false;
    }
    mapOfCheckedVersions.set(state.version, new Map(oldDepValues));
    return Array.from(oldDepValues).some(([nodeKey, oldVal]) => {
      const loadable = getCachedNodeLoadable(store, state, nodeKey);
      return loadable.contents !== oldVal.contents;
    });
  }
  function setExecutionInfo(loadable, store, depValues, newExecutionId, state) {
    const executionInfo = getExecutionInfo(store);
    if (loadable.state === "loading") {
      executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
      executionInfo.latestExecutionId = newExecutionId;
      executionInfo.latestLoadable = loadable;
      executionInfo.stateVersion = state === null || state === void 0 ? void 0 : state.version;
    } else {
      executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = null;
      executionInfo.latestExecutionId = null;
      executionInfo.latestLoadable = null;
      executionInfo.stateVersion = null;
    }
  }
  function maybeSetCacheWithLoadable(state, depRoute, loadable) {
    if (loadable.state !== "loading") {
      setCache(state, depRoute, loadable);
    }
  }
  function updateExecutionInfoDepValues(depValues, store, executionId) {
    const executionInfo = getExecutionInfo(store);
    if (isLatestExecution(store, executionId)) {
      executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
    }
  }
  function clearExecutionInfo(store, executionId) {
    if (isLatestExecution(store, executionId)) {
      executionInfoMap.delete(store);
    }
  }
  function isLatestExecution(store, executionId) {
    const executionInfo = getExecutionInfo(store);
    return executionId === executionInfo.latestExecutionId;
  }
  function maybeFreezeLoadableContents(loadable) {
    if (loadable.state !== "loading") {
      maybeFreezeValue(loadable.contents);
    }
  }
  function maybeFreezeValue(val) {
    if (true) {
      if (Boolean(options.dangerouslyAllowMutability) === false) {
        Recoil_deepFreezeValue(val);
      }
    }
  }
  function setCache(state, cacheRoute, loadable) {
    state.atomValues.set(key2, loadable);
    cache.set(cacheRoute, loadable);
  }
  function detectCircularDependencies(fn3) {
    if (dependencyStack.includes(key2)) {
      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key2)).join(" \u2192 ")}`;
      return loadableWithError$1(new Error(message));
    }
    dependencyStack.push(key2);
    try {
      return fn3();
    } finally {
      dependencyStack.pop();
    }
  }
  function selectorPeek(store, state) {
    const cacheVal = cache.get((nodeKey) => {
      !(typeof nodeKey === "string") ? true ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
      const peek = peekNodeLoadable$1(store, state, nodeKey);
      return peek === null || peek === void 0 ? void 0 : peek.contents;
    });
    return cacheVal;
  }
  function selectorGet(store, state) {
    return detectCircularDependencies(() => getSelectorValAndUpdatedDeps(store, state));
  }
  function invalidateSelector(state) {
    state.atomValues.delete(key2);
  }
  if (set != null) {
    const selectorSet = (store, state, newValue) => {
      let syncSelectorSetFinished = false;
      const writes = /* @__PURE__ */ new Map();
      function getRecoilValue({
        key: key3
      }) {
        if (syncSelectorSetFinished) {
          throw new Error("Recoil: Async selector sets are not currently supported.");
        }
        const loadable = getCachedNodeLoadable(store, state, key3);
        maybeFreezeLoadableContents(loadable);
        if (loadable.state === "hasValue") {
          return loadable.contents;
        } else if (loadable.state === "loading") {
          throw new RecoilValueNotReady$2(key3);
        } else {
          throw loadable.contents;
        }
      }
      function setRecoilState(recoilState, valueOrUpdater) {
        if (syncSelectorSetFinished) {
          throw new Error("Recoil: Async selector sets are not currently supported.");
        }
        const newValue2 = typeof valueOrUpdater === "function" ? valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;
        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, newValue2);
        upstreamWrites.forEach((v3, k4) => writes.set(k4, v3));
      }
      function resetRecoilState(recoilState) {
        setRecoilState(recoilState, DEFAULT_VALUE$4);
      }
      const ret = set({
        set: setRecoilState,
        get: getRecoilValue,
        reset: resetRecoilState
      }, newValue);
      if (ret !== void 0) {
        throw Recoil_isPromise(ret) ? new Error("Recoil: Async selector sets are not currently supported.") : new Error("Recoil: selector set should be a void function.");
      }
      syncSelectorSetFinished = true;
      return writes;
    };
    return registerNode$1({
      key: key2,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      set: selectorSet,
      init: selectorInit,
      invalidate: invalidateSelector,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  } else {
    return registerNode$1({
      key: key2,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      init: selectorInit,
      invalidate: invalidateSelector,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  }
}
var Recoil_selector = selector;
var {
  loadableWithError: loadableWithError$2,
  loadableWithPromise: loadableWithPromise$2,
  loadableWithValue: loadableWithValue$3
} = Recoil_Loadable;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$5,
  DefaultValue: DefaultValue$2,
  getConfigDeletionHandler: getConfigDeletionHandler$2,
  registerNode: registerNode$2,
  setConfigDeletionHandler: setConfigDeletionHandler$1
} = Recoil_Node;
var {
  isRecoilValue: isRecoilValue$4
} = Recoil_RecoilValue$1;
var {
  markRecoilValueModified: markRecoilValueModified$1,
  setRecoilValue: setRecoilValue$3,
  setRecoilValueLoadable: setRecoilValueLoadable$3
} = Recoil_RecoilValueInterface;
var {
  retainedByOptionWithDefault: retainedByOptionWithDefault$2
} = Recoil_Retention;
function baseAtom(options) {
  const {
    key: key2,
    persistence_UNSTABLE: persistence
  } = options;
  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);
  let liveStoresCount = 0;
  let defaultLoadable = Recoil_isPromise(options.default) ? loadableWithPromise$2(options.default.then((value) => {
    defaultLoadable = loadableWithValue$3(value);
    const promiseInfo = {
      __key: key2,
      __value: value
    };
    return promiseInfo;
  }).catch((error) => {
    defaultLoadable = loadableWithError$2(error);
    throw error;
  })) : loadableWithValue$3(options.default);
  let cachedAnswerForUnvalidatedValue = void 0;
  const cleanupEffectsByStore = /* @__PURE__ */ new Map();
  function wrapPendingPromise(store, promise) {
    const wrappedPromise = promise.then((value) => {
      var _store$getState$nextT, _state$atomValues$get;
      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;
      if (((_state$atomValues$get = state.atomValues.get(key2)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {
        setRecoilValue$3(store, node, value);
      }
      return {
        __key: key2,
        __value: value
      };
    }).catch((error) => {
      var _store$getState$nextT2, _state$atomValues$get2;
      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;
      if (((_state$atomValues$get2 = state.atomValues.get(key2)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {
        setRecoilValueLoadable$3(store, node, loadableWithError$2(error));
      }
      throw error;
    });
    return wrappedPromise;
  }
  function initAtom(store, initState, trigger) {
    liveStoresCount++;
    const alreadyKnown = store.getState().knownAtoms.has(key2);
    store.getState().knownAtoms.add(key2);
    if (defaultLoadable.state === "loading") {
      const notifyDefaultSubscribers = () => {
        var _store$getState$nextT3;
        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;
        if (!state.atomValues.has(key2)) {
          markRecoilValueModified$1(store, node);
        }
      };
      defaultLoadable.contents.then(notifyDefaultSubscribers).catch(notifyDefaultSubscribers);
    }
    let initValue = DEFAULT_VALUE$5;
    let pendingSetSelf = null;
    if (options.effects_UNSTABLE != null && !alreadyKnown) {
      let duringInit = true;
      const setSelf = (effect4) => (valueOrUpdater) => {
        if (duringInit) {
          const currentValue = initValue instanceof DefaultValue$2 || Recoil_isPromise(initValue) ? defaultLoadable.state === "hasValue" ? defaultLoadable.contents : DEFAULT_VALUE$5 : initValue;
          initValue = typeof valueOrUpdater === "function" ? valueOrUpdater(currentValue) : valueOrUpdater;
          if (Recoil_isPromise(initValue)) {
            initValue = initValue.then((value) => {
              pendingSetSelf = {
                effect: effect4,
                value
              };
              return value;
            });
          }
        } else {
          if (Recoil_isPromise(valueOrUpdater)) {
            throw new Error("Setting atoms to async values is not implemented.");
          }
          if (typeof valueOrUpdater !== "function") {
            pendingSetSelf = {
              effect: effect4,
              value: valueOrUpdater
            };
          }
          setRecoilValue$3(store, node, typeof valueOrUpdater === "function" ? (currentValue) => {
            const newValue = valueOrUpdater(currentValue);
            pendingSetSelf = {
              effect: effect4,
              value: newValue
            };
            return newValue;
          } : valueOrUpdater);
        }
      };
      const resetSelf = (effect4) => () => setSelf(effect4)(DEFAULT_VALUE$5);
      const onSet = (effect4) => (handler) => {
        store.subscribeToTransactions((currentStore) => {
          var _currentTree$atomValu;
          let {
            currentTree,
            previousTree
          } = currentStore.getState();
          if (!previousTree) {
            Recoil_recoverableViolation("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil");
            previousTree = currentTree;
          }
          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key2)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;
          if (newLoadable.state === "hasValue") {
            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;
            const newValue = newLoadable.contents;
            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key2)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;
            const oldValue = oldLoadable.state === "hasValue" ? oldLoadable.contents : DEFAULT_VALUE$5;
            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect4 || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {
              handler(newValue, oldValue);
            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect4) {
              pendingSetSelf = null;
            }
          }
        }, key2);
      };
      for (const effect4 of (_options$effects_UNST = options.effects_UNSTABLE) !== null && _options$effects_UNST !== void 0 ? _options$effects_UNST : []) {
        var _options$effects_UNST;
        const cleanup = effect4({
          node,
          trigger,
          setSelf: setSelf(effect4),
          resetSelf: resetSelf(effect4),
          onSet: onSet(effect4)
        });
        if (cleanup != null) {
          var _cleanupEffectsByStor;
          cleanupEffectsByStore.set(store, [...(_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor !== void 0 ? _cleanupEffectsByStor : [], cleanup]);
        }
      }
      duringInit = false;
    }
    if (!(initValue instanceof DefaultValue$2)) {
      var _store$getState$nextT4;
      const initLoadable = Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(initValue);
      initState.atomValues.set(key2, initLoadable);
      (_store$getState$nextT4 = store.getState().nextTree) === null || _store$getState$nextT4 === void 0 ? void 0 : _store$getState$nextT4.atomValues.set(key2, initLoadable);
    }
    return () => {
      var _cleanupEffectsByStor2;
      liveStoresCount--;
      (_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor2 === void 0 ? void 0 : _cleanupEffectsByStor2.forEach((cleanup) => cleanup());
      cleanupEffectsByStore.delete(store);
      store.getState().knownAtoms.delete(key2);
    };
  }
  function peekAtom(_store, state) {
    var _ref, _state$atomValues$get3, _cachedAnswerForUnval;
    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key2)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : (_cachedAnswerForUnval = cachedAnswerForUnvalidatedValue) === null || _cachedAnswerForUnval === void 0 ? void 0 : _cachedAnswerForUnval[1]) !== null && _ref !== void 0 ? _ref : defaultLoadable;
  }
  function getAtom(_store, state) {
    if (state.atomValues.has(key2)) {
      return Recoil_nullthrows(state.atomValues.get(key2));
    } else if (state.nonvalidatedAtoms.has(key2)) {
      if (cachedAnswerForUnvalidatedValue != null) {
        return cachedAnswerForUnvalidatedValue;
      }
      if (persistence == null) {
        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key2} but it has no persistence settings.`);
        return defaultLoadable;
      }
      const nonvalidatedValue = state.nonvalidatedAtoms.get(key2);
      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$5);
      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);
      cachedAnswerForUnvalidatedValue = validatedValueLoadable;
      return cachedAnswerForUnvalidatedValue;
    } else {
      return defaultLoadable;
    }
  }
  function invalidateAtom() {
    cachedAnswerForUnvalidatedValue = void 0;
  }
  function setAtom(_store, state, newValue) {
    if (state.atomValues.has(key2)) {
      const existing = Recoil_nullthrows(state.atomValues.get(key2));
      if (existing.state === "hasValue" && newValue === existing.contents) {
        return /* @__PURE__ */ new Map();
      }
    } else if (!state.nonvalidatedAtoms.has(key2) && newValue instanceof DefaultValue$2) {
      return /* @__PURE__ */ new Map();
    }
    if (true) {
      if (options.dangerouslyAllowMutability !== true) {
        Recoil_deepFreezeValue(newValue);
      }
    }
    cachedAnswerForUnvalidatedValue = void 0;
    return (/* @__PURE__ */ new Map()).set(key2, loadableWithValue$3(newValue));
  }
  function shouldDeleteConfigOnReleaseAtom() {
    return getConfigDeletionHandler$2(key2) !== void 0 && liveStoresCount <= 0;
  }
  const node = registerNode$2({
    key: key2,
    nodeType: "atom",
    peek: peekAtom,
    get: getAtom,
    set: setAtom,
    init: initAtom,
    invalidate: invalidateAtom,
    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,
    dangerouslyAllowMutability: options.dangerouslyAllowMutability,
    persistence_UNSTABLE: options.persistence_UNSTABLE ? {
      type: options.persistence_UNSTABLE.type,
      backButton: options.persistence_UNSTABLE.backButton
    } : void 0,
    shouldRestoreFromSnapshots: true,
    retainedBy
  });
  return node;
}
function atom(options) {
  const {
    default: optionsDefault,
    ...restOptions
  } = options;
  if (isRecoilValue$4(optionsDefault)) {
    return atomWithFallback({
      ...restOptions,
      default: optionsDefault
    });
  } else {
    return baseAtom({
      ...restOptions,
      default: optionsDefault
    });
  }
}
function atomWithFallback(options) {
  const base = atom({
    ...options,
    default: DEFAULT_VALUE$5,
    persistence_UNSTABLE: options.persistence_UNSTABLE === void 0 ? void 0 : {
      ...options.persistence_UNSTABLE,
      validator: (storedValue) => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$5)
    },
    effects_UNSTABLE: options.effects_UNSTABLE
  });
  const sel = Recoil_selector({
    key: `${options.key}__withFallback`,
    get: ({
      get
    }) => {
      const baseValue = get(base);
      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;
    },
    set: ({
      set
    }, newValue) => set(base, newValue),
    dangerouslyAllowMutability: options.dangerouslyAllowMutability
  });
  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));
  return sel;
}
var Recoil_atom = atom;
var MapCache = class {
  constructor(options) {
    var _options$mapKey;
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_keyMapper", void 0);
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v3) => v3;
  }
  size() {
    return this._map.size;
  }
  has(key2) {
    return this._map.has(this._keyMapper(key2));
  }
  get(key2) {
    return this._map.get(this._keyMapper(key2));
  }
  set(key2, val) {
    this._map.set(this._keyMapper(key2), val);
  }
  delete(key2) {
    this._map.delete(this._keyMapper(key2));
  }
  clear() {
    this._map.clear();
  }
};
var Recoil_MapCache = {
  MapCache
};
var Recoil_MapCache_1 = Recoil_MapCache.MapCache;
var Recoil_MapCache$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MapCache: Recoil_MapCache_1
});
var {
  LRUCache: LRUCache$2
} = Recoil_LRUCache$1;
var {
  MapCache: MapCache$1
} = Recoil_MapCache$1;
var defaultPolicy$1 = {
  equality: "reference",
  eviction: "none",
  maxSize: Infinity
};
function cacheFromPolicy({
  equality = defaultPolicy$1.equality,
  eviction = defaultPolicy$1.eviction,
  maxSize = defaultPolicy$1.maxSize
} = defaultPolicy$1) {
  const valueMapper = getValueMapper$1(equality);
  const cache = getCache(eviction, maxSize, valueMapper);
  return cache;
}
function getValueMapper$1(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw new Error(`Unrecognized equality policy ${equality}`);
}
function getCache(eviction, maxSize, mapKey) {
  switch (eviction) {
    case "keep-all":
      return new MapCache$1({
        mapKey
      });
    case "lru":
      return new LRUCache$2({
        mapKey,
        maxSize: Recoil_nullthrows(maxSize)
      });
    case "most-recent":
      return new LRUCache$2({
        mapKey,
        maxSize: 1
      });
  }
  throw new Error(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_cacheFromPolicy = cacheFromPolicy;
var {
  setConfigDeletionHandler: setConfigDeletionHandler$2
} = Recoil_Node;
function atomFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const atomCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify;
    const cachedAtom = atomCache.get(params);
    if (cachedAtom != null) {
      return cachedAtom;
    }
    const {
      cachePolicyForParams_UNSTABLE,
      ...atomOptions
    } = options;
    const newAtom = Recoil_atom({
      ...atomOptions,
      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}`,
      default: typeof options.default === "function" ? options.default(params) : options.default,
      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,
      effects_UNSTABLE: typeof options.effects_UNSTABLE === "function" ? options.effects_UNSTABLE(params) : options.effects_UNSTABLE
    });
    atomCache.set(params, newAtom);
    setConfigDeletionHandler$2(newAtom.key, () => {
      atomCache.delete(params);
    });
    return newAtom;
  };
}
var Recoil_atomFamily = atomFamily;
var {
  setConfigDeletionHandler: setConfigDeletionHandler$3
} = Recoil_Node;
var nextIndex = 0;
function selectorFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const selectorCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify;
    const cachedSelector = selectorCache.get(params);
    if (cachedSelector != null) {
      return cachedSelector;
    }
    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {
      allowFunctions: true
    })) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}/${nextIndex++}`;
    const myGet = (callbacks) => options.get(params)(callbacks);
    const myCachePolicy = options.cachePolicy_UNSTABLE;
    const retainedBy = typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;
    let newSelector;
    if (options.set != null) {
      const set = options.set;
      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        set: mySet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    } else {
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    }
    selectorCache.set(params, newSelector);
    setConfigDeletionHandler$3(newSelector.key, () => {
      selectorCache.delete(params);
    });
    return newSelector;
  };
}
var Recoil_selectorFamily = selectorFamily;
var constantSelector = Recoil_selectorFamily({
  key: "__constant",
  get: (constant) => () => constant,
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function constSelector(constant) {
  return constantSelector(constant);
}
var Recoil_constSelector = constSelector;
var throwingSelector = Recoil_selectorFamily({
  key: "__error",
  get: (message) => () => {
    throw new Error(message);
  },
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function errorSelector(message) {
  return throwingSelector(message);
}
var Recoil_errorSelector = errorSelector;
function readOnlySelector(atom2) {
  return atom2;
}
var Recoil_readOnlySelector = readOnlySelector;
var {
  loadableWithError: loadableWithError$3,
  loadableWithPromise: loadableWithPromise$3,
  loadableWithValue: loadableWithValue$4
} = Recoil_Loadable;
function concurrentRequests(getRecoilValue, deps) {
  const results = Array(deps.length).fill(void 0);
  const exceptions = Array(deps.length).fill(void 0);
  for (const [i3, dep] of deps.entries()) {
    try {
      results[i3] = getRecoilValue(dep);
    } catch (e3) {
      exceptions[i3] = e3;
    }
  }
  return [results, exceptions];
}
function isError(exp) {
  return exp != null && !Recoil_isPromise(exp);
}
function unwrapDependencies(dependencies) {
  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key2) => dependencies[key2]);
}
function getValueFromLoadablePromiseResult(result) {
  if (result != null && typeof result === "object" && result.hasOwnProperty("__value")) {
    return result.__value;
  }
  return result;
}
function wrapResults(dependencies, results) {
  return Array.isArray(dependencies) ? results : Object.getOwnPropertyNames(dependencies).reduce((out, key2, idx) => ({
    ...out,
    [key2]: results[idx]
  }), {});
}
function wrapLoadables(dependencies, results, exceptions) {
  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
  return wrapResults(dependencies, output);
}
function combineAsyncResultsWithSyncResults(syncResults, asyncResults) {
  return asyncResults.map((result, idx) => result === void 0 ? syncResults[idx] : result);
}
var waitForNone = Recoil_selectorFamily({
  key: "__waitForNone",
  get: (dependencies) => ({
    get
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps);
    return wrapLoadables(dependencies, results, exceptions);
  },
  dangerouslyAllowMutability: true
});
var waitForAny = Recoil_selectorFamily({
  key: "__waitForAny",
  get: (dependencies) => ({
    get
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps);
    if (exceptions.some((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return new Promise((resolve) => {
      for (const [i3, exp] of exceptions.entries()) {
        if (Recoil_isPromise(exp)) {
          exp.then((result) => {
            results[i3] = getValueFromLoadablePromiseResult(result);
            exceptions[i3] = void 0;
            resolve(wrapLoadables(dependencies, results, exceptions));
          }).catch((error) => {
            exceptions[i3] = error;
            resolve(wrapLoadables(dependencies, results, exceptions));
          });
        }
      }
    });
  },
  dangerouslyAllowMutability: true
});
var waitForAll = Recoil_selectorFamily({
  key: "__waitForAll",
  get: (dependencies) => ({
    get
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps);
    if (exceptions.every((exp) => exp == null)) {
      return wrapResults(dependencies, results);
    }
    const error = exceptions.find(isError);
    if (error != null) {
      throw error;
    }
    return Promise.all(exceptions).then((exceptionResults) => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults).map(getValueFromLoadablePromiseResult)));
  },
  dangerouslyAllowMutability: true
});
var waitForAllSettled = Recoil_selectorFamily({
  key: "__waitForAllSettled",
  get: (dependencies) => ({
    get
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get, deps);
    if (exceptions.every((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return Promise.all(exceptions.map((exp, i3) => Recoil_isPromise(exp) ? exp.then((result) => {
      results[i3] = getValueFromLoadablePromiseResult(result);
      exceptions[i3] = void 0;
    }).catch((error) => {
      results[i3] = void 0;
      exceptions[i3] = error;
    }) : null)).then(() => wrapLoadables(dependencies, results, exceptions));
  },
  dangerouslyAllowMutability: true
});
var noWait = Recoil_selectorFamily({
  key: "__noWait",
  get: (dependency) => ({
    get
  }) => {
    try {
      return loadableWithValue$4(get(dependency));
    } catch (exception) {
      return Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception);
    }
  },
  dangerouslyAllowMutability: true
});
var Recoil_WaitFor = {
  waitForNone,
  waitForAny,
  waitForAll,
  waitForAllSettled,
  noWait
};
var {
  batchUpdates: batchUpdates$3,
  setBatcher: setBatcher$1
} = Recoil_Batching;
var {
  DefaultValue: DefaultValue$3
} = Recoil_Node;
var {
  RecoilRoot: RecoilRoot$2
} = Recoil_RecoilRoot_react;
var {
  isRecoilValue: isRecoilValue$5
} = Recoil_RecoilValue$1;
var {
  retentionZone: retentionZone$1
} = Recoil_RetentionZone;
var {
  freshSnapshot: freshSnapshot$2
} = Recoil_Snapshot$1;
var {
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilCallback: useRecoilCallback$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilState: useRecoilState$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useRecoilTransaction: useRecoilTransaction$1,
  useRecoilTransactionObserver: useRecoilTransactionObserver$1,
  useRecoilValue: useRecoilValue$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useResetRecoilState: useResetRecoilState$1,
  useRetain: useRetain$1,
  useSetRecoilState: useSetRecoilState$1,
  useSetUnvalidatedAtomValues: useSetUnvalidatedAtomValues$1,
  useTransactionObservation_DEPRECATED: useTransactionObservation_DEPRECATED$1
} = Recoil_Hooks;
var {
  noWait: noWait$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  waitForAny: waitForAny$1,
  waitForNone: waitForNone$1
} = Recoil_WaitFor;
var Recoil_index = {
  DefaultValue: DefaultValue$3,
  RecoilRoot: RecoilRoot$2,
  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,
  atom: Recoil_atom,
  selector: Recoil_selector,
  retentionZone: retentionZone$1,
  atomFamily: Recoil_atomFamily,
  selectorFamily: Recoil_selectorFamily,
  constSelector: Recoil_constSelector,
  errorSelector: Recoil_errorSelector,
  readOnlySelector: Recoil_readOnlySelector,
  useRecoilValue: useRecoilValue$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilState: useRecoilState$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useSetRecoilState: useSetRecoilState$1,
  useResetRecoilState: useResetRecoilState$1,
  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,
  useRetain: useRetain$1,
  useRecoilCallback: useRecoilCallback$1,
  useRecoilTransaction_UNSTABLE: useRecoilTransaction$1,
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,
  useTransactionObservation_UNSTABLE: useTransactionObservation_DEPRECATED$1,
  useSetUnvalidatedAtomValues_UNSTABLE: useSetUnvalidatedAtomValues$1,
  noWait: noWait$1,
  waitForNone: waitForNone$1,
  waitForAny: waitForAny$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  isRecoilValue: isRecoilValue$5,
  batchUpdates: batchUpdates$3,
  setBatcher: setBatcher$1,
  snapshot_UNSTABLE: freshSnapshot$2
};
var Recoil_index_1 = Recoil_index.DefaultValue;
var Recoil_index_2 = Recoil_index.RecoilRoot;
var Recoil_index_3 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;
var Recoil_index_4 = Recoil_index.atom;
var Recoil_index_5 = Recoil_index.selector;
var Recoil_index_6 = Recoil_index.retentionZone;
var Recoil_index_7 = Recoil_index.atomFamily;
var Recoil_index_8 = Recoil_index.selectorFamily;
var Recoil_index_9 = Recoil_index.constSelector;
var Recoil_index_10 = Recoil_index.errorSelector;
var Recoil_index_11 = Recoil_index.readOnlySelector;
var Recoil_index_12 = Recoil_index.useRecoilValue;
var Recoil_index_13 = Recoil_index.useRecoilValueLoadable;
var Recoil_index_14 = Recoil_index.useRecoilState;
var Recoil_index_15 = Recoil_index.useRecoilStateLoadable;
var Recoil_index_16 = Recoil_index.useSetRecoilState;
var Recoil_index_17 = Recoil_index.useResetRecoilState;
var Recoil_index_18 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;
var Recoil_index_19 = Recoil_index.useRetain;
var Recoil_index_20 = Recoil_index.useRecoilCallback;
var Recoil_index_21 = Recoil_index.useRecoilTransaction_UNSTABLE;
var Recoil_index_22 = Recoil_index.useGotoRecoilSnapshot;
var Recoil_index_23 = Recoil_index.useRecoilSnapshot;
var Recoil_index_24 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;
var Recoil_index_25 = Recoil_index.useTransactionObservation_UNSTABLE;
var Recoil_index_26 = Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE;
var Recoil_index_27 = Recoil_index.noWait;
var Recoil_index_28 = Recoil_index.waitForNone;
var Recoil_index_29 = Recoil_index.waitForAny;
var Recoil_index_30 = Recoil_index.waitForAll;
var Recoil_index_31 = Recoil_index.waitForAllSettled;
var Recoil_index_32 = Recoil_index.isRecoilValue;
var Recoil_index_33 = Recoil_index.batchUpdates;
var Recoil_index_34 = Recoil_index.setBatcher;
var Recoil_index_35 = Recoil_index.snapshot_UNSTABLE;

// src/types/types.ts
var eventTypes = {
  activeFileChange: "mkmd-active-file-change",
  refreshView: "mkmd-refresh-view",
  revealFile: "mkmd-reveal-file",
  vaultChange: "mkmd-vault-change",
  updateSections: "mkmd-update-sections",
  settingsChanged: "mkmd-settings-changed",
  spawnPortal: "mkmd-portal-spawn",
  openFilePortal: "mkmd-portal-file",
  focusPortal: "mkmd-portal-focus"
};

// src/hooks/ForceUpdate.tsx
function useForceUpdate() {
  const [value, setValue] = p2(0);
  return () => setValue((value2) => value2 + 1);
}

// src/components/Spaces/FileExplorerVirtualized.tsx
var import_obsidian8 = require("obsidian");

// src/recoil/pluginState.ts
var activeFile = Recoil_index_4({
  key: "spacesActiveFile",
  default: null,
  dangerouslyAllowMutability: true
});
var folderTree = Recoil_index_4({
  key: "spacesFolderTree",
  default: null,
  dangerouslyAllowMutability: true
});
var sections = Recoil_index_4({
  key: "spacesSections",
  default: [],
  dangerouslyAllowMutability: true
});
var fileIcons = Recoil_index_4({
  key: "spacesIcons",
  default: []
});
var openFolders = Recoil_index_4({
  key: "spacesOpenFolders",
  default: []
});
var focusedFolder = Recoil_index_4({
  key: "spacesFocusedFolder",
  default: null,
  dangerouslyAllowMutability: true
});

// src/utils/utils.ts
var import_obsidian4 = require("obsidian");

// src/components/Spaces/modals.ts
var import_obsidian = require("obsidian");

// src/i18n.ts
var T4 = class {
  constructor() {
    this.all = {
      en: {
        commands: {
          h1: "Heading 1",
          h2: "Heading 2",
          h3: "Heading 3",
          list: "Bullet List",
          "ordered-list": "Numbered List",
          todo: "To-do List",
          quote: "Quote",
          divider: "Divider",
          note: "Link to Note",
          link: "Web Link",
          callout: "Callout",
          codeblock: "Code Block",
          emoji: "Emoji",
          image: "Image",
          flow: "Flow Note",
          tag: "Tag",
          makeMenu: "Make Menu",
          selectStyle: "Style",
          toggleKeyboard: "Toggle Keyboard"
        },
        styles: {
          bold: "Bold",
          italics: "Italics",
          strikethrough: "Strikethrough",
          code: "Code",
          link: "Web Link",
          blocklink: "Link to Note",
          textColor: "Text Color",
          highlight: "Highlight"
        },
        commandsSuggest: {
          noResult: "No result"
        },
        commandPalette: {
          enable: "Enable",
          disabled: "Disable",
          openFlow: "Open Flow Editors in Selection",
          closeFlow: "Close Flow Editors in Selection",
          toggleBold: "Toggle Bold",
          toggleItalics: "Toggle Italics"
        },
        menu: {
          openFilePane: "Open in a new pane",
          rename: "Rename",
          moveFile: "Move file to...",
          duplicate: "Make a copy",
          edit: "Edit",
          delete: "Delete",
          getHelp: "Make.md Community",
          openVault: "Open Another Vault",
          obSettings: "Obsidian Settings",
          commandPalette: "Command Palette",
          backToSpace: "Back to Spaces",
          newSpace: "New Space",
          collapseAllSections: "Collapse All Spaces",
          expandAllSections: "Expand All Spaces",
          collapseAllFolders: "Collapse All Folders",
          expandAllFolders: "Expand All Folders",
          spaceTitle: "Add/Remove in Space"
        },
        buttons: {
          moreOptions: "More Options",
          newNote: "New Note",
          changeIcon: "Change Sticker",
          removeIcon: "Remove Sticker",
          rename: "Change Name",
          createFolder: "New Folder",
          createNote: "New Note",
          createSection: "New Space",
          cancel: "Cancel",
          search: "Search",
          toggleFlow: "Toggle Flow",
          openFlow: "Open Flow",
          hideFlow: "Hide Flow",
          openLink: "Open Link"
        },
        labels: {
          createFolder: "New Folder Name",
          rename: "Rename Note",
          renameSection: "Rename Space",
          createSection: "New Space",
          createNote: "New Note Name",
          collapse: "Collapse",
          expand: "Expand",
          findStickers: "Find Sticker",
          placeholder: "Type '/' for commands",
          noFile: "is not created yet. Click to create."
        },
        flowView: {
          emptyDoc: "Empty Document",
          itemsCount: " Items",
          emptyFolder: "This Folder is Empty"
        },
        notice: {
          duplicateFile: "Folder already contains note with same name",
          addedToSection: "Added to Space"
        },
        settings: {
          sectionSidebar: "Spaces",
          sectionEditor: "Maker Mode",
          sectionFlow: "Flow Editor",
          sectionAdvanced: "Advanced",
          spaces: {
            name: "Spaces",
            desc: `Spaces gives you control over how you organize your files`
          },
          spacesStickers: {
            name: "Stickers",
            desc: `Use Emojis to make it easier to find your notes`
          },
          spacesFileExplorerDual: {
            name: "Use Spaces Alongside File Explorer",
            desc: "This will allow plugins that uses the File Explorer to work while using Spaces"
          },
          spacesDeleteOption: {
            name: "Delete File Option",
            desc: "Select how you want files to be deleted"
          },
          spacesDeleteOptions: {
            permanant: "Delete Permanently",
            trash: "Move to Obsidian Trash",
            "system-trash": "Move to System Trash"
          },
          sidebarRibbon: {
            name: "Show Ribbon Bar",
            desc: `Show/hide Obsidian ribbon bar`
          },
          sidebarTabs: {
            name: "Show Sidebar Tabs",
            desc: `Show/hide other sidebar tabs`
          },
          spacesPerformance: {
            name: "Spaces Performance Mode",
            desc: `Turn on performance mode for Spaces, may affect scrolling appearance. Requires Restart`
          },
          inlineStyler: {
            name: "Inline Styler",
            desc: `Select text to add styling, recommended for Flow Editor`
          },
          inlineStylerColor: {
            name: "Text and Highlight Colors \u{1F9EA}",
            desc: `Select text color and highlight color, (this may change in the future because of the limitations with HTML and Obsidian)`
          },
          makeChar: {
            name: "Make Menu Trigger",
            desc: "Character to open the Make Menu"
          },
          mobileMakeBar: {
            name: "Make Bar (Mobile)",
            desc: "Replaces the mobile toolbar"
          },
          editorMarkSans: {
            name: "Mark Sans \u{1F9EA}",
            desc: `Use the editor without Markdown.`
          },
          editorMakePlacholder: {
            name: "Make Menu Hint Text",
            desc: `Show a hint text on how to open the Make Menu Shortcut`
          },
          editorMakeMenu: {
            name: "Make Menu Shortcut",
            desc: `Open the Make menu to quickly add content`
          },
          editorFlowReplace: {
            name: "Flow Editor",
            desc: `Open your internal links or toggle your embeds in the flow editor.`
          },
          editorFlowStyle: {
            name: "Flow Editor Style",
            desc: "Select a theme for your flow editors",
            seamless: "Seamless",
            classic: "Classic"
          }
        }
      }
    };
    this.lang = localStorage.getItem("language");
  }
  get texts() {
    return this.all["en"];
  }
};
var i18n_default = new T4().texts;

// src/components/Spaces/modals.ts
var VaultChangeModal = class extends import_obsidian.Modal {
  constructor(plugin, file, action, section) {
    super(plugin.app);
    this.file = file;
    this.action = action;
    this.plugin = plugin;
    this.section = section;
  }
  onOpen() {
    let { contentEl } = this;
    let myModal = this;
    let headerText;
    if (this.action === "rename") {
      headerText = i18n_default.labels.rename;
    } else if (this.action === "create folder") {
      headerText = i18n_default.labels.createFolder;
    } else if (this.action === "create note") {
      headerText = i18n_default.labels.createNote;
    }
    const headerEl = contentEl.createEl("div", { text: headerText });
    headerEl.addClass("modal-title");
    const inputEl = contentEl.createEl("input");
    inputEl.style.cssText = "width: 100%; height: 2.5em; margin-bottom: 15px;";
    if (this.action === "rename") {
      if (this.file.name.endsWith(".md")) {
        inputEl.value = this.file.name.substring(0, this.file.name.lastIndexOf("."));
      } else {
        inputEl.value = this.file.name;
      }
    }
    inputEl.focus();
    let changeButtonText;
    if (this.action === "rename") {
      changeButtonText = i18n_default.buttons.rename;
    } else if (this.action === "create folder") {
      changeButtonText = i18n_default.buttons.createFolder;
    } else if (this.action === "create note") {
      changeButtonText = i18n_default.buttons.createNote;
    }
    const changeButton = contentEl.createEl("button", { text: changeButtonText });
    const cancelButton = contentEl.createEl("button", { text: i18n_default.buttons.cancel });
    cancelButton.style.cssText = "float: right;";
    cancelButton.addEventListener("click", () => {
      myModal.close();
    });
    const updateSections = (sections2) => {
      this.plugin.settings.spaces = sections2;
      this.plugin.saveSettings();
    };
    const onClickAction = async () => {
      let newName = inputEl.value;
      if (this.action === "rename") {
        if (this.file.name.endsWith(".md"))
          newName = newName + ".md";
        this.app.fileManager.renameFile(this.file, this.file.parent.path + "/" + newName);
      } else if (this.action === "create folder") {
        const path = this.file.path + "/" + newName;
        this.app.vault.createFolder(path);
        if (this.section >= 0)
          updateSections(this.plugin.settings.spaces.map((s3, k4) => {
            return k4 == this.section ? {
              ...s3,
              children: [newName, ...s3.children]
            } : s3;
          }));
      } else if (this.action === "create note") {
        await createNewMarkdownFile(this.plugin.app, this.file, newName, "");
      }
      myModal.close();
    };
    changeButton.addEventListener("click", onClickAction);
    inputEl.addEventListener("keydown", (e3) => {
      if (e3.key === "Enter")
        onClickAction();
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var MoveSuggestionModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, fileOrFolderToMove) {
    super(app2);
    this.fileOrFolderToMove = fileOrFolderToMove;
  }
  getItemText(item) {
    return item.path;
  }
  getItems() {
    return getAllFoldersInVault(this.app);
  }
  onChooseItem(item, evt) {
    this.app.vault.rename(this.fileOrFolderToMove, item.path + "/" + this.fileOrFolderToMove.name);
  }
};
function getAllFoldersInVault(app2) {
  let folders = [];
  let rootFolder = app2.vault.getRoot();
  folders.push(rootFolder);
  function recursiveFx(folder) {
    for (let child of folder.children) {
      if (child instanceof import_obsidian.TFolder) {
        let childFolder = child;
        folders.push(childFolder);
        if (childFolder.children)
          recursiveFx(childFolder);
      }
    }
  }
  recursiveFx(rootFolder);
  return folders;
}
var SectionChangeModal = class extends import_obsidian.Modal {
  constructor(plugin, section, sectionIndex, action) {
    super(plugin.app);
    this.section = section;
    this.sectionIndex = sectionIndex;
    this.action = action;
    this.plugin = plugin;
  }
  onOpen() {
    let { contentEl } = this;
    let myModal = this;
    let headerText;
    if (this.action === "rename") {
      headerText = i18n_default.labels.renameSection;
    } else if (this.action === "create") {
      headerText = i18n_default.labels.createSection;
    }
    const headerEl = contentEl.createEl("div", { text: headerText });
    headerEl.addClass("modal-title");
    const inputEl = contentEl.createEl("input");
    inputEl.style.cssText = "width: 100%; height: 2.5em; margin-bottom: 15px;";
    if (this.action === "rename") {
      inputEl.value = this.section;
    }
    inputEl.focus();
    let changeButtonText;
    if (this.action === "rename") {
      changeButtonText = i18n_default.buttons.rename;
    } else if (this.action === "create") {
      changeButtonText = i18n_default.buttons.createSection;
    }
    const changeButton = contentEl.createEl("button", { text: changeButtonText });
    const cancelButton = contentEl.createEl("button", { text: i18n_default.buttons.cancel });
    cancelButton.style.cssText = "float: right;";
    cancelButton.addEventListener("click", () => {
      myModal.close();
    });
    const updateSections = (sections2) => {
      this.plugin.settings.spaces = sections2;
      this.plugin.saveSettings();
    };
    const onClickAction = async () => {
      let newName = inputEl.value;
      if (this.action === "rename") {
        updateSections(this.plugin.settings.spaces.map((s3, i3) => {
          return i3 == this.sectionIndex ? {
            ...s3,
            section: newName
          } : s3;
        }));
      } else if (this.action === "create") {
        updateSections([{ section: newName, children: [], collapsed: false }, ...this.plugin.settings.spaces]);
      }
      myModal.close();
    };
    changeButton.addEventListener("click", onClickAction);
    inputEl.addEventListener("keydown", (e3) => {
      if (e3.key === "Enter")
        onClickAction();
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/components/FlowView/FlowView.tsx
var import_obsidian3 = require("obsidian");

// src/components/FlowView/FlowRow.tsx
var import_dayjs = __toESM(require_dayjs_min());

// src/cm-extensions/markSans/callout.tsx
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");

// src/components/FlowEditor/FlowEditor.tsx
var import_obsidian2 = require("obsidian");
function genId(size2) {
  const chars = [];
  for (let n2 = 0; n2 < size2; n2++)
    chars.push((16 * Math.random() | 0).toString(16));
  return chars.join("");
}
var popovers = /* @__PURE__ */ new WeakMap();
var mouseCoords = { x: 0, y: 0 };
function nosuper(base) {
  const derived = function() {
    return Object.setPrototypeOf(new import_obsidian2.Component(), new.target.prototype);
  };
  derived.prototype = base.prototype;
  return Object.setPrototypeOf(derived, base);
}
var _a, _b, _c, _d, _e;
var FlowEditor = class extends nosuper(import_obsidian2.HoverPopover) {
  constructor(parent, targetEl, plugin, waitTime, onShowCallback) {
    super();
    this.targetEl = targetEl;
    this.plugin = plugin;
    this.onShowCallback = onShowCallback;
    this.abortController = this.addChild(new import_obsidian2.Component());
    this.detaching = false;
    this.opening = false;
    this.rootSplit = new import_obsidian2.WorkspaceSplit(window.app.workspace, "vertical");
    this.targetRect = (_a = this.targetEl) == null ? void 0 : _a.getBoundingClientRect();
    this.oldPopover = (_b = this.parent) == null ? void 0 : _b.flowEditor;
    this.document = (_e = (_d = (_c = this.targetEl) == null ? void 0 : _c.ownerDocument) != null ? _d : window.activeDocument) != null ? _e : window.document;
    this.id = genId(8);
    this.hoverEl = this.document.defaultView.createDiv({
      cls: "mk-floweditor mk-hover-popover",
      attr: { id: "he" + this.id }
    });
    if (waitTime === void 0) {
      waitTime = 300;
    }
    this.onTarget = true;
    this.parent = parent;
    this.waitTime = waitTime;
    this.state = import_obsidian2.PopoverState.Showing;
    const { hoverEl } = this;
    this.abortController.load();
    this.timer = window.setTimeout(this.show.bind(this), waitTime);
    this.setActive = this._setActive.bind(this);
    if (hoverEl) {
      hoverEl.addEventListener("mousedown", this.setActive);
    }
    popovers.set(this.hoverEl, this);
    this.hoverEl.addClass("hover-editor");
    this.containerEl = this.hoverEl.createDiv("popover-content");
    this.setTitleBar();
    this.hoverEl.style.height = "auto";
    this.hoverEl.style.width = "100%";
  }
  static activeWindows() {
    const windows = [window];
    const { floatingSplit } = app.workspace;
    if (floatingSplit) {
      for (const split of floatingSplit.children) {
        if (split.win)
          windows.push(split.win);
      }
    }
    return windows;
  }
  static containerForDocument(doc) {
    if (doc !== document && app.workspace.floatingSplit)
      for (const container of app.workspace.floatingSplit.children) {
        if (container.doc === doc)
          return container;
      }
    return app.workspace.rootSplit;
  }
  static activePopovers() {
    return this.activeWindows().flatMap(this.popoversForWindow);
  }
  static popoversForWindow(win) {
    var _a2, _b2;
    return Array.prototype.slice.call((_b2 = (_a2 = win == null ? void 0 : win.document) == null ? void 0 : _a2.body.querySelectorAll(".mk-hover-popover")) != null ? _b2 : []).map((el) => popovers.get(el)).filter((he) => he);
  }
  static forLeaf(leaf) {
    const el = leaf && document.body.matchParent.call(leaf.containerEl, ".mk-hover-popover");
    return el ? popovers.get(el) : void 0;
  }
  _setActive() {
    this.plugin.app.workspace.setActiveLeaf(this.leaves()[0], { focus: true });
  }
  getDefaultMode() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.parent) == null ? void 0 : _a2.view) == null ? void 0 : _b2.getMode) ? this.parent.view.getMode() : "preview";
  }
  updateLeaves() {
    if (this.onTarget && this.targetEl && !this.document.contains(this.targetEl)) {
      this.onTarget = false;
      this.transition();
    }
    let leafCount = 0;
    this.plugin.app.workspace.iterateLeaves((leaf) => {
      leafCount++;
    }, this.rootSplit);
    if (leafCount === 0) {
      this.hide();
    } else if (leafCount > 1) {
    }
    this.hoverEl.setAttribute("data-leaf-count", leafCount.toString());
  }
  setTitleBar() {
    this.titleEl = this.document.defaultView.createDiv("mk-flow-titlebar");
    this.containerEl.prepend(this.titleEl);
  }
  attachLeaf() {
    this.rootSplit.getRoot = () => this.plugin.app.workspace[this.document === document ? "rootSplit" : "floatingSplit"];
    this.rootSplit.getContainer = () => FlowEditor.containerForDocument(this.document);
    this.titleEl.insertAdjacentElement("afterend", this.rootSplit.containerEl);
    const leaf = this.plugin.app.workspace.createLeafInParent(this.rootSplit, 0);
    this.updateLeaves();
    return leaf;
  }
  onload() {
    super.onload();
    this.registerEvent(this.plugin.app.workspace.on("layout-change", this.updateLeaves, this));
    this.registerEvent(app.workspace.on("layout-change", () => {
      this.rootSplit.children.forEach((item, index) => {
        if (item instanceof import_obsidian2.WorkspaceTabs) {
          this.rootSplit.replaceChild(index, item.children[0]);
        }
      });
    }));
  }
  leaves() {
    const leaves = [];
    this.plugin.app.workspace.iterateLeaves((leaf) => {
      leaves.push(leaf);
    }, this.rootSplit);
    return leaves;
  }
  onShow() {
    var _a2, _b2;
    const closeDelay = 600;
    setTimeout(() => this.waitTime = closeDelay, closeDelay);
    (_a2 = this.oldPopover) == null ? void 0 : _a2.hide();
    this.oldPopover = null;
    this.hoverEl.toggleClass("is-new", true);
    this.document.body.addEventListener("click", () => {
      this.hoverEl.toggleClass("is-new", false);
    }, { once: true, capture: true });
    if (this.parent) {
      this.parent.flowEditor = this;
    }
    const viewHeaderEl = this.hoverEl.querySelector(".view-header");
    viewHeaderEl == null ? void 0 : viewHeaderEl.remove();
    const sizer = this.hoverEl.querySelector(".workspace-leaf");
    this.hoverEl.appendChild(sizer);
    const inlineTitle = this.hoverEl.querySelector(".inline-title");
    inlineTitle.remove();
    (_b2 = this.onShowCallback) == null ? void 0 : _b2.call(this);
    this.onShowCallback = void 0;
  }
  transition() {
    if (this.shouldShow()) {
      if (this.state === import_obsidian2.PopoverState.Hiding) {
        this.state = import_obsidian2.PopoverState.Shown;
        clearTimeout(this.timer);
      }
    } else {
      if (this.state === import_obsidian2.PopoverState.Showing) {
        this.hide();
      } else {
        if (this.state === import_obsidian2.PopoverState.Shown) {
          this.state = import_obsidian2.PopoverState.Hiding;
          this.timer = window.setTimeout(() => {
            if (this.shouldShow()) {
              this.transition();
            } else {
              this.hide();
            }
          }, this.waitTime);
        }
      }
    }
  }
  shouldShow() {
    return this.shouldShowSelf() || this.shouldShowChild();
  }
  shouldShowChild() {
    return FlowEditor.activePopovers().some((popover) => {
      if (popover !== this && popover.targetEl && this.hoverEl.contains(popover.targetEl)) {
        return popover.shouldShow();
      }
      return false;
    });
  }
  shouldShowSelf() {
    return !this.detaching && !!(this.onTarget || this.state == import_obsidian2.PopoverState.Shown || this.document.querySelector(`body>.modal-container, body > #he${this.id} ~ .menu, body > #he${this.id} ~ .suggestion-container`));
  }
  show() {
    if (!this.targetEl || this.document.body.contains(this.targetEl)) {
      this.state = import_obsidian2.PopoverState.Shown;
      this.timer = 0;
      this.shownPos = mouseCoords;
      this.targetEl.replaceChildren(this.hoverEl);
      this.onShow();
      app.workspace.onLayoutChange();
      this.load();
    } else {
      this.hide();
    }
  }
  onHide() {
    var _a2;
    this.oldPopover = null;
    if (((_a2 = this.parent) == null ? void 0 : _a2.flowEditor) === this) {
      this.parent.flowEditor = null;
    }
  }
  hide() {
    var _a2;
    this.onTarget = false;
    this.detaching = true;
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = 0;
    }
    this.hoverEl.hide();
    if (this.opening)
      return;
    const leaves = this.leaves();
    if (leaves.length) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      this.parent = null;
      (_a2 = this.abortController) == null ? void 0 : _a2.unload();
      this.abortController = void 0;
      return this.nativeHide();
    }
  }
  nativeHide() {
    var _a2;
    const { hoverEl, targetEl } = this;
    this.state = import_obsidian2.PopoverState.Hidden;
    hoverEl.detach();
    if (targetEl) {
      const parent = targetEl.matchParent(".mk-hover-popover");
      if (parent)
        (_a2 = popovers.get(parent)) == null ? void 0 : _a2.transition();
    }
    this.onHide();
    this.unload();
  }
  resolveLink(linkText, sourcePath) {
    const link = (0, import_obsidian2.parseLinktext)(linkText);
    const tFile = link ? this.plugin.app.metadataCache.getFirstLinkpathDest(link.path, sourcePath) : null;
    return tFile;
  }
  async openFile(file, openState, useLeaf) {
    if (this.detaching)
      return;
    const leaf = useLeaf != null ? useLeaf : this.attachLeaf();
    this.opening = true;
    try {
      await leaf.openFile(file, openState);
    } catch (e3) {
      console.error(e3);
    } finally {
      this.opening = false;
      if (this.detaching)
        this.hide();
    }
    this.plugin.app.workspace.setActiveLeaf(leaf);
    return leaf;
  }
  buildState(parentMode, eState) {
    return {
      active: false,
      state: {},
      eState
    };
  }
  buildEphemeralState(file, link) {
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    const subpath = cache ? (0, import_obsidian2.resolveSubpath)(cache, (link == null ? void 0 : link.subpath) || "") : void 0;
    const eState = { subpath: link == null ? void 0 : link.subpath };
    if (subpath) {
      eState.line = subpath.start.line;
      eState.startLoc = subpath.start;
      eState.endLoc = subpath.end || void 0;
    }
    return eState;
  }
};

// src/cm-extensions/markSans/callout.tsx
var portalTypeAnnotation = import_state.Annotation.define();
var flowIDAnnotation = import_state.Annotation.define();
var flowIDStateField = import_state.StateField.define({
  create: () => void 0,
  update(value, tr) {
    if (tr.annotation(flowIDAnnotation))
      return tr.annotation(flowIDAnnotation);
    return value;
  }
});
var flowTypeStateField = import_state.StateField.define({
  create: () => "none",
  update(value, tr) {
    if (tr.annotation(portalTypeAnnotation))
      return tr.annotation(portalTypeAnnotation);
    return value;
  }
});
var calloutField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(value, tr) {
    if (tr.state.field(flowTypeStateField) != "doc") {
      return value;
    }
    let builder = new import_state.RangeSetBuilder();
    let nodes2 = [];
    (0, import_language.syntaxTree)(tr.state).iterate({
      enter: ({ name, from, to }) => {
        nodes2.push({ name, from, to });
      }
    });
    const nextQuote = (ns, to) => {
      const nq = ns.find((f4) => f4.from == to + 1 && f4.name.contains("HyperMD-quote"));
      if (nq) {
        return nextQuote(ns, nq.to);
      }
      return to;
    };
    const previous = value.iter();
    const previousSpecs = [];
    while (previous.value !== null) {
      previousSpecs.push(previous.value.spec.widget.info);
      previous.next();
    }
    let index = 0;
    nodes2.map(({ name, from, to }) => {
      if (name.contains("HyperMD-callout")) {
        const existingCallout = previousSpecs[index];
        const endQuote = nextQuote(nodes2, to);
        const lineStart = tr.state.doc.lineAt(from).number;
        const lineEnd = tr.state.doc.lineAt(endQuote).number;
        if (existingCallout) {
          builder.add(from, endQuote + 1, calloutBlock({ from: lineStart, to: lineEnd }, tr.state.sliceDoc(from, endQuote), existingCallout.id));
        } else {
          builder.add(from, endQuote + 1, calloutBlock({ from: lineStart, to: lineEnd }, tr.state.sliceDoc(from, endQuote), genId(8)));
        }
        index++;
      }
    });
    const dec = builder.finish();
    return dec;
  },
  provide: (f4) => import_view.EditorView.decorations.from(f4)
});
var CalloutWidget = class extends import_view.WidgetType {
  constructor(info) {
    super();
    this.info = info;
  }
  eq(other) {
    return other.info.id === this.info.id;
  }
  toDOM() {
    const parseTextToCallout = (text) => {
      if (!this.info.text) {
        return { icon: "", title: "" };
      }
      const stringArray = text.split("\n");
      const titleRegex = RegExp(/.*\[!(\w*)\]\s(.*)/);
      const title = titleRegex.exec(stringArray[0]);
      if (!title || title.length < 3) {
        return { icon: "", title: "" };
      }
      return {
        icon: title[1],
        title: title[2]
      };
    };
    const callOutData = parseTextToCallout(this.info.text);
    const div = document.createElement("div");
    div.toggleClass("callout", true);
    const divTitle = div.createDiv("div");
    divTitle.toggleClass("callout-title", true);
    const div2 = div.createDiv("div");
    div2.toggleClass("callout-content", true);
    div2.setAttribute("id", "mk-callout-" + this.info.id);
    return div;
  }
};
var calloutBlock = (range, text, id) => import_view.Decoration.widget({
  widget: new CalloutWidget({ range, text, id }),
  block: true
});

// src/cm-extensions/flowEditor/flowEditor.tsx
var import_view3 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");

// src/utils/codemirror.ts
var import_language2 = require("@codemirror/language");
var getActiveCM = () => {
  let rcm;
  app.workspace.iterateLeaves((leaf) => {
    var _a2;
    const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
    if (cm.hasFocus) {
      rcm = cm;
      return true;
    }
  }, app.workspace["rootSplit"]);
  return rcm;
};
var getActiveMarkdownView = () => {
  let rv;
  app.workspace.iterateLeaves((leaf) => {
    var _a2;
    const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
    if (cm.hasFocus) {
      rv = leaf.view;
      return true;
    }
  }, app.workspace["rootSplit"]);
  return rv;
};
function iterateTreeAtPos(pos, state, iterateFns) {
  (0, import_language2.syntaxTree)(state).iterate({ ...iterateFns, from: pos, to: pos });
}
function iterateTreeInSelection(selection, state, iterateFns) {
  (0, import_language2.syntaxTree)(state).iterate({ ...iterateFns, from: selection.from, to: selection.to });
}
function iterateTreeInDocument(state, iterateFns) {
  (0, import_language2.syntaxTree)(state).iterate({ ...iterateFns });
}

// src/cm-extensions/tooltip.ts
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var ios = typeof navigator != "undefined" && !/Edge\/(\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t3) => t3);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }
  update(update) {
    let input = update.state.facet(this.facet);
    let tooltips3 = input.filter((x4) => x4);
    if (input === this.input) {
      for (let t3 of this.tooltipViews)
        if (t3.update)
          t3.update(update);
      return false;
    }
    let tooltipViews = [];
    for (let i3 = 0; i3 < tooltips3.length; i3++) {
      let tip = tooltips3[i3], known = -1;
      if (!tip)
        continue;
      for (let i4 = 0; i4 < this.tooltips.length; i4++) {
        let other = this.tooltips[i4];
        if (other && other.create == tip.create)
          known = i4;
      }
      if (known < 0) {
        tooltipViews[i3] = this.createTooltipView(tip);
      } else {
        let tooltipView = tooltipViews[i3] = this.tooltipViews[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t3 of this.tooltipViews)
      if (tooltipViews.indexOf(t3) < 0)
        t3.dom.remove();
    this.input = input;
    this.tooltips = tooltips3;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function tooltips(config = {}) {
  return tooltipConfig.of(config);
}
function windowSpace() {
  return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
}
var tooltipConfig = import_state2.Facet.define({
  combine: (values) => {
    var _a2, _b2, _c2;
    return {
      position: ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) == null ? void 0 : _a2.position) || "fixed",
      parent: ((_b2 = values.find((conf) => conf.parent)) == null ? void 0 : _b2.parent) || null,
      tooltipSpace: ((_c2 = values.find((conf) => conf.tooltipSpace)) == null ? void 0 : _c2.tooltipSpace) || windowSpace
    };
  }
});
var tooltipPlugin = import_view2.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.inView = true;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    var _a2;
    let config = view.state.facet(tooltipConfig);
    this.position = config.position;
    this.parent = config.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.manager = new TooltipViewManager(view, showTooltip, (t3) => this.createTooltip(t3));
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    (_a2 = view.dom.ownerDocument.defaultView) == null ? void 0 : _a2.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position) {
      this.position = newConfig.position;
      for (let t3 of this.manager.tooltipViews)
        t3.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t3 of this.manager.tooltipViews)
        this.container.appendChild(t3.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow2 = document.createElement("div");
      arrow2.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow2);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    this.container.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    var _a2, _b2;
    (_a2 = this.view.dom.ownerDocument.defaultView) == null ? void 0 : _a2.removeEventListener("resize", this.measureSoon);
    for (let { dom } of this.manager.tooltipViews)
      dom.remove();
    (_b2 = this.intersectionObserver) == null ? void 0 : _b2.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t3, i3) => {
        let tv = this.manager.tooltipViews[i3];
        return tv.getCoords ? tv.getCoords(t3.pos) : this.view.coordsAtPos(t3.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
    };
  }
  writeMeasure(measured) {
    let { editor, space } = measured;
    let others = [];
    for (let i3 = 0; i3 < this.manager.tooltips.length; i3++) {
      let tooltip = this.manager.tooltips[i3], tView = this.manager.tooltipViews[i3], { dom } = tView;
      let pos = measured.pos[i3], size2 = measured.size[i3];
      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow2 = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow2 ? 7 /* Size */ : 0;
      let width = size2.right - size2.left, height = size2.bottom - size2.top;
      let offset2 = tView.offset || noOffset, ltr = this.view.textDirection == import_view2.Direction.LTR;
      let left2 = size2.width > space.right - space.left ? ltr ? space.left : space.right - size2.width : ltr ? Math.min(pos.left - (arrow2 ? 14 /* Offset */ : 0) + offset2.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow2 ? 14 /* Offset */ : 0) - offset2.x);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size2.bottom - size2.top) - offset2.y < space.top : pos.bottom + (size2.bottom - size2.top) + offset2.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
        above = !above;
      let top2 = above ? pos.top - height - arrowHeight - offset2.y : pos.bottom + arrowHeight + offset2.y;
      let right2 = left2 + width;
      if (tView.overlap !== true) {
        for (let r3 of others)
          if (r3.left < right2 && r3.right > left2 && r3.top < top2 + height && r3.bottom > top2)
            top2 = above ? r3.top - height - 2 - arrowHeight : r3.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = top2 - measured.parent.top + "px";
        dom.style.left = left2 - measured.parent.left + "px";
      } else {
        dom.style.top = top2 + "px";
        dom.style.left = left2 + "px";
      }
      if (arrow2)
        arrow2.style.left = `${pos.left + (ltr ? offset2.x : -offset2.x) - (left2 + 14 /* Offset */ - 7 /* Size */)}px`;
      if (tView.overlap !== true)
        others.push({ left: left2, top: top2, right: right2, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned();
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var baseTheme = import_view2.EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7 /* Size */}px`,
    width: `${7 /* Size */ * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7 /* Size */}px solid transparent`,
      borderRight: `${7 /* Size */}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7 /* Size */}px`,
      "&:before": {
        borderTop: `${7 /* Size */}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7 /* Size */}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7 /* Size */}px`,
      "&:before": {
        borderBottom: `${7 /* Size */}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7 /* Size */}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = import_state2.Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = import_state2.Facet.define();
var HoverTooltipHost = class {
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t3) => this.createHostedView(t3));
  }
  static create(view) {
    return new HoverTooltipHost(view);
  }
  createHostedView(tooltip) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.appendChild(hostedView.dom);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned() {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned();
    }
  }
  update(update) {
    this.manager.update(update);
  }
};
var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips3 = state.facet(showHoverTooltip).filter((t3) => t3);
  if (tooltips3.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips3.map((t3) => t3.pos)),
    end: Math.max(...tooltips3.filter((t3) => t3.end != null).map((t3) => t3.end)),
    create: HoverTooltipHost.create,
    above: tooltips3[0].above,
    arrow: tooltips3.some((t3) => t3.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove } = this;
    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
    if (pos == null)
      return;
    let posCoords = this.view.coordsAtPos(pos);
    if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
      return;
    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s3) => s3.from <= pos && s3.to >= pos);
    let rtl = bidi && bidi.dir == import_view2.Direction.RTL ? -1 : 1;
    let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
    if (open == null ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result)
            this.view.dispatch({ effects: this.setHover.of(result) });
        }
      }, (e3) => (0, import_view2.logException)(this.view.state, e3, "hover tooltip"));
    } else if (open) {
      this.view.dispatch({ effects: this.setHover.of(open) });
    }
  }
  mousemove(event) {
    var _a2;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let tooltip = this.active;
    if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
      let { pos } = tooltip || this.pending, end2 = (_a2 = tooltip == null ? void 0 : tooltip.end) != null ? _a2 : pos;
      if (pos == end2 ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end2, event.clientX, event.clientY, 6 /* MaxDist */)) {
        this.view.dispatch({ effects: this.setHover.of(null) });
        this.pending = null;
      }
    }
  }
  mouseleave(e3) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    if (this.active && !isInTooltip(e3.relatedTarget))
      this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
function isInTooltip(elt) {
  for (let cur = elt; cur; cur = cur.parentNode)
    if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
      return true;
  return false;
}
function isOverRange(view, from, to, x4, y3, margin) {
  let range = document.createRange();
  let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
  range.setEnd(toDOM.node, toDOM.offset);
  range.setStart(fromDOM.node, fromDOM.offset);
  let rects = range.getClientRects();
  range.detach();
  for (let i3 = 0; i3 < rects.length; i3++) {
    let rect = rects[i3];
    let dist = Math.max(rect.top - y3, y3 - rect.bottom, rect.left - x4, x4 - rect.right);
    if (dist <= margin)
      return true;
  }
  return false;
}
function hoverTooltip(source, options = {}) {
  let setHover = import_state2.StateEffect.define();
  let hoverState = import_state2.StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))
        return null;
      for (let effect4 of tr.effects) {
        if (effect4.is(setHover)) {
          return effect4.value;
        }
        if (effect4.is(closeHoverTooltipEffect))
          return null;
      }
      if (value && tr.docChanged) {
        let newPos = tr.changes.mapPos(value.pos, -1, import_state2.MapMode.TrackDel);
        if (newPos == null)
          return null;
        let copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
        copy.pos = newPos;
        if (value.end != null)
          copy.end = tr.changes.mapPos(value.end);
        return copy;
      }
      return value;
    },
    provide: (f4) => showHoverTooltip.from(f4)
  });
  return [
    hoverState,
    import_view2.ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Time */)),
    showHoverTooltipHost
  ];
}
var closeHoverTooltipEffect = import_state2.StateEffect.define();
var closeHoverTooltips = closeHoverTooltipEffect.of(null);

// src/dispatch/flowDispatch.ts
var createFlowEditorInElement = (id, el, type, file, from, to) => {
  let evt = new CustomEvent(eventTypes.spawnPortal, { detail: { id, el, file, from, to, type } });
  window.dispatchEvent(evt);
};
var focusFlowEditor = (id, top2) => {
  let evt = new CustomEvent(eventTypes.focusPortal, { detail: { id, parent: false, top: top2 } });
  window.dispatchEvent(evt);
};
var focusFlowEditorParent = (id, top2) => {
  let evt = new CustomEvent(eventTypes.focusPortal, { detail: { id, parent: true, top: top2 } });
  window.dispatchEvent(evt);
};
var openFileFlowEditor = (file, source) => {
  let evt = new CustomEvent(eventTypes.openFilePortal, { detail: { file, source } });
  window.dispatchEvent(evt);
};

// src/utils/icons.ts
var uiIconSet = {
  "mk-ui-close": `<svg xmlns="http://www.w3.org/2000/svg" width='24px' height='24px' fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>`,
  "mk-ui-flow-hover": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M10.7941 11.6917C11.4281 11.809 12.0857 11.7486 12.6856 11.5163C13.2858 11.2838 13.8068 10.8873 14.1773 10.3692C14.5483 9.85038 14.75 9.23465 14.75 8.6C14.75 7.96535 14.5483 7.34962 14.1773 6.83081C13.8068 6.31273 13.2858 5.91619 12.6856 5.68372C12.0857 5.45136 11.4281 5.39096 10.7941 5.50834C10.1599 5.62575 9.57072 5.91716 9.10335 6.35289C9.09233 6.36317 9.08162 6.37378 9.07124 6.3847L5.85862 9.76393C5.60897 9.99123 5.28818 10.1509 4.93287 10.2167C4.5702 10.2839 4.19486 10.2487 3.85619 10.1175C3.51778 9.98646 3.23669 9.76777 3.04283 9.49668C2.84949 9.22631 2.75 8.91434 2.75 8.6C2.75 8.28566 2.84949 7.97369 3.04283 7.70332C3.23669 7.43223 3.51778 7.21354 3.85619 7.08246C4.19486 6.95128 4.5702 6.91614 4.93287 6.98328C5.29024 7.04944 5.61268 7.21063 5.86295 7.44003L6.559 8.14747L7.62823 7.09545L6.91982 6.37545C6.91226 6.36777 6.90453 6.36025 6.89665 6.35289C6.42928 5.91716 5.8401 5.62575 5.20593 5.50834C4.57189 5.39096 3.91432 5.45136 3.31441 5.68372C2.71423 5.91619 2.19318 6.31273 1.8227 6.83081C1.4517 7.34962 1.25 7.96535 1.25 8.6C1.25 9.23465 1.4517 9.85038 1.8227 10.3692C2.19318 10.8873 2.71423 11.2838 3.31441 11.5163C3.91432 11.7486 4.57189 11.809 5.20593 11.6917C5.8401 11.5742 6.42928 11.2828 6.89665 10.8471C6.90767 10.8368 6.91838 10.8262 6.92876 10.8153L10.1414 7.43607C10.391 7.20877 10.7118 7.04906 11.0671 6.98328C11.4298 6.91614 11.8051 6.95128 12.1438 7.08246C12.4822 7.21354 12.7633 7.43223 12.9572 7.70332C13.1505 7.97369 13.25 8.28566 13.25 8.6C13.25 8.91434 13.1505 9.22631 12.9572 9.49668C12.7633 9.76777 12.4822 9.98646 12.1438 10.1175C11.8051 10.2487 11.4298 10.2839 11.0671 10.2167C10.7098 10.1506 10.3873 9.98938 10.1371 9.75998L9.441 9.05253L8.37177 10.1045L9.08018 10.8245C9.08774 10.8322 9.09547 10.8398 9.10335 10.8471C9.57072 11.2828 10.1599 11.5742 10.7941 11.6917Z" fill="currentColor"/>
    </svg>`,
  "mk-ui-folder": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
  </svg>`,
  "mk-ui-open-link": `<svg width="16" height="16"  xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244" />
  </svg>`,
  "mk-ui-file": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
</svg>`,
  "mk-ui-expand": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
<path stroke-linecap="round" stroke-linejoin="round" d="M8.25 15L12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9" />
</svg>`,
  "mk-ui-new-folder": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path><line x1="12" y1="10" x2="12" y2="16"></line><line x1="9" y1="13" x2="15" y2="13"></line></svg>`,
  "mk-ui-new-note": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`,
  "mk-ui-collapse": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
<path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
</svg>`,
  "mk-ui-options": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
<path stroke-linecap="round" stroke-linejoin="round" d="M6.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM12.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM18.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0z" />
</svg>`,
  "mk-ui-plus": `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
<path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
</svg>`,
  "mk-ui-collapse-sm": `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5">
<path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
</svg>`
};
var makeIconSet = {
  "mk-make-todo": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="1.5" y="1.5" width="13" height="13" rx="1.5" stroke="currentColor"/>
  <path d="M4.5 8L7 10.5L11.5 6" stroke="currentColor"/>
  </svg>        
  `,
  "mk-make-list": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <line x1="5.5" y1="4.5" x2="14.5" y2="4.5" stroke="currentColor" stroke-linecap="round"/>
  <line x1="5.5" y1="8.5" x2="14.5" y2="8.5" stroke="currentColor" stroke-linecap="round"/>
  <line x1="5.5" y1="12.5" x2="14.5" y2="12.5" stroke="currentColor" stroke-linecap="round"/>
  <circle cx="1.75" cy="4.5" r="0.75" fill="currentColor"/>
  <circle cx="1.75" cy="8.5" r="0.75" fill="currentColor"/>
  <circle cx="1.75" cy="12.5" r="0.75" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-ordered": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M1.50142 3.09091V6H0.886364V3.67472H0.869318L0.203125 4.09233V3.54688L0.923295 3.09091H1.50142Z" fill="currentColor"/>
  <path d="M0.235807 10V9.55682L1.27132 8.59801C1.35939 8.51278 1.43325 8.43608 1.49291 8.3679C1.55351 8.29972 1.59944 8.23295 1.63069 8.16761C1.66194 8.10133 1.67757 8.02983 1.67757 7.95312C1.67757 7.8679 1.65816 7.79451 1.61933 7.73295C1.5805 7.67045 1.52747 7.62263 1.46024 7.58949C1.393 7.5554 1.31677 7.53835 1.23155 7.53835C1.14253 7.53835 1.06488 7.55634 0.998591 7.59233C0.932303 7.62831 0.881166 7.67992 0.845182 7.74716C0.809197 7.81439 0.791204 7.89441 0.791204 7.98722H0.207397C0.207397 7.79687 0.250485 7.63163 0.336659 7.49148C0.422833 7.35133 0.543572 7.2429 0.698875 7.16619C0.854178 7.08949 1.03316 7.05114 1.23581 7.05114C1.44414 7.05114 1.62548 7.08807 1.77984 7.16193C1.93514 7.23485 2.05588 7.33617 2.14206 7.46591C2.22823 7.59564 2.27132 7.74432 2.27132 7.91193C2.27132 8.02178 2.24954 8.13021 2.20598 8.23722C2.16336 8.34422 2.08713 8.46307 1.97728 8.59375C1.86744 8.72348 1.71261 8.87926 1.5128 9.06108L1.08808 9.47727V9.49716H2.30967V10H0.235807Z" fill="currentColor"/>
  <path d="M1.31109 14.0398C1.09897 14.0398 0.910049 14.0033 0.744329 13.9304C0.579557 13.8565 0.449348 13.7552 0.353704 13.6264C0.259007 13.4967 0.210238 13.3471 0.207397 13.1776H0.826716C0.830504 13.2486 0.853704 13.3111 0.896318 13.3651C0.939879 13.4181 0.997644 13.4593 1.06961 13.4886C1.14158 13.518 1.22255 13.5327 1.31251 13.5327C1.40626 13.5327 1.48912 13.5161 1.56109 13.483C1.63306 13.4498 1.68941 13.4039 1.73012 13.3452C1.77084 13.2865 1.7912 13.2187 1.7912 13.142C1.7912 13.0644 1.76942 12.9957 1.72586 12.9361C1.68325 12.8755 1.6217 12.8281 1.5412 12.794C1.46166 12.7599 1.36696 12.7429 1.25711 12.7429H0.985807V12.2912H1.25711C1.34992 12.2912 1.43183 12.2751 1.50285 12.2429C1.57482 12.2107 1.63069 12.1662 1.67047 12.1094C1.71024 12.0516 1.73012 11.9844 1.73012 11.9077C1.73012 11.8348 1.71261 11.7708 1.67757 11.7159C1.64348 11.66 1.59518 11.6165 1.53268 11.5852C1.47113 11.554 1.39916 11.5384 1.31677 11.5384C1.23344 11.5384 1.15721 11.5535 1.08808 11.5838C1.01895 11.6132 0.963553 11.6553 0.921886 11.7102C0.880219 11.7652 0.857966 11.8295 0.855125 11.9034H0.265636C0.268477 11.7358 0.316299 11.5881 0.409102 11.4602C0.501905 11.3324 0.626905 11.2325 0.784102 11.1605C0.942246 11.0876 1.12075 11.0511 1.31961 11.0511C1.52037 11.0511 1.69603 11.0876 1.8466 11.1605C1.99717 11.2334 2.11412 11.3319 2.19745 11.456C2.28173 11.5791 2.3234 11.7173 2.32245 11.8707C2.3234 12.0336 2.27274 12.1695 2.17047 12.2784C2.06914 12.3873 1.93704 12.4564 1.77416 12.4858V12.5085C1.98817 12.536 2.15105 12.6103 2.2628 12.7315C2.37548 12.8518 2.43136 13.0024 2.43041 13.1832C2.43136 13.349 2.38353 13.4962 2.28694 13.625C2.1913 13.7538 2.0592 13.8551 1.89064 13.929C1.72208 14.0028 1.52889 14.0398 1.31109 14.0398Z" fill="currentColor"/>
  <line x1="5.5" y1="4.5" x2="14.5" y2="4.5" stroke="currentColor" stroke-linecap="round"/>
  <line x1="5.5" y1="8.5" x2="14.5" y2="8.5" stroke="currentColor" stroke-linecap="round"/>
  <line x1="5.5" y1="12.5" x2="14.5" y2="12.5" stroke="currentColor" stroke-linecap="round"/>
  </svg>        
  `,
  "mk-make-h1": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M2.26278 12H0.285507L3.29829 3.27273H5.67613L8.68466 12H6.70738L4.5213 5.26705H4.45312L2.26278 12ZM2.1392 8.5696H6.80966V10.0099H2.1392V8.5696Z" fill="currentColor"/>
  <path d="M11.5675 12.1236C11.1499 12.1236 10.7777 12.0511 10.451 11.9062C10.1243 11.7585 9.86576 11.5412 9.67542 11.2543C9.48792 10.9645 9.39417 10.6037 9.39417 10.1719C9.39417 9.80824 9.46093 9.50284 9.59446 9.25568C9.72798 9.00852 9.9098 8.80966 10.1399 8.65909C10.37 8.50852 10.6314 8.39489 10.924 8.31818C11.2195 8.24148 11.5291 8.1875 11.853 8.15625C12.2337 8.11648 12.5405 8.07955 12.7734 8.04545C13.0064 8.00852 13.1754 7.95455 13.2805 7.88352C13.3856 7.8125 13.4382 7.70739 13.4382 7.56818V7.54261C13.4382 7.27273 13.353 7.06392 13.1825 6.91619C13.0149 6.76847 12.7763 6.6946 12.4666 6.6946C12.1399 6.6946 11.88 6.76705 11.6868 6.91193C11.4936 7.05398 11.3658 7.23295 11.3033 7.44886L9.62429 7.3125C9.70951 6.91477 9.87713 6.57102 10.1271 6.28125C10.3771 5.98864 10.6996 5.7642 11.0945 5.60795C11.4922 5.44886 11.9524 5.36932 12.4751 5.36932C12.8388 5.36932 13.1868 5.41193 13.5192 5.49716C13.8544 5.58239 14.1513 5.71449 14.4098 5.89347C14.6712 6.07244 14.8771 6.30256 15.0277 6.58381C15.1783 6.86222 15.2535 7.19602 15.2535 7.58523V12H13.532V11.0923H13.4808C13.3757 11.2969 13.2351 11.4773 13.0589 11.6335C12.8828 11.7869 12.6712 11.9077 12.424 11.9957C12.1768 12.081 11.8913 12.1236 11.5675 12.1236ZM12.0874 10.8707C12.3544 10.8707 12.5902 10.8182 12.7947 10.7131C12.9993 10.6051 13.1598 10.4602 13.2763 10.2784C13.3928 10.0966 13.451 9.89062 13.451 9.66051V8.96591C13.3942 9.00284 13.316 9.03693 13.2166 9.06818C13.12 9.09659 13.0106 9.12358 12.8885 9.14915C12.7663 9.17188 12.6442 9.19318 12.522 9.21307C12.3999 9.23011 12.2891 9.24574 12.1896 9.25994C11.9766 9.29119 11.7905 9.34091 11.6314 9.40909C11.4723 9.47727 11.3487 9.5696 11.2606 9.68608C11.1726 9.79972 11.1285 9.94176 11.1285 10.1122C11.1285 10.3594 11.218 10.5483 11.397 10.679C11.5788 10.8068 11.8089 10.8707 12.0874 10.8707Z" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-h2": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M2.88566 12H1.23793L3.74858 4.72727H5.73012L8.23722 12H6.58949L4.76776 6.3892H4.71094L2.88566 12ZM2.78267 9.14133H6.67472V10.3416H2.78267V9.14133Z" fill="currentColor"/>
  <path d="M10.6396 12.103C10.2916 12.103 9.98142 12.0426 9.70917 11.9219C9.43691 11.7988 9.22148 11.6177 9.06286 11.3786C8.90661 11.1371 8.82848 10.8364 8.82848 10.4766C8.82848 10.1735 8.88412 9.91903 8.99539 9.71307C9.10666 9.5071 9.25817 9.34138 9.44993 9.21591C9.64169 9.09043 9.8595 8.99574 10.1033 8.93182C10.3496 8.8679 10.6076 8.82292 10.8775 8.79687C11.1947 8.76373 11.4504 8.73295 11.6445 8.70455C11.8387 8.67377 11.9795 8.62879 12.0671 8.5696C12.1547 8.51042 12.1985 8.42282 12.1985 8.30682V8.28551C12.1985 8.06061 12.1275 7.8866 11.9854 7.76349C11.8458 7.64039 11.6469 7.57883 11.3889 7.57883C11.1166 7.57883 10.9 7.6392 10.739 7.75994C10.578 7.87831 10.4715 8.02746 10.4194 8.20739L9.02025 8.09375C9.09127 7.76231 9.23095 7.47585 9.43928 7.23437C9.64761 6.99053 9.91632 6.8035 10.2454 6.67329C10.5768 6.54072 10.9603 6.47443 11.396 6.47443C11.699 6.47443 11.989 6.50994 12.266 6.58097C12.5453 6.65199 12.7927 6.76207 13.0082 6.91122C13.226 7.06037 13.3976 7.25213 13.5231 7.48651C13.6486 7.71851 13.7113 7.99668 13.7113 8.32102V12H12.2766V11.2436H12.234C12.1464 11.4141 12.0292 11.5644 11.8825 11.6946C11.7357 11.8224 11.5593 11.9231 11.3533 11.9964C11.1474 12.0675 10.9095 12.103 10.6396 12.103ZM11.0728 11.0589C11.2953 11.0589 11.4918 11.0152 11.6623 10.9276C11.8327 10.8376 11.9665 10.7169 12.0636 10.5653C12.1606 10.4138 12.2092 10.2422 12.2092 10.0504V9.47159C12.1618 9.50237 12.0967 9.53078 12.0139 9.55682C11.9334 9.58049 11.8422 9.60298 11.7404 9.62429C11.6386 9.64323 11.5368 9.66098 11.435 9.67756C11.3332 9.69176 11.2409 9.70478 11.158 9.71662C10.9805 9.74266 10.8254 9.78409 10.6928 9.84091C10.5603 9.89773 10.4573 9.97467 10.3839 10.0717C10.3105 10.1664 10.2738 10.2848 10.2738 10.4268C10.2738 10.6328 10.3484 10.7902 10.4975 10.8991C10.649 11.0057 10.8408 11.0589 11.0728 11.0589Z" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-h3": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3.17897 12H2.25568L4.92613 4.72727H5.83522L8.50568 12H7.58238L5.40909 5.87784H5.35227L3.17897 12ZM3.51988 9.15909H7.24147V9.94034H3.51988V9.15909Z" fill="currentColor"/>
  <path d="M11.13 12.1278C10.7843 12.1278 10.4706 12.0627 10.1889 11.9325C9.90719 11.8 9.68347 11.6094 9.51775 11.3608C9.35203 11.1098 9.26917 10.8068 9.26917 10.4517C9.26917 10.1392 9.33072 9.88589 9.45383 9.69176C9.57694 9.49526 9.74147 9.34138 9.94744 9.23011C10.1534 9.11884 10.3807 9.03598 10.6293 8.98153C10.8802 8.92472 11.1323 8.87973 11.3856 8.84659C11.7171 8.80398 11.9858 8.77202 12.1918 8.75071C12.4001 8.72704 12.5516 8.68797 12.6463 8.63352C12.7434 8.57907 12.7919 8.48437 12.7919 8.34943V8.32102C12.7919 7.97064 12.696 7.69839 12.5043 7.50426C12.3149 7.31013 12.0272 7.21307 11.6413 7.21307C11.2412 7.21307 10.9276 7.30066 10.7003 7.47585C10.473 7.65104 10.3132 7.83807 10.2209 8.03693L9.42542 7.75284C9.56747 7.4214 9.75686 7.16335 9.9936 6.97869C10.2327 6.79167 10.4931 6.66146 10.7749 6.58807C11.0589 6.51231 11.3383 6.47443 11.6129 6.47443C11.7881 6.47443 11.9893 6.49574 12.2166 6.53835C12.4463 6.5786 12.6676 6.66264 12.8807 6.79048C13.0961 6.91832 13.2749 7.11127 13.4169 7.36932C13.5589 7.62737 13.63 7.97301 13.63 8.40625V12H12.7919V11.2614H12.7493C12.6925 11.3797 12.5978 11.5064 12.4652 11.6413C12.3326 11.7763 12.1562 11.8911 11.9361 11.9858C11.7159 12.0805 11.4472 12.1278 11.13 12.1278ZM11.2578 11.375C11.5892 11.375 11.8686 11.3099 12.0959 11.1797C12.3255 11.0495 12.4983 10.8814 12.6143 10.6754C12.7327 10.4695 12.7919 10.2528 12.7919 10.0256V9.25852C12.7564 9.30114 12.6783 9.3402 12.5575 9.37571C12.4392 9.40885 12.3018 9.43845 12.1456 9.46449C11.9917 9.48816 11.8414 9.50947 11.6946 9.52841C11.5502 9.54498 11.433 9.55918 11.343 9.57102C11.1252 9.59943 10.9216 9.6456 10.7322 9.70952C10.5452 9.77107 10.3937 9.86458 10.2777 9.99006C10.1641 10.1132 10.1072 10.2812 10.1072 10.4943C10.1072 10.7855 10.215 11.0057 10.4304 11.1548C10.6482 11.3016 10.924 11.375 11.2578 11.375Z" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-quote": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <line x1="1.75" y1="2.75" x2="1.75" y2="12.25" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  <line opacity="0.3" x1="5.5" y1="4.5" x2="13.5" y2="4.5" stroke="currentColor" stroke-linecap="round"/>
  <line opacity="0.3" x1="5.5" y1="7.5" x2="11.5" y2="7.5" stroke="currentColor" stroke-linecap="round"/>
  <line opacity="0.3" x1="5.5" y1="10.5" x2="9.5" y2="10.5" stroke="currentColor" stroke-linecap="round"/>
  </svg>        
  `,
  "mk-make-hr": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <line x1="0.75" y1="8.25" x2="15.25" y2="8.25" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
  </svg>
  `,
  "mk-make-link": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M9.25144 6.74857C8.75136 6.24864 8.07321 5.9678 7.3661 5.9678C6.659 5.9678 5.98084 6.24864 5.48077 6.74857L2.8141 9.41523C2.55941 9.66122 2.35626 9.95548 2.2165 10.2808C2.07674 10.6062 2.00318 10.9561 2.0001 11.3102C1.99702 11.6642 2.06449 12.0154 2.19858 12.3431C2.33266 12.6708 2.53067 12.9686 2.78105 13.219C3.03143 13.4693 3.32917 13.6673 3.65689 13.8014C3.98461 13.9355 4.33576 14.003 4.68984 13.9999C5.04392 13.9968 5.39384 13.9233 5.71918 13.7835C6.04452 13.6437 6.33878 13.4406 6.58477 13.1859L7.31944 12.4519M6.8141 9.1859C7.31418 9.68582 7.99233 9.96666 8.69944 9.96666C9.40654 9.96666 10.0847 9.68582 10.5848 9.1859L13.2514 6.51923C13.7372 6.01629 14.006 5.34269 13.9999 4.6435C13.9938 3.9443 13.7134 3.27547 13.219 2.78105C12.7245 2.28663 12.0557 2.00618 11.3565 2.0001C10.6573 1.99403 9.98371 2.26281 9.48077 2.74856L8.74743 3.4819" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>        
  `,
  "mk-make-image": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="1.5" y="2.5" width="13" height="10" rx="1.5" stroke="currentColor"/>
  <path d="M4.2 9.06667C4.6 8.53333 5.4 8.53333 5.8 9.06667L8 12H2L4.2 9.06667Z" fill="currentColor"/>
  <path d="M9.16795 7.24808C9.56377 6.65434 10.4362 6.65434 10.8321 7.24808L14 12H6L9.16795 7.24808Z" fill="currentColor"/>
  <circle cx="4.5" cy="5.5" r="1.5" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-codeblock": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M1 9.01852V7.98148L5 5V6.41204L2.04819 8.48148L2.0753 8.39815V8.59722L2.04819 8.51852L5 10.5833V12L1 9.01852Z" fill="currentColor"/>
  <path d="M15 9.01852V7.98148L11 5V6.41204L13.9518 8.48148L13.9247 8.39815V8.59722L13.9518 8.51852L11 10.5833V12L15 9.01852Z" fill="currentColor"/>
  <path d="M10 3L7.1521 14H6L8.8479 3H10Z" fill="currentColor"/>
  </svg>        
  `,
  "mk-make-callout": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="3.5" y="6.5" width="9" height="3" stroke="currentColor"/>
  <line x1="4.5" y1="3.5" x2="11.5" y2="3.5" stroke="#B2B2B2" stroke-linecap="round"/>
  <line x1="4.5" y1="12.5" x2="11.5" y2="12.5" stroke="#B2B2B2" stroke-linecap="round"/>
  </svg>`,
  "mk-make-note": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7.5 11C6.11929 11 5 9.88071 5 8.5C5 7.11929 6.11929 6 7.5 6" stroke="currentColor" stroke-width="1.5"/>
  <path d="M9 6C10.3807 6 11.5 7.11929 11.5 8.5C11.5 9.88071 10.3807 11 9 11" stroke="currentColor" stroke-width="1.5"/>
  <line x1="1" y1="8.25" x2="5" y2="8.25" stroke="currentColor" stroke-width="1.5"/>
  <line x1="11" y1="8.25" x2="15" y2="8.25" stroke="currentColor" stroke-width="1.5"/>
  </svg>        
  `,
  "mk-make-flow": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.7941 11.6917C11.4281 11.809 12.0857 11.7486 12.6856 11.5163C13.2858 11.2838 13.8068 10.8873 14.1773 10.3692C14.5483 9.85038 14.75 9.23465 14.75 8.6C14.75 7.96535 14.5483 7.34962 14.1773 6.83081C13.8068 6.31273 13.2858 5.91619 12.6856 5.68372C12.0857 5.45136 11.4281 5.39096 10.7941 5.50834C10.1599 5.62575 9.57072 5.91716 9.10335 6.35289C9.09233 6.36317 9.08162 6.37378 9.07124 6.3847L5.85862 9.76393C5.60897 9.99123 5.28818 10.1509 4.93287 10.2167C4.5702 10.2839 4.19486 10.2487 3.85619 10.1175C3.51778 9.98646 3.23669 9.76777 3.04283 9.49668C2.84949 9.22631 2.75 8.91434 2.75 8.6C2.75 8.28566 2.84949 7.97369 3.04283 7.70332C3.23669 7.43223 3.51778 7.21354 3.85619 7.08246C4.19486 6.95128 4.5702 6.91614 4.93287 6.98328C5.29024 7.04944 5.61268 7.21063 5.86295 7.44003L6.559 8.14747L7.62823 7.09545L6.91982 6.37545C6.91226 6.36777 6.90453 6.36025 6.89665 6.35289C6.42928 5.91716 5.8401 5.62575 5.20593 5.50834C4.57189 5.39096 3.91432 5.45136 3.31441 5.68372C2.71423 5.91619 2.19318 6.31273 1.8227 6.83081C1.4517 7.34962 1.25 7.96535 1.25 8.6C1.25 9.23465 1.4517 9.85038 1.8227 10.3692C2.19318 10.8873 2.71423 11.2838 3.31441 11.5163C3.91432 11.7486 4.57189 11.809 5.20593 11.6917C5.8401 11.5742 6.42928 11.2828 6.89665 10.8471C6.90767 10.8368 6.91838 10.8262 6.92876 10.8153L10.1414 7.43607C10.391 7.20877 10.7118 7.04906 11.0671 6.98328C11.4298 6.91614 11.8051 6.95128 12.1438 7.08246C12.4822 7.21354 12.7633 7.43223 12.9572 7.70332C13.1505 7.97369 13.25 8.28566 13.25 8.6C13.25 8.91434 13.1505 9.22631 12.9572 9.49668C12.7633 9.76777 12.4822 9.98646 12.1438 10.1175C11.8051 10.2487 11.4298 10.2839 11.0671 10.2167C10.7098 10.1506 10.3873 9.98938 10.1371 9.75998L9.441 9.05253L8.37177 10.1045L9.08018 10.8245C9.08774 10.8322 9.09547 10.8398 9.10335 10.8471C9.57072 11.2828 10.1599 11.5742 10.7941 11.6917Z" fill="currentColor"/>
  </svg>
  `,
  "mk-make-tag": `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7.81747 13L9.48792 2.81818H10.6811L9.01065 13H7.81747ZM3.2088 10.2756L3.40269 9.08239H11.1186L10.9247 10.2756H3.2088ZM4.23792 13L5.90838 2.81818H7.10156L5.4311 13H4.23792ZM3.80042 6.7358L3.99431 5.54261H11.7102L11.5163 6.7358H3.80042Z" fill="currentColor"/>
  </svg>
  `
};
var mkLogo = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" fill="currentColor" viewBox="0 0 100 100">
<path d="m51.39 53.148 36.687-38.355v73.284H11.923V14.793L48.61 53.148 50 54.6l1.39-1.453Z"/>
</svg>
`;
var markIconSet = {
  "mk-mark-strong": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M7 17.6364V6H11.8523C12.7235 6 13.4527 6.12311 14.0398 6.36932C14.6307 6.61553 15.0739 6.96023 15.3693 7.40341C15.6686 7.84659 15.8182 8.35985 15.8182 8.94318C15.8182 9.38636 15.7254 9.7822 15.5398 10.1307C15.3542 10.4754 15.0985 10.7614 14.7727 10.9886C14.447 11.2159 14.0701 11.375 13.642 11.4659V11.5795C14.1117 11.6023 14.5455 11.7292 14.9432 11.9602C15.3447 12.1913 15.6667 12.5133 15.9091 12.9261C16.1515 13.3352 16.2727 13.8201 16.2727 14.3807C16.2727 15.0057 16.1136 15.5644 15.7955 16.0568C15.4773 16.5455 15.017 16.9318 14.4148 17.2159C13.8125 17.4962 13.0814 17.6364 12.2216 17.6364H7ZM9.8125 15.3693H11.5511C12.161 15.3693 12.6098 15.2538 12.8977 15.0227C13.1894 14.7917 13.3352 14.4697 13.3352 14.0568C13.3352 13.7576 13.2652 13.5 13.125 13.2841C12.9848 13.0644 12.786 12.8958 12.5284 12.7784C12.2708 12.6572 11.9621 12.5966 11.6023 12.5966H9.8125V15.3693ZM9.8125 10.7841H11.3693C11.6761 10.7841 11.9489 10.733 12.1875 10.6307C12.4261 10.5284 12.6117 10.3807 12.7443 10.1875C12.8807 9.99432 12.9489 9.76136 12.9489 9.48864C12.9489 9.09848 12.8106 8.79167 12.5341 8.56818C12.2576 8.3447 11.8845 8.23295 11.4148 8.23295H9.8125V10.7841Z" fill="currentColor"/>
    </svg>
    `,
  "mk-mark-em": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M9.76 15.888L11.424 7.52C11.4773 7.28533 11.392 7.13067 11.168 7.056C10.9547 6.98133 10.6667 6.944 10.304 6.944H10.08L10.288 6H15.184L14.976 6.944H14.752C14.4107 6.944 14.112 6.976 13.856 7.04C13.6107 7.104 13.4667 7.248 13.424 7.472L11.76 15.84C11.7173 16.0747 11.8027 16.2293 12.016 16.304C12.2293 16.3787 12.5173 16.416 12.88 16.416H13.104L12.896 17.36H8L8.208 16.416H8.432C8.77333 16.416 9.06667 16.384 9.312 16.32C9.568 16.2453 9.71733 16.1013 9.76 15.888Z" fill="currentColor"/>
    </svg>`,
  "mk-mark-strikethrough": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M14.625 9.21591C14.5644 8.67803 14.3144 8.26136 13.875 7.96591C13.4356 7.66667 12.8826 7.51705 12.2159 7.51705C11.7386 7.51705 11.3258 7.5928 10.9773 7.74432C10.6288 7.89205 10.358 8.09659 10.1648 8.35795C9.97538 8.61553 9.88068 8.90909 9.88068 9.23864C9.88068 9.51515 9.94508 9.75379 10.0739 9.95455C10.2064 10.1553 10.3788 10.3239 10.5909 10.4602C10.8068 10.5928 11.0379 10.7045 11.2841 10.7955C11.5303 10.8826 11.767 10.9545 11.9943 11.0114L13.1307 11.3068C13.5019 11.3977 13.8826 11.5208 14.2727 11.6761C14.6629 11.8314 15.0246 12.036 15.358 12.2898C15.6913 12.5436 15.9602 12.858 16.1648 13.233C16.3731 13.608 16.4773 14.0568 16.4773 14.5795C16.4773 15.2386 16.3068 15.8239 15.9659 16.3352C15.6288 16.8466 15.1383 17.25 14.4943 17.5455C13.8542 17.8409 13.0795 17.9886 12.1705 17.9886C11.2992 17.9886 10.5455 17.8504 9.90909 17.5739C9.27273 17.2973 8.77462 16.9053 8.41477 16.3977C8.05492 15.8864 7.85606 15.2803 7.81818 14.5795H9.57955C9.61364 15 9.75 15.3504 9.98864 15.6307C10.2311 15.9072 10.5398 16.1136 10.9148 16.25C11.2936 16.3826 11.7083 16.4489 12.1591 16.4489C12.6553 16.4489 13.0966 16.3712 13.483 16.2159C13.8731 16.0568 14.1799 15.8371 14.4034 15.5568C14.6269 15.2727 14.7386 14.9413 14.7386 14.5625C14.7386 14.2178 14.6402 13.9356 14.4432 13.7159C14.25 13.4962 13.9867 13.3144 13.6534 13.1705C13.3239 13.0265 12.9508 12.8996 12.5341 12.7898L11.1591 12.4148C10.2273 12.161 9.48864 11.7879 8.94318 11.2955C8.40152 10.803 8.13068 10.1515 8.13068 9.34091C8.13068 8.67045 8.3125 8.08523 8.67614 7.58523C9.03977 7.08523 9.5322 6.69697 10.1534 6.42045C10.7746 6.14015 11.4754 6 12.2557 6C13.0436 6 13.7386 6.13826 14.3409 6.41477C14.947 6.69129 15.4242 7.07197 15.7727 7.55682C16.1212 8.03788 16.303 8.59091 16.3182 9.21591H14.625Z" fill="currentColor"/>
    <path d="M7 12.5568H17.2955V13.6477H7V12.5568Z" fill="currentColor"/>
    </svg>
    `,
  "mk-mark-code": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3 13.1667V11.8333L8 8V9.81548L4.31024 12.4762L4.34413 12.369V12.625L4.31024 12.5238L8 15.1786V17L3 13.1667Z" fill="currentColor"/>
    <path d="M21 13.1667V11.8333L16 8V9.81548L19.6898 12.4762L19.6559 12.369V12.625L19.6898 12.5238L16 15.1786V17L21 13.1667Z" fill="currentColor"/>
    <path d="M14.5739 5.81818L10.8239 19.75H9.30682L13.0568 5.81818H14.5739Z" fill="currentColor"/>
    </svg>
    `,
  "mk-mark-link": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M13.2514 10.7486C12.7514 10.2486 12.0732 9.9678 11.3661 9.9678C10.659 9.9678 9.98084 10.2486 9.48077 10.7486L6.8141 13.4152C6.55941 13.6612 6.35626 13.9555 6.2165 14.2808C6.07674 14.6062 6.00318 14.9561 6.0001 15.3102C5.99702 15.6642 6.06449 16.0154 6.19858 16.3431C6.33266 16.6708 6.53067 16.9686 6.78105 17.219C7.03143 17.4693 7.32917 17.6673 7.65689 17.8014C7.98461 17.9355 8.33576 18.003 8.68984 17.9999C9.04392 17.9968 9.39384 17.9233 9.71918 17.7835C10.0445 17.6437 10.3388 17.4406 10.5848 17.1859L11.3194 16.4519M10.8141 13.1859C11.3142 13.6858 11.9923 13.9667 12.6994 13.9667C13.4065 13.9667 14.0847 13.6858 14.5848 13.1859L17.2514 10.5192C17.7372 10.0163 18.006 9.34269 17.9999 8.6435C17.9938 7.9443 17.7134 7.27547 17.219 6.78105C16.7245 6.28663 16.0557 6.00618 15.3565 6.0001C14.6573 5.99403 13.9837 6.26281 13.4808 6.74856L12.7474 7.4819" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`,
  "mk-mark-blocklink": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.5 15C10.1193 15 9 13.8807 9 12.5C9 11.1193 10.1193 10 11.5 10" stroke="currentColor" stroke-width="1.5"/>
    <path d="M13 10C14.3807 10 15.5 11.1193 15.5 12.5C15.5 13.8807 14.3807 15 13 15" stroke="currentColor" stroke-width="1.5"/>
    <line x1="4" y1="12.25" x2="9" y2="12.25" stroke="currentColor" stroke-width="1.5"/>
    <line x1="15" y1="12.25" x2="20" y2="12.25" stroke="currentColor" stroke-width="1.5"/>
    </svg>`,
  "mk-mark-highlight": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g opacity="0.2">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M18 21H6V19H18V20Z" fill="currentColor"/>
    </g>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M9.43302 10.7498L9.2698 13.9711L11.3368 15.3582L14.256 13.9863L9.43302 10.7498ZM13.7828 5.58248L9.43305 10.7498L14.256 13.9863L17.3893 8.00268C17.626 7.5506 17.4844 6.99279 17.0606 6.70843L15.1051 5.39611C14.6813 5.11175 14.1114 5.19208 13.7828 5.58248Z" fill="currentColor"/>
    <path d="M7.65151 16.3826L9.0386 14.3156L11.1056 15.7027L10.412 16.7362L7.65151 16.3826Z" fill="currentColor"/>
    </svg>`,
  "mk-make-attach": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
    <path fill-rule="evenodd" d="M17 8H7a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1ZM7 7a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2H7Z" clip-rule="evenodd"/>
    <path d="M8.2 14.067a1 1 0 0 1 1.6 0L12 17H6l2.2-2.933Z"/>
    <path d="M13.168 12.248a1 1 0 0 1 1.664 0L18 17h-8l3.168-4.752Z"/>
    <circle cx="8.5" cy="10.5" r="1.5"/>
  </svg>`,
  "mk-make-keyboard": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
  <path fill-rule="evenodd" d="M8.5 10a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H9a.5.5 0 0 1-.5-.5Zm2 0a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H11a.5.5 0 0 1-.5-.5Zm2 0a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H13a.5.5 0 0 1-.5-.5Zm2 0a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H15a.5.5 0 0 1-.5-.5Zm-5 2a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H10a.5.5 0 0 1-.5-.5Zm2 0a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H12a.5.5 0 0 1-.5-.5Zm2 0a.5.5 0 0 1 .5-.5h.001a.5.5 0 0 1 0 1H14a.5.5 0 0 1-.5-.5Zm.035 1.5H9.5a.5.5 0 0 0 0 1h3.626c.091-.355.23-.69.41-1Z" clip-rule="evenodd"/>
  <path d="M17 13.5v3m-1.5-1L17 17l1.5-1.5"/>
  <path fill-rule="evenodd" d="M7.5 9a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v2.53a4.045 4.045 0 0 1 1 0V9A1.5 1.5 0 0 0 16 7.5H8A1.5 1.5 0 0 0 6.5 9v6A1.5 1.5 0 0 0 8 16.5h5.126a4.01 4.01 0 0 1-.126-1H8a.5.5 0 0 1-.5-.5V9Z" clip-rule="evenodd"/>
</svg>`,
  "mk-make-slash": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
<path d="M9.574 4.818 5.824 18.75H4.307l3.75-13.932h1.517Z" opacity=".3"/>
<path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 0 1h-8a.5.5 0 0 1-.5-.5Z" clip-rule="evenodd"/>
<path fill-rule="evenodd" d="M14.5 8a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-1 0v-8a.5.5 0 0 1 .5-.5Z" clip-rule="evenodd"/>
</svg>`,
  "mk-make-style": `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24">
<path d="M7.648 15.273H6L8.51 8h1.982L13 15.273h-1.647L9.53 9.662h-.057l-1.825 5.61Zm-.103-2.859h3.892v1.2H7.545v-1.2Zm8.315 2.989c-.345 0-.659-.065-.94-.195a1.615 1.615 0 0 1-.671-.572c-.166-.25-.249-.554-.249-.909 0-.312.062-.566.185-.76a1.3 1.3 0 0 1 .493-.461c.206-.112.433-.194.682-.249.251-.057.503-.102.756-.135.332-.043.6-.074.807-.096.208-.023.36-.063.454-.117.097-.054.146-.15.146-.284v-.028c0-.35-.096-.623-.288-.817-.19-.194-.477-.291-.863-.291-.4 0-.714.087-.94.262a1.553 1.553 0 0 0-.48.562l-.796-.285a1.91 1.91 0 0 1 .568-.774c.24-.187.5-.317.782-.39a3.23 3.23 0 0 1 .838-.114c.175 0 .376.021.603.064.23.04.451.124.665.252.215.128.394.32.536.579.142.258.213.604.213 1.037v3.594h-.838v-.74h-.043a1.473 1.473 0 0 1-.284.38 1.64 1.64 0 0 1-.53.345c-.22.095-.488.142-.805.142Zm.129-.752c.331 0 .61-.066.838-.196a1.33 1.33 0 0 0 .696-1.154v-.767c-.036.043-.114.082-.235.117a3.98 3.98 0 0 1-.412.09 19.433 19.433 0 0 1-.802.106 3.203 3.203 0 0 0-.61.138 1.053 1.053 0 0 0-.456.28c-.113.124-.17.292-.17.505 0 .291.108.511.323.66.218.147.494.22.828.22Z"/>
</svg>`,
  "mk-mark-color": `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.47727 17H7L11.2727 5H12.7273L17 17H15.5227L12.0455 6.89844H11.9545L8.47727 17ZM9.02273 12.3125H14.9773V13.6016H9.02273V12.3125Z" fill="currentColor"/>
<path opacity="0.2" fill-rule="evenodd" clip-rule="evenodd" d="M18 21H6V19H18V20Z" fill="currentColor"/>
</svg>`
};

// src/components/FlowEditor/FlowEditorHover.tsx
var FlowEditorHover = (props) => {
  return /* @__PURE__ */ bn.createElement(bn.Fragment, null, props.toggle && /* @__PURE__ */ bn.createElement("div", {
    "aria-label": i18n_default.buttons.toggleFlow,
    onClick: props.toggleFlow,
    className: props.toggleState ? "mk-toggle-on" : "",
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-flow-hover"] }
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": i18n_default.buttons.openLink,
    onClick: props.openLink,
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-open-link"] }
  }));
};

// src/cm-extensions/flowEditor/flowEditor.tsx
var toggleFlowEditor = import_state3.Annotation.define();
var cacheFlowEditorHeight = import_state3.Annotation.define();
var preloadFlowEditor = import_state3.EditorState.transactionFilter.of((tr) => {
  let newTrans = [];
  const value = tr.state.field(flowEditorInfo, false);
  if (value && !tr.annotation(toggleFlowEditor)) {
    newTrans.push(...value.filter((f4) => f4.expandedState == 1).map((f4) => {
      if (tr.state.field(flowTypeStateField) == "doc") {
        return {
          annotations: toggleFlowEditor.of([f4.id, 2])
        };
      } else {
        return {
          annotations: toggleFlowEditor.of([f4.id, 0])
        };
      }
    }));
  }
  return [tr, ...newTrans];
});
var internalLinkHover = hoverTooltip((view, pos, side) => {
  let { from: lineFrom, to: lineTo, text } = view.state.doc.lineAt(pos);
  let hovObject = null;
  iterateTreeInSelection({ from: lineFrom, to: lineTo }, view.state, {
    enter: ({ name, from, to }) => {
      if (name.contains("hmd-internal-link") && pos <= to && pos >= from) {
        const stateField = view.state.field(flowEditorInfo, false);
        const info = stateField.find((f4) => f4.to == to);
        if (info) {
          hovObject = {
            pos: pos - 5,
            end: to,
            above: true,
            create(view2) {
              let dom = document.createElement("div");
              dom.toggleClass("mk-flow-hover", true);
              dom.toggleClass("menu", true);
              const openHoverDiv = dom.createDiv();
              openHoverDiv.setAttribute("aria-label", info.expandedState == 0 ? i18n_default.buttons.openFlow : i18n_default.buttons.hideFlow);
              openHoverDiv.addEventListener("click", () => {
                view2.dispatch({
                  annotations: toggleFlowEditor.of([info.id, 2])
                });
              });
              const icon = openHoverDiv.createDiv();
              icon.innerHTML = uiIconSet["mk-ui-flow-hover"];
              openHoverDiv.insertAdjacentText("beforeend", info.expandedState == 0 ? i18n_default.buttons.openFlow : i18n_default.buttons.hideFlow);
              return { dom };
            }
          };
          return false;
        }
      }
    }
  });
  return hovObject;
});
var findFullInternalLink = (posA, posB, state) => {
  let { text, from, length } = state.doc.lineAt(posA);
  let start2 = posA - from + 1, end2 = posB - from - 1;
  while (start2 > 0) {
    let prev = start2 - 1;
    if (text.slice(prev, start2) == "[")
      break;
    start2 = prev;
  }
  while (end2 < length) {
    let next = end2 + 1;
    if (text.slice(end2, next) == "]")
      break;
    end2 = next;
  }
  return start2 == end2 ? null : import_state3.EditorSelection.range(start2 + from, end2 + from);
};
var flowEditorInfo = import_state3.StateField.define({
  create() {
    return [];
  },
  update(value, tr) {
    let newValues = [];
    const previous = value;
    let usedContainers = [];
    let nameContainers = [];
    iterateTreeInDocument(tr.state, {
      enter: ({ name, from, to }) => {
        var _a2, _b2, _c2, _d2;
        if (name.contains("hmd-internal-link")) {
          nameContainers.push(name);
          const fullRange = findFullInternalLink(from, to, tr.state);
          const link = tr.state.sliceDoc(fullRange.from, fullRange.to);
          const existingLinks = previous.filter((f4) => f4.link == link);
          const offset2 = usedContainers.filter((f4) => f4 == link).length;
          const existingInfo = existingLinks[offset2];
          const id = existingInfo ? existingInfo.id : genId(8);
          let listEmbed = false;
          const embedOverride = tr.state.sliceDoc(fullRange.from - 4, fullRange.from - 3) == "!";
          const embedType = name.contains("hmd-embed") ? embedOverride ? 1 : 2 : 0;
          const reverseExpandedState = (state) => {
            const news = state != 2 ? 2 : 0;
            return news;
          };
          usedContainers.push(link);
          const info = {
            id,
            link: tr.state.sliceDoc(fullRange.from, fullRange.to),
            startOfLineFix: listEmbed,
            from: fullRange.from,
            to: fullRange.to,
            embed: embedType,
            height: existingInfo ? ((_a2 = tr.annotation(cacheFlowEditorHeight)) == null ? void 0 : _a2[0]) == id && ((_b2 = tr.annotation(cacheFlowEditorHeight)) == null ? void 0 : _b2[1]) != 0 ? (_c2 = tr.annotation(cacheFlowEditorHeight)) == null ? void 0 : _c2[1] : existingInfo.height : -1,
            expandedState: existingInfo ? ((_d2 = tr.annotation(toggleFlowEditor)) == null ? void 0 : _d2[0]) == id ? reverseExpandedState(existingInfo.expandedState) : existingInfo.expandedState : embedType >= 1 ? 1 : 0
          };
          newValues.push(info);
        }
      }
    });
    return newValues;
  }
});
var flowEditorRangeset = (state) => {
  let builder = new import_state3.RangeSetBuilder();
  const infoFields = state.field(flowEditorInfo);
  for (let info of infoFields) {
    const { from, to, embed: embedType, expandedState } = info;
    const lineFix = from - 3 == state.doc.lineAt(from).from && to + 2 == state.doc.lineAt(from).to;
    if (expandedState == 2) {
      if (embedType == 1) {
        if (!(state.selection.main.from == from - 4 && state.selection.main.to == to + 2 || state.selection.main.from >= from - 3 && state.selection.main.to <= to + 1)) {
          builder.add(from - 4, from - 3, flowEditorSelector(info));
          if (lineFix) {
            builder.add(from - 3, to + 2, flowEditorWidgetDecoration(info));
          } else {
            builder.add(from - 3, to + 2, flowEditorDecoration(info));
          }
        }
      } else if (embedType == 0) {
        builder.add(to + 2, to + 2, flowEditorDecoration(info));
      }
    }
  }
  const dec = builder.finish();
  return dec;
};
var flowEditorField = import_state3.StateField.define({
  create(state) {
    return flowEditorRangeset(state);
  },
  update(value, tr) {
    return flowEditorRangeset(tr.state);
  },
  provide: (f4) => import_view3.EditorView.decorations.from(f4)
});
var FlowEditorWidget = class extends import_view3.WidgetType {
  constructor(info) {
    super();
    this.info = info;
  }
  eq(other) {
    return other.info.id === this.info.id;
  }
  toDOM(view) {
    const div = document.createElement("div");
    div.toggleClass("mk-floweditor-container", true);
    div.toggleClass("mk-floweditor-fix", this.info.startOfLineFix);
    div.setAttribute("id", "mk-flow-" + this.info.id);
    const placeholder2 = div.createDiv("mk-floweditor-placeholder");
    placeholder2.style.setProperty("height", this.info.height + "px");
    loadFlowEditorByDOM(div, view, this.info.id);
    return div;
  }
  get estimatedHeight() {
    return this.info.height;
  }
};
var FlowEditorSelector = class extends import_view3.WidgetType {
  constructor(info) {
    super();
    this.info = info;
  }
  eq(other) {
    return false;
  }
  toDOM(view) {
    const div = document.createElement("div");
    div.toggleClass("mk-floweditor-selector", true);
    const reactEl = createRoot(div);
    reactEl.render(/* @__PURE__ */ bn.createElement(FlowEditorHover, {
      toggle: true,
      toggleState: true,
      toggleFlow: () => {
        view.dispatch({
          changes: { from: this.info.from - 4, to: this.info.from - 3 }
        });
      },
      openLink: () => {
        app.workspace.iterateLeaves((leaf) => {
          var _a2, _b2;
          const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
          if (cm && view.dom == cm.dom) {
            openFileFlowEditor(this.info.link, (_b2 = leaf.view.file) == null ? void 0 : _b2.path);
          }
        }, app.workspace["rootSplit"]);
      }
    }));
    return div;
  }
};
var flowEditorSelector = (info) => import_view3.Decoration.replace({
  widget: new FlowEditorSelector(info),
  inclusive: true,
  block: false
});
var flowEditorDecoration = (info) => import_view3.Decoration.replace({
  widget: new FlowEditorWidget(info),
  inclusive: true,
  block: false
});
var flowEditorWidgetDecoration = (info) => import_view3.Decoration.widget({
  widget: new FlowEditorWidget(info),
  block: true
});

// src/utils/flowEditor.ts
var import_state6 = require("@codemirror/state");

// src/cm-extensions/flowEditor/selectiveEditor.ts
var import_state4 = require("@codemirror/state");
var import_view4 = require("@codemirror/view");

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// src/cm-extensions/flowEditor/selectiveEditor.ts
var editableRange = import_state4.Annotation.define();
var hiddenLine = import_view4.Decoration.replace({ inclusive: true });
var hideLine = import_state4.StateField.define({
  create() {
    return import_view4.Decoration.none;
  },
  update(value, tr) {
    var _a2;
    let builder = new import_state4.RangeSetBuilder();
    if (((_a2 = tr.state.field(selectiveLinesFacet)) == null ? void 0 : _a2[0]) != void 0) {
      builder.add(tr.state.doc.line(1).from, tr.state.doc.line(tr.state.field(selectiveLinesFacet)[0]).from, hiddenLine);
      builder.add(tr.state.doc.line(Math.min(tr.newDoc.lines, tr.state.field(selectiveLinesFacet)[1])).to, tr.state.doc.line(tr.newDoc.lines).to, hiddenLine);
    }
    const dec = builder.finish();
    return dec;
  },
  provide: (f4) => import_view4.EditorView.decorations.from(f4)
});
var selectiveLinesFacet = import_state4.StateField.define({
  create: () => [void 0, void 0],
  update(value, tr) {
    if (tr.annotation(editableRange)) {
      if (tr.annotation(editableRange)[0]) {
        return [tr.annotation(editableRange)[0], Math.min(tr.state.doc.lines, tr.annotation(editableRange)[1])];
      }
      return tr.annotation(editableRange);
    }
    return value;
  }
});
var lineRangeToPosRange = (state, range) => {
  return {
    from: state.doc.line(range[0]).from,
    to: state.doc.line(Math.min(state.doc.lines, range[1])).to
  };
};
var smartDelete = import_state4.EditorState.transactionFilter.of((tr) => {
  var _a2;
  if (tr.isUserEvent("delete") && !tr.isUserEvent("delete.smart")) {
    const initialSelections = tr.startState.selection.ranges.map((range) => ({
      from: range.from,
      to: range.to
    }));
    if (initialSelections.length > 0 && ((_a2 = tr.startState.field(selectiveLinesFacet)) == null ? void 0 : _a2[0])) {
      const posRange = lineRangeToPosRange(tr.startState, tr.startState.field(selectiveLinesFacet));
      const minFrom = Math.max(posRange.from, initialSelections[0].from);
      const minTo = Math.min(posRange.to, initialSelections[0].to);
      tr.startState.update({
        changes: {
          from: Math.min(minFrom, minTo),
          to: Math.max(minFrom, minTo)
        },
        annotations: import_state4.Transaction.userEvent.of(`${tr.annotation(import_state4.Transaction.userEvent)}.smart`)
      });
    }
  }
  return tr;
});
var preventModifyTargetRanges = import_state4.EditorState.transactionFilter.of((tr) => {
  let newTrans = [];
  try {
    const selectiveLines = tr.startState.field(selectiveLinesFacet);
    if (tr.isUserEvent("input") || tr.isUserEvent("delete") || tr.isUserEvent("move")) {
      if (selectiveLines == null ? void 0 : selectiveLines[0]) {
        const posRange = lineRangeToPosRange(tr.startState, tr.startState.field(selectiveLinesFacet));
        if (tr.changes.touchesRange(0, posRange.from - 1) || !tr.changes.touchesRange(posRange.from, posRange.to)) {
          return [];
        }
      }
    }
    if (tr.state.doc.lines != tr.startState.doc.lines) {
      const numberNewLines = tr.state.doc.lines - tr.startState.doc.lines;
      if (selectiveLines == null ? void 0 : selectiveLines[0]) {
        const posRange = lineRangeToPosRange(tr.startState, tr.startState.field(selectiveLinesFacet));
        if (tr.changes.touchesRange(0, posRange.from - 1)) {
          newTrans.push({
            annotations: [editableRange.of([selectiveLines[0] + numberNewLines, selectiveLines[1] + numberNewLines])]
          });
        } else if (tr.changes.touchesRange(posRange.from - 1, posRange.to)) {
          newTrans.push({
            annotations: [editableRange.of([selectiveLines[0], selectiveLines[1] + numberNewLines])]
          });
        }
      }
    }
  } catch (e3) {
    return [];
  }
  return [tr, ...newTrans];
});
var readOnlyRangesExtension = [smartDelete, preventModifyTargetRanges];
var editBlockExtensions = () => [readOnlyRangesExtension, hideLine, selectiveLinesFacet];

// src/cm-extensions/flowEditor/atomic.ts
var import_state5 = require("@codemirror/state");
var arrowKeyAnnotation = import_state5.Annotation.define();
var atomicSelect = import_state5.EditorState.transactionFilter.of((tr) => {
  if (tr.isUserEvent("delete") || tr.isUserEvent("input")) {
    return tr;
  }
  const flowID = tr.startState.field(flowIDStateField, false);
  if (tr.annotation(arrowKeyAnnotation) && flowID) {
    const oldSel = tr.startState.selection.main;
    const lineRange = tr.state.field(selectiveLinesFacet, false);
    const posRange = lineRange && lineRange[0] != void 0 ? lineRangeToPosRange(tr.startState, lineRange) : { from: 0, to: tr.startState.doc.length };
    if (oldSel.from <= posRange.from && tr.annotation(arrowKeyAnnotation) == 3) {
      focusFlowEditorParent(flowID, true);
    }
    if (oldSel.to >= posRange.to && tr.annotation(arrowKeyAnnotation) == 4) {
      focusFlowEditorParent(flowID, false);
    }
    return tr;
  }
  const selection = tr.newSelection.main;
  if (selection.from == 0 && selection.to == 0 || selection.from != selection.to)
    return tr;
  const flowEditors = tr.state.field(flowEditorInfo, false);
  if (flowEditors) {
    for (let info of flowEditors) {
      if (info.embed == 1) {
        if (info.from - 3 <= selection.from && info.to + 2 >= selection.to && info.expandedState == 2) {
          const top2 = tr.annotation(arrowKeyAnnotation) == 1 || tr.startState.selection.main.from > selection.from ? false : true;
          focusFlowEditor(info.id, top2);
          return {
            selection: import_state5.EditorSelection.single(info.from - 4)
          };
          break;
        }
      }
    }
  }
  return tr;
});

// src/utils/flowEditor.ts
var parseOutReferences = (ostr) => {
  const str = ostr.split("|")[0];
  const refIndex = str.lastIndexOf("#");
  return refIndex != -1 ? [str.substring(0, refIndex), str.substring(refIndex + 1)] : [str, void 0];
};
var getFileFromString = (url, source) => {
  return app.metadataCache.getFirstLinkpathDest(url, source);
};
var getLineRangeFromRef = (file, ref, app2) => {
  var _a2;
  if (!ref) {
    return [void 0, void 0];
  }
  const cache = app2.metadataCache.getFileCache(file);
  const headings = cache.headings;
  const blocks = cache.blocks;
  const sections2 = cache.sections;
  if (blocks && ref.charAt(0) == "^" && blocks[ref.substring(1)]) {
    return [blocks[ref.substring(1)].position.start.line + 1, blocks[ref.substring(1)].position.end.line + 1];
  }
  const heading = headings == null ? void 0 : headings.find((f4) => f4.heading.replace("#", " ") == ref);
  if (heading) {
    const index = headings.findIndex((f4) => f4.heading == heading.heading);
    const level = (_a2 = headings[index]) == null ? void 0 : _a2.level;
    const nextIndex2 = headings.findIndex((f4, i3) => i3 > index && f4.level <= level);
    const start2 = window.make.settings.editorFlowStyle == "classic" ? heading.position.start.line + 1 : heading.position.start.line + 2;
    if (index < headings.length - 1 && nextIndex2 != -1) {
      return [start2, headings[nextIndex2].position.end.line];
    }
    return [start2, sections2[sections2.length - 1].position.end.line + 1];
  }
  return [void 0, void 0];
};
var loadFlowEditorByDOM = (el, view, id) => {
  setTimeout(async () => {
    let counter = 0;
    while (!el.parentElement && counter++ <= 50)
      await sleep(50);
    if (!el.parentElement)
      return;
    let dom = el;
    while (!dom.hasClass("mk-floweditor") && !dom.hasClass("workspace") && dom.parentElement) {
      dom = dom.parentElement;
    }
    if (!dom.hasClass("mk-floweditor") && !dom.hasClass("workspace")) {
      return;
    }
    setTimeout(async () => {
      let counter2 = 0;
      while (!dom.parentElement && counter2++ <= 50)
        await sleep(50);
      if (!dom.parentElement)
        return;
      app.workspace.iterateLeaves((leaf) => {
        var _a2;
        const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
        if (cm && view.dom == cm.dom) {
          loadFlowEditorsForLeafForID(cm, leaf, app, id);
        }
      }, app.workspace["rootSplit"]);
    });
  });
};
var loadFlowEditorsForLeafForID = (cm, leaf, app2, id) => {
  const stateField = cm.state.field(flowEditorInfo, false);
  if (!stateField)
    return;
  const flowInfo = stateField.find((f4) => f4.id == id);
  if (flowInfo && flowInfo.expandedState == 2) {
    loadFlowEditor(cm, flowInfo, leaf, app2);
  }
};
var loadFlowEditor = (cm, flowEditorInfo2, leaf, app2) => {
  var _a2;
  const dom = cm.dom.querySelector("#mk-flow-" + flowEditorInfo2.id);
  const [link, ref] = parseOutReferences(flowEditorInfo2.link);
  const source = (_a2 = leaf.view.file) == null ? void 0 : _a2.path;
  const file = getFileFromString(link, source);
  if (dom) {
    if (file) {
      const selectiveRange = getLineRangeFromRef(file, ref, app2);
      if (!dom.hasAttribute("ready")) {
        dom.setAttribute("ready", "");
        createFlowEditorInElement(flowEditorInfo2.id, dom, ref ? "block" : "flow", file.path, selectiveRange[0], selectiveRange[1]);
      }
    } else {
      dom.empty();
      const createDiv = dom.createDiv("file-embed");
      createDiv.toggleClass("mod-empty", true);
      const createFile = async (e3) => {
        e3.stopPropagation();
        e3.stopImmediatePropagation();
        await app2.fileManager.createNewMarkdownFile(app2.vault.getRoot(), link);
        loadFlowEditor(cm, flowEditorInfo2, leaf, app2);
      };
      createDiv.setText(`"${link}" ` + i18n_default.labels.noFile);
      createDiv.addEventListener("click", createFile);
    }
  }
};
var focusPortal = async (plugin, evt) => {
  const { id, parent, top: top2 } = evt.detail;
  if (parent) {
    app.workspace.iterateLeaves((leaf) => {
      var _a2;
      const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
      if (cm) {
        const stateField = cm.state.field(flowEditorInfo, false);
        if (stateField) {
          const foundInfo = stateField.find((f4) => f4.id == id);
          if (foundInfo) {
            cm.focus();
            if (top2) {
              cm.dispatch({
                selection: import_state6.EditorSelection.single(foundInfo.from - 4),
                annotations: arrowKeyAnnotation.of(1)
              });
            } else {
              if (foundInfo.to + 2 == cm.state.doc.length) {
                cm.dispatch({
                  changes: [{ from: foundInfo.to + 2, to: foundInfo.to + 2, insert: cm.state.lineBreak }],
                  selection: import_state6.EditorSelection.single(foundInfo.to + 3),
                  annotations: arrowKeyAnnotation.of(2)
                });
              } else {
                cm.dispatch({
                  selection: import_state6.EditorSelection.single(foundInfo.to + 3),
                  annotations: arrowKeyAnnotation.of(2)
                });
              }
            }
          }
        }
      }
    }, app.workspace["rootSplit"]);
  } else {
    app.workspace.iterateLeaves((leaf) => {
      var _a2;
      const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
      if (cm) {
        const stateField = cm.state.field(flowIDStateField, false);
        if (stateField && stateField == id) {
          cm.focus();
          const lineRange = cm.state.field(selectiveLinesFacet, false);
          const posRange = lineRange && lineRange[0] != void 0 ? lineRangeToPosRange(cm.state, lineRange) : { from: 0, to: cm.state.doc.length };
          if (top2) {
            cm.dispatch({
              selection: import_state6.EditorSelection.single(posRange.from)
            });
          } else {
            cm.dispatch({
              selection: import_state6.EditorSelection.single(posRange.to)
            });
          }
        }
      }
    }, app.workspace["rootSplit"]);
  }
};
var openFileFromPortal = (plugin, evt) => {
  const { file: fullLink, source } = evt.detail;
  const [link, ref] = parseOutReferences(fullLink);
  const file = getFileFromString(link, source);
  openFile({ ...file, isFolder: false }, plugin.app, false);
};
var spawnNewPortal = async (plugin, evt) => {
  var _a2, _b2;
  const { file, el, from, to } = evt.detail;
  let portalFile = plugin.app.vault.getAbstractFileByPath(file);
  const newLeaf = spawnPortal(plugin, el, !from && portalFile.name);
  await newLeaf.openFile(portalFile);
  const view = (_a2 = newLeaf.view.editor) == null ? void 0 : _a2.cm;
  view.dispatch({
    annotations: [portalTypeAnnotation.of(evt.detail.type), flowIDAnnotation.of(evt.detail.id)]
  });
  view.dom.addEventListener("keydown", (e3) => {
    if (e3.key == "ArrowUp") {
      if (e3.metaKey == true) {
        view.dispatch({
          annotations: arrowKeyAnnotation.of(3)
        });
      } else {
        view.dispatch({
          annotations: arrowKeyAnnotation.of(1)
        });
      }
    }
    if (e3.key == "ArrowDown") {
      if (e3.metaKey == true) {
        view.dispatch({
          annotations: arrowKeyAnnotation.of(4)
        });
      } else {
        view.dispatch({
          annotations: arrowKeyAnnotation.of(2)
        });
      }
    }
  });
  if (from && to) {
    (_b2 = newLeaf.view.editor) == null ? void 0 : _b2.cm.dispatch({
      annotations: [editableRange.of([from, to])]
    });
  }
};
var spawnPortal = (plugin, initiatingEl, fileName, onShowCallback) => {
  const parent = plugin.app.workspace.activeLeaf;
  if (!initiatingEl)
    initiatingEl = parent.containerEl;
  const hoverPopover = new FlowEditor(parent, initiatingEl, plugin, void 0, onShowCallback);
  if (fileName)
    hoverPopover.titleEl.textContent = fileName.substring(0, fileName.lastIndexOf("."));
  ;
  return hoverPopover.attachLeaf();
};

// src/components/FlowView/FlowRow.tsx
import_dayjs.default.extend(require_relativeTime());
var FlowRow = (props) => {
  var _a2;
  const ref = _2(null);
  const [flowOpen, setFlowOpen] = p2(false);
  const loadFile = () => {
    const file = props.item.file;
    const div = ref.current;
    const newLeaf = spawnPortal(props.plugin, div);
    newLeaf.openFile(file);
  };
  const toggleFlow = (event) => {
    event.stopPropagation();
    const newState = !flowOpen;
    if (newState) {
      loadFile();
    } else {
      ref.current.empty();
    }
    setFlowOpen(newState);
  };
  const { item } = props;
  return /* @__PURE__ */ bn.createElement("div", {
    className: "mk-flowspace-container"
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-flowspace-title",
    onClick: (e3) => openFile({ ...props.item.file, isFolder: item.type == "folder" }, props.plugin.app, false)
  }, /* @__PURE__ */ bn.createElement("div", {
    dangerouslySetInnerHTML: ((_a2 = item.icon) != null ? _a2 : item.type == "folder") ? { __html: uiIconSet["mk-ui-folder"] } : { __html: uiIconSet["mk-ui-file"] }
  }, item.icon && unifiedToNative(item.icon[1])), /* @__PURE__ */ bn.createElement("div", null, /* @__PURE__ */ bn.createElement("p", null, item.name), /* @__PURE__ */ bn.createElement("p", {
    className: "mk-flowspace-date"
  }, item.created && (0, import_dayjs.default)(item.created).fromNow())), " ", /* @__PURE__ */ bn.createElement("span", null), /* @__PURE__ */ bn.createElement("button", {
    onClick: toggleFlow,
    className: flowOpen ? "mk-open" : "",
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-flow-hover"] }
  })), /* @__PURE__ */ bn.createElement("div", {
    className: "mk-flowspace-editor",
    ref
  }));
};

// src/components/FlowView/FlowComponent.tsx
var FolderComponent = (props) => {
  const filteredNotes = props.folder.children.map((f4) => {
    return {
      type: f4.children ? "folder" : f4.extension,
      file: f4,
      name: f4.name,
      path: f4.path,
      icon: props.plugin.settings.fileIcons.find(([path, icon]) => path == f4.path),
      children: f4.children,
      created: f4.stat ? f4.stat.ctime : void 0
    };
  });
  return /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-scroller"
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-sizer"
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-header"
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "inline-title"
  }, props.folder.name)), filteredNotes.length > 0 ? /* @__PURE__ */ bn.createElement("div", null, filteredNotes.map((f4, i3) => /* @__PURE__ */ bn.createElement(FlowRow, {
    key: i3,
    item: f4,
    plugin: props.plugin
  }))) : /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-empty"
  }, i18n_default.flowView.emptyFolder)));
};

// src/components/FlowView/FlowView.tsx
var FOLDER_VIEW_TYPE = "make-folder-view";
var FlowView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.navigation = true;
    this.plugin = plugin;
  }
  getViewType() {
    return FOLDER_VIEW_TYPE;
  }
  getDisplayText() {
    var _a2;
    return (_a2 = this.folder) == null ? void 0 : _a2.name;
  }
  async onClose() {
    this.destroy();
  }
  destroy() {
    if (this.root)
      this.root.unmount();
  }
  async onOpen() {
    this.destroy();
  }
  async setState(state, result) {
    const folder = this.plugin.app.vault.getAbstractFileByPath(state.folder);
    this.folder = folder;
    this.constructFileTree(folder);
    await super.setState(state, result);
    this.leaf.tabHeaderInnerTitleEl.innerText = folder.name;
    this.leaf.view.titleEl = folder.name;
    const headerEl = this.leaf.view.headerEl;
    if (headerEl) {
      headerEl.querySelector(".view-header-title").innerText = folder.name;
    }
    return;
  }
  getState() {
    var _a2;
    let state = super.getState();
    state.folder = (_a2 = this.folder) == null ? void 0 : _a2.path;
    return state;
  }
  constructFileTree(folder) {
    this.destroy();
    this.root = createRoot(this.contentEl);
    this.root.render(/* @__PURE__ */ bn.createElement("div", {
      className: "mk-folder-view"
    }, /* @__PURE__ */ bn.createElement(FolderComponent, {
      folder,
      plugin: this.plugin
    })));
  }
};

// src/utils/utils.ts
function buildTree(flattenedItems) {
  var _a2, _b2;
  const root = { ...flattenedItems.find((f4) => f4.id == "/"), children: [], isRoot: () => true };
  const items = flattenedItems.map((item) => ({ ...item, children: [] }));
  for (const item of items) {
    const { id, children, vault, path, name, parent } = item;
    const parentId = (_a2 = item.parentId) != null ? _a2 : "/";
    const _parent = (_b2 = items.find((f4) => f4.id == parentId)) != null ? _b2 : items.find((f4) => f4.id == "/");
    if (_parent) {
      if (item.isFolder) {
        _parent.children.push({ children, vault, parent, path, name });
      } else {
        _parent.children.push({ vault, parent, path, name });
      }
    }
  }
  return {
    ...root,
    children: items.filter((f4) => f4.parentId == "/").map((item) => {
      const { children, vault, path, name, parent } = item;
      if (item.isFolder) {
        return { children, vault, parent, path, name };
      } else {
        return { vault, parent, path, name };
      }
    })
  };
}
var nodeIsAncestorOfTarget = (node, target) => {
  const recursive = (_node, _target) => {
    if (!_target.path) {
      return false;
    }
    if (_target.path == "/")
      return false;
    if (_target.parent.path == _node.path)
      return true;
    return recursive(_node, _target.parent);
  };
  return recursive(node, target);
};
function getMaxDepth({ previousItem }) {
  if (previousItem) {
    if (previousItem.isFolder)
      return previousItem.depth + 1;
    return previousItem.depth;
  }
  return 0;
}
function getMinDepth({ nextItem }) {
  if (nextItem) {
    return nextItem.depth;
  }
  return 0;
}
function getDragDepth(offset2, indentationWidth) {
  return Math.round(offset2 / indentationWidth) + 1;
}
function getProjection(items, activeItem, overItemIndex, previousItem, nextItem, dragDepth) {
  const activeIsSection = activeItem.parentId == null;
  const overIsSection = previousItem.parentId == null;
  if (nodeIsAncestorOfTarget(activeItem, previousItem)) {
    return null;
  }
  if (activeIsSection) {
    if (overIsSection) {
      return { depth: 0, maxDepth: 0, minDepth: 0, overId: previousItem.id, parentId: null };
    }
    return null;
  }
  if (activeItem.section != previousItem.section) {
    if (previousItem.section == -1) {
      return null;
    }
  }
  const projectedDepth = dragDepth;
  const maxDepth = getMaxDepth({
    previousItem
  });
  const minDepth = getMinDepth({ nextItem });
  let depth = projectedDepth;
  if (projectedDepth >= maxDepth) {
    depth = maxDepth;
  } else if (projectedDepth < minDepth) {
    depth = minDepth;
  }
  if (previousItem.section != -1 && depth > 1) {
    return null;
  }
  return { depth, maxDepth, minDepth, overId: previousItem.id, parentId: getParentId() };
  function getParentId() {
    var _a2;
    if (depth === 0 || !previousItem) {
      return "/";
    }
    if (depth === previousItem.depth || depth > previousItem.depth && !previousItem.isFolder) {
      return previousItem.parentId;
    }
    if (depth > previousItem.depth) {
      return previousItem.id;
    }
    const newParent = (_a2 = items.slice(0, overItemIndex).reverse().find((item) => item.depth === depth)) == null ? void 0 : _a2.parentId;
    return newParent != null ? newParent : null;
  }
}
var flattenTrees = (items, section, sectionIndex, parentId = null, depth = 0) => {
  return items.filter((f4) => f4).reduce((acc, item, index) => {
    const id = parentId + "/" + item.path;
    if (item.children) {
      return [
        ...acc,
        { ...item, parentId, depth, section: sectionIndex, index, id, isFolder: true },
        ...flattenTrees(item.children, section, sectionIndex, id, depth + 1)
      ];
    } else {
      return [
        ...acc,
        { ...item, parentId, depth, section: sectionIndex, index, id, isFolder: false }
      ];
    }
  }, []);
};
var flattenTree = (folder, path, sectionIndex, collapsed) => {
  return [{
    ...folder,
    id: folder.path,
    parentId: null,
    depth: 0,
    index: 0,
    section: -1,
    isFolder: true
  }, ...!collapsed ? flattenTrees(folder.children, path, sectionIndex, path, 1) : []];
};
function includeChildrenOf(items, ids3) {
  const excludeParentIds = items.filter((f4) => {
    var _a2;
    return ((_a2 = f4.children) == null ? void 0 : _a2.length) > 0 && !ids3.find((i3) => i3 == f4.id) && f4.id != "/";
  }).map((f4) => f4.id);
  return items.filter((item) => {
    var _a2;
    if (item.parentId && excludeParentIds.includes(item.parentId)) {
      if ((_a2 = item.children) == null ? void 0 : _a2.length) {
        excludeParentIds.push(item.id);
      }
      return false;
    }
    return true;
  });
}
var sortFolderTree = async (folderTree2, plugin) => {
  const stringTree = plugin.settings.folderRank;
  const rawStringTree = folderTreeToStringTree(folderTree2);
  const newStringTree = mergeStringTree(stringTree, rawStringTree);
  plugin.settings.folderRank = newStringTree;
  plugin.saveSettings(false);
  const sortedFolderTree = sortFolderTreeUsingStringTree(folderTree2, newStringTree);
  return sortedFolderTree;
};
var renamePathInStringTree = (oldPath, newFile, plugin) => {
  const stringTree = plugin.settings.folderRank;
  const newName = newFile.name;
  const newPath = newFile.path;
  const recursive = (tree, path, oldS, newS) => {
    if (path == oldS) {
      return {
        ...tree,
        node: newS
      };
    } else if (!tree.isFolder) {
      return tree;
    }
    return {
      ...tree,
      children: tree.children.map((f4) => recursive(f4, path + "/" + f4.node, oldS, newS))
    };
  };
  plugin.settings.fileIcons = plugin.settings.fileIcons.map((f4) => f4[0] == oldPath ? [newPath, f4[1]] : f4);
  plugin.settings.spaces = plugin.settings.spaces.map((f4) => {
    return { ...f4, children: f4.children.map((g4) => g4 == oldPath ? newPath : g4) };
  });
  plugin.settings.folderRank = recursive(stringTree, "", "/" + oldPath, newName);
  plugin.saveSettings();
};
var folderTreeToStringTree = (tree) => {
  const recursive = (subtree) => {
    if (subtree.children) {
      return {
        node: subtree.name,
        children: subtree.children.map((f4) => recursive(f4)),
        isFolder: true
      };
    } else {
      return {
        node: subtree.name,
        children: [],
        isFolder: false
      };
    }
  };
  return recursive(tree);
};
var reorderStringTree = (savedTrees, rawTrees) => {
  const missingTrees = rawTrees.filter((f4) => !savedTrees.find((g4) => f4.node == g4.node));
  const allTrees = [...savedTrees, ...missingTrees];
  const filteredTrees = allTrees.filter((f4) => rawTrees.find((g4) => f4.node == g4.node));
  return filteredTrees;
};
var mergeStringTree = (savedTree, rawTree) => {
  const flattenSavedTree = (tree) => {
    const treeReduce = (t3, currPath) => {
      return t3.reduce((p3, c3) => {
        return [...p3, {
          ...c3,
          path: currPath + "/" + c3.node
        }, ...treeReduce(c3.children, currPath + "/" + c3.node)];
      }, []);
    };
    return [
      { ...tree, path: "/" },
      ...treeReduce(tree.children, "/")
    ];
  };
  const rankReferences = flattenSavedTree(savedTree);
  const recursive = (subtree, treePaths, currPath) => {
    const existingTree = treePaths.find((f4) => currPath == f4.path);
    if (existingTree) {
      return {
        ...subtree,
        children: reorderStringTree(existingTree.children, subtree.children).map((t3) => recursive(t3, treePaths, currPath + "/" + t3.node))
      };
    } else {
      return {
        ...subtree,
        children: subtree.children.map((t3) => recursive(t3, treePaths, currPath + "/" + t3.node))
      };
    }
  };
  return recursive(rawTree, rankReferences, "/");
};
var sortFolderTreeUsingStringTree = (folderTree2, stringTree) => {
  const recursiveSort = (file, strings) => {
    if (file instanceof import_obsidian4.TFolder) {
      return {
        ...file,
        children: file.children.map((f4) => {
          const currStringTree = strings.children.find((g4) => g4.node == f4.name);
          if (currStringTree)
            return recursiveSort(f4, currStringTree);
          return f4;
        }).sort((a3, b3) => strings.children.findIndex((x4) => x4.node == a3.name) - strings.children.findIndex((x4) => x4.node == b3.name))
      };
    } else {
      return file;
    }
  };
  return recursiveSort(folderTree2, stringTree);
};
var internalPluginLoaded = (pluginName, app2) => {
  var _a2;
  return (_a2 = app2.internalPlugins.plugins[pluginName]) == null ? void 0 : _a2._loaded;
};
var openFile = async (file, app2, newLeaf) => {
  if (file.isFolder) {
    let leaf = app2.workspace.getLeaf(newLeaf);
    app2.workspace.setActiveLeaf(leaf, { focus: true });
    await leaf.setViewState({ type: FOLDER_VIEW_TYPE, state: { folder: file.path } });
    await app2.workspace.requestSaveLayout();
  } else {
    let leaf = app2.workspace.getLeaf(newLeaf);
    app2.workspace.setActiveLeaf(leaf, { focus: true });
    await leaf.openFile(app2.vault.getAbstractFileByPath(file.path), { eState: { focus: true } });
  }
};
var openFileInNewPane = (plugin, file) => {
  openFile(file, plugin.app, true);
};
function selectElementContents(el) {
  var range = document.createRange();
  range.selectNodeContents(el);
  var sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}
var createNewMarkdownFile = async (app2, folder, newFileName, content) => {
  const newFile = await app2.fileManager.createNewMarkdownFile(folder, newFileName);
  if (content && content !== "")
    await app2.vault.modify(newFile, content);
  await openFile(newFile, app2, false);
  const titleEl = app2.workspace.activeLeaf.view.containerEl.querySelector(".inline-title");
  if (titleEl) {
    titleEl.focus();
    selectElementContents(titleEl);
  }
  let evt = new CustomEvent(eventTypes.activeFileChange, { detail: { filePath: newFile.path } });
  window.dispatchEvent(evt);
  return newFile;
};
var platformIsMobile = () => {
  return import_obsidian4.Platform.isMobile;
};
var unifiedToNative = (unified) => {
  let unicodes = unified.split("-");
  let codePoints = unicodes.map((u3) => `0x${u3}`);
  return String.fromCodePoint(...codePoints);
};

// src/components/Spaces/TreeView/FolderTreeView.tsx
var import_obsidian7 = require("obsidian");

// node_modules/@dnd-kit/core/node_modules/@dnd-kit/utilities/dist/utilities.esm.js
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode2(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode2(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node) {
  const {
    Document
  } = getWindow(node);
  return node instanceof Document;
}
function isHTMLElement(node) {
  if (isWindow(node)) {
    return false;
  }
  return node instanceof getWindow(node).HTMLElement;
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode2(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
var useIsomorphicLayoutEffect = canUseDOM ? s2 : h2;
function useEvent(handler) {
  const handlerRef = _2(handler);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return T2(function(...args) {
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = _2(null);
  const set = T2((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = T2(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set, clear];
}
function useLatestValue(value, dependencies = [value]) {
  const valueRef = _2(value);
  useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = _2();
  return F(() => {
    const newValue = callback(valueRef.current);
    valueRef.current = newValue;
    return newValue;
  }, [...dependencies]);
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node = _2(null);
  const setNodeRef = T2((element) => {
    if (element !== node.current) {
      onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
    }
    node.current = element;
  }, []);
  return [node, setNodeRef];
}
function usePrevious2(value) {
  const ref = _2();
  h2(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var ids = {};
function useUniqueId(prefix, value) {
  return F(() => {
    if (value) {
      return value;
    }
    const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
    ids[prefix] = id;
    return `${prefix}-${id}`;
  }, [prefix, value]);
}
function createAdjustmentFn(modifier) {
  return (object, ...adjustments) => {
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key2, valueAdjustment] of entries) {
        const value = accumulator[key2];
        if (value != null) {
          accumulator[key2] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object
    });
  };
}
var add = /* @__PURE__ */ createAdjustmentFn(1);
var subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x4,
        clientY: y3
      } = event.touches[0];
      return {
        x: x4,
        y: y3
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x4,
        clientY: y3
      } = event.changedTouches[0];
      return {
        x: x4,
        y: y3
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
var CSS = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x4,
        y: y3
      } = transform;
      return `translate3d(${x4 ? Math.round(x4) : 0}px, ${y3 ? Math.round(y3) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX,
        scaleY
      } = transform;
      return `scaleX(${scaleX}) scaleY(${scaleY})`;
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString({
      property,
      duration,
      easing
    }) {
      return `${property} ${duration}ms ${easing}`;
    }
  }
});
var SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}

// node_modules/@dnd-kit/core/node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js
var hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return bn.createElement("div", {
    id,
    style: hiddenStyles
  }, value);
}
var visuallyHidden = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function LiveRegion(_ref) {
  let {
    id,
    announcement
  } = _ref;
  return bn.createElement("div", {
    id,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = p2("");
  const announce = T2((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}

// node_modules/@dnd-kit/core/dist/core.esm.js
var DndMonitorContext = /* @__PURE__ */ B(null);
function useDndMonitor(listener) {
  const registerListener = q2(DndMonitorContext);
  h2(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners] = p2(() => /* @__PURE__ */ new Set());
  const registerListener = T2((listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = T2((_ref) => {
    let {
      type,
      event
    } = _ref;
    listeners.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}
var defaultScreenReaderInstructions = {
  draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
var defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },
  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;
    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }
    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },
  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;
    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }
    return "Draggable item " + active.id + " was dropped.";
  },
  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }
};
function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = p2(false);
  h2(() => {
    setMounted(true);
  }, []);
  useDndMonitor(F(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = bn.createElement(bn.Fragment, null, bn.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), bn.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? j3(markup, container) : markup;
}
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop() {
}
function useSensor(sensor, options) {
  return F(() => ({
    sensor,
    options: options != null ? options : {}
  }), [sensor, options]);
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return F(() => [...sensors].filter((sensor) => sensor != null), [...sensors]);
}
var defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p22) {
  return Math.sqrt(Math.pow(p1.x - p22.x, 2) + Math.pow(p1.y - p22.y, 2));
}
function getRelativeTransformOrigin(event, rect) {
  const eventCoordinates = getEventCoordinates(event);
  if (!eventCoordinates) {
    return "0 0";
  }
  const transformOrigin = {
    x: (eventCoordinates.x - rect.left) / rect.width * 100,
    y: (eventCoordinates.y - rect.top) / rect.height * 100
  };
  return transformOrigin.x + "% " + transformOrigin.y + "%";
}
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a3
    }
  } = _ref;
  let {
    data: {
      value: b3
    }
  } = _ref2;
  return a3 - b3;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a3
    }
  } = _ref3;
  let {
    data: {
      value: b3
    }
  } = _ref4;
  return b3 - a3;
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return property ? firstCollision[property] : firstCollision;
}
function centerOfRectangle(rect, left2, top2) {
  if (left2 === void 0) {
    left2 = rect.left;
  }
  if (top2 === void 0) {
    top2 = rect.top;
  }
  return {
    x: left2 + rect.width * 0.5,
    y: top2 + rect.height * 0.5
  };
}
var closestCenter = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
function getIntersectionRatio(entry, target) {
  const top2 = Math.max(target.top, entry.top);
  const left2 = Math.max(target.left, entry.left);
  const right2 = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom2 = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right2 - left2;
  const height = bottom2 - top2;
  if (left2 < right2 && top2 < bottom2) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
var rectIntersection = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > 0) {
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }
  return collisions.sort(sortCollisionsDesc);
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
var getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x4 = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y3 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w4 = scaleX ? rect.width / scaleX : rect.width;
  const h3 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w4,
    height: h3,
    top: y3,
    right: x4 + w4,
    bottom: y3 + h3,
    left: x4
  };
}
var defaultOptions = {
  ignoreTransform: false
};
function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      getComputedStyle: getComputedStyle2
    } = getWindow(element);
    const {
      transform,
      transformOrigin
    } = getComputedStyle2(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }
  const {
    top: top2,
    left: left2,
    width,
    height,
    bottom: bottom2,
    right: right2
  } = rect;
  return {
    top: top2,
    left: left2,
    width,
    height,
    bottom: bottom2,
    right: right2
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(node).getComputedStyle(node);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties2 = ["overflow", "overflowX", "overflowY"];
  return properties2.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node) || isSVGElement(node)) {
      return scrollParents;
    }
    if (scrollParents.includes(node)) {
      return scrollParents;
    }
    const {
      getComputedStyle: getComputedStyle2
    } = getWindow(node);
    const computedStyle = getComputedStyle2(node);
    if (node !== element) {
      if (isScrollable(node, computedStyle)) {
        scrollParents.push(node);
      }
    }
    if (isFixed(node, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode2(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
var Direction2;
(function(Direction3) {
  Direction3[Direction3["Forward"] = 1] = "Forward";
  Direction3[Direction3["Backward"] = -1] = "Backward";
})(Direction2 || (Direction2 = {}));
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  } = _ref;
  if (acceleration === void 0) {
    acceleration = 10;
  }
  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top2 <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction2.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top2) / threshold.height);
  } else if (!isBottom && bottom2 >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction2.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom2) / threshold.height);
  }
  if (!isRight && right2 >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction2.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right2) / threshold.width);
  } else if (!isLeft && left2 <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction2.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left2) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth: innerWidth2,
      innerHeight: innerHeight2
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth2,
      bottom: innerHeight2,
      width: innerWidth2,
      height: innerHeight2
    };
  }
  const {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  } = element.getBoundingClientRect();
  return {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollXCoordinate(node);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollYCoordinate(node);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom2 <= 0 || right2 <= 0 || top2 >= window.innerHeight || left2 >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
var properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
var Rect = class {
  constructor(rect, element) {
    this.rect = void 0;
    this.width = void 0;
    this.height = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.right = void 0;
    this.left = void 0;
    const scrollableAncestors = getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = {
      ...rect
    };
    this.width = rect.width;
    this.height = rect.height;
    for (const [axis, keys, getScrollOffset] of properties) {
      for (const key2 of keys) {
        Object.defineProperty(this, key2, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key2] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }
    Object.defineProperty(this, "rect", {
      enumerable: false
    });
  }
};
var Listeners = class {
  constructor(target) {
    this.target = void 0;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
    this.target = target;
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
};
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
})(KeyboardCode || (KeyboardCode = {}));
var defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};
var defaultKeyboardCoordinateGetter = (event, _ref) => {
  let {
    currentCoordinates
  } = _ref;
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
var KeyboardSensor = class {
  constructor(props) {
    this.props = void 0;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = void 0;
    this.listeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node = activeNode.node.current;
    if (node) {
      scrollIntoViewIfNeeded(node);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const {
        collisionRect
      } = context.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }
            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }
            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }
            break;
          }
        }
        this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
};
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;
      if (activator && event.target !== activator) {
        return false;
      }
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
var AbstractPointerSensor = class {
  constructor(props, events2, listenerTarget) {
    var _getEventCoordinates;
    if (listenerTarget === void 0) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }
    this.props = void 0;
    this.events = void 0;
    this.autoScrollEnabled = true;
    this.document = void 0;
    this.activated = false;
    this.initialCoordinates = void 0;
    this.timeoutId = null;
    this.listeners = void 0;
    this.documentListeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    this.events = events2;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow(target));
    this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    var _getEventCoordinates2;
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
        return;
      }
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }
  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
};
var events = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
var PointerSensor = class extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }
};
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
var MouseSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
};
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$2 = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
var TouchSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
};
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order: order2 = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = _2({
    x: 0,
    y: 0
  });
  const scrollDirection = _2({
    x: 0,
    y: 0
  });
  const rect = F(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = _2(null);
  const autoScroll = T2(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = F(() => order2 === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order2, scrollableAncestors]);
  h2(() => {
    if (!enabled || !scrollableAncestors.length || !rect) {
      clearAutoScrollInterval();
      return;
    }
    for (const scrollContainer of sortedScrollableAncestors) {
      if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
        continue;
      }
      const index = scrollableAncestors.indexOf(scrollContainer);
      const scrollContainerRect = scrollableAncestorRects[index];
      if (!scrollContainerRect) {
        continue;
      }
      const {
        direction,
        speed
      } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
      for (const axis of ["x", "y"]) {
        if (!scrollIntent[axis][direction[axis]]) {
          speed[axis] = 0;
          direction[axis] = 0;
        }
      }
      if (speed.x > 0 || speed.y > 0) {
        clearAutoScrollInterval();
        scrollContainerRef.current = scrollContainer;
        setAutoScrollInterval(autoScroll, interval);
        scrollSpeed.current = speed;
        scrollDirection.current = direction;
        return;
      }
    }
    scrollSpeed.current = {
      x: 0,
      y: 0
    };
    scrollDirection.current = {
      x: 0,
      y: 0
    };
    clearAutoScrollInterval();
  }, [
    acceleration,
    autoScroll,
    canScroll,
    clearAutoScrollInterval,
    enabled,
    interval,
    JSON.stringify(rect),
    JSON.stringify(scrollIntent),
    setAutoScrollInterval,
    scrollableAncestors,
    sortedScrollableAncestors,
    scrollableAncestorRects,
    JSON.stringify(threshold)
  ]);
}
var defaultScrollIntent = {
  x: {
    [Direction2.Backward]: false,
    [Direction2.Forward]: false
  },
  y: {
    [Direction2.Backward]: false,
    [Direction2.Forward]: false
  }
};
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious2(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction2.Backward]: previousIntent.x[Direction2.Backward] || direction.x === -1,
        [Direction2.Forward]: previousIntent.x[Direction2.Forward] || direction.x === 1
      },
      y: {
        [Direction2.Backward]: previousIntent.y[Direction2.Backward] || direction.y === -1,
        [Direction2.Forward]: previousIntent.y[Direction2.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id) {
  const draggableNode = id !== null ? draggableNodes.get(id) : void 0;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id === null) {
      return null;
    }
    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return F(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
var defaultValue = /* @__PURE__ */ new Map();
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [containerIdsScheduledForMeasurement, setContainerIdsScheduledForMeasurement] = p2(null);
  const measuringScheduled = containerIdsScheduledForMeasurement != null;
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = _2(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = T2(function(ids3) {
    if (ids3 === void 0) {
      ids3 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setContainerIdsScheduledForMeasurement((value) => value ? value.concat(ids3) : ids3);
  }, [disabledRef]);
  const timeoutId = _2(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    const ids3 = containerIdsScheduledForMeasurement;
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || ids3 != null) {
      const map = /* @__PURE__ */ new Map();
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (ids3 && ids3.length > 0 && !ids3.includes(container.id) && container.rect.current) {
          map.set(container.id, container.rect.current);
          continue;
        }
        const node = container.node.current;
        const rect = node ? new Rect(measure(node), node) : null;
        container.rect.current = rect;
        if (rect) {
          map.set(container.id, rect);
        }
      }
      return map;
    }
    return previousValue;
  }, [containers, containerIdsScheduledForMeasurement, dragging, disabled, measure]);
  h2(() => {
    containersRef.current = containers;
  }, [containers]);
  h2(() => {
    if (disabled) {
      return;
    }
    requestAnimationFrame(() => measureDroppableContainers());
  }, [dragging, disabled]);
  h2(() => {
    if (measuringScheduled) {
      setContainerIdsScheduledForMeasurement(null);
    }
  }, [measuringScheduled]);
  h2(() => {
    if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
      return;
    }
    timeoutId.current = setTimeout(() => {
      measureDroppableContainers();
      timeoutId.current = null;
    }, frequency);
  }, [frequency, disabled, measureDroppableContainers, ...dependencies]);
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node, measure) {
  return useInitialValue(node, measure);
}
function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = useEvent(callback);
  const mutationObserver = F(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return void 0;
    }
    const {
      MutationObserver
    } = window;
    return new MutationObserver(handleMutations);
  }, [handleMutations, disabled]);
  h2(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = useEvent(callback);
  const resizeObserver = F(() => {
    if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
      return void 0;
    }
    const {
      ResizeObserver
    } = window;
    return new ResizeObserver(handleResize);
  }, [disabled]);
  h2(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }
  const [rect, measureRect] = y2(reducer2, null);
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver({
    callback: measureRect
  });
  useIsomorphicLayoutEffect(() => {
    measureRect();
    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
  function reducer2(currentRect) {
    if (!element) {
      return null;
    }
    if (element.isConnected === false) {
      var _ref;
      return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
    }
    const newRect = measure(element);
    if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
      return currentRect;
    }
    return newRect;
  }
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
var defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = _2(node);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node);
  }, [node]);
  h2(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = p2(null);
  const prevElements = _2(elements);
  const handleScroll = T2((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  h2(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return F(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  const initialScrollOffsets = _2(null);
  h2(() => {
    initialScrollOffsets.current = null;
  }, dependencies);
  h2(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  h2(() => {
    if (!canUseDOM) {
      return;
    }
    const teardownFns = sensors.map((_ref) => {
      let {
        sensor
      } = _ref;
      return sensor.setup == null ? void 0 : sensor.setup();
    });
    return () => {
      for (const teardown of teardownFns) {
        teardown == null ? void 0 : teardown();
      }
    };
  }, sensors.map((_ref2) => {
    let {
      sensor
    } = _ref2;
    return sensor;
  }));
}
function useSyntheticListeners(listeners, id) {
  return F(() => {
    return listeners.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;
      acc[eventName] = (event) => {
        handler(event, id);
      };
      return acc;
    }, {});
  }, [listeners, id]);
}
function useWindowRect(element) {
  return F(() => element ? getWindowClientRect(element) : null, [element]);
}
var defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
  const [rects, measureRects] = y2(reducer2, defaultValue$2);
  const resizeObserver = useResizeObserver({
    callback: measureRects
  });
  if (elements.length > 0 && rects === defaultValue$2) {
    measureRects();
  }
  useIsomorphicLayoutEffect(() => {
    if (elements.length) {
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
    }
  }, [elements]);
  return rects;
  function reducer2() {
    if (!elements.length) {
      return defaultValue$2;
    }
    return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
  }
}
function getMeasurableNode(node) {
  if (!node) {
    return null;
  }
  if (node.children.length > 1) {
    return node;
  }
  const firstChild = node.children[0];
  return isHTMLElement(firstChild) ? firstChild : node;
}
function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = p2(null);
  const handleResize = T2((entries) => {
    for (const {
      target
    } of entries) {
      if (isHTMLElement(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver({
    callback: handleResize
  });
  const handleNodeChange = T2((element) => {
    const node = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    if (node) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node);
    }
    setRect(node ? measure(node) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return F(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}
var defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
var defaultData = {
  current: {}
};
var defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};
var DroppableContainersMap = class extends Map {
  get(id) {
    var _super$get;
    return id != null ? (_super$get = super.get(id)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((_ref) => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }
  getNodeFor(id) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
};
var defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop,
  windowRect: null,
  measuringScheduled: false
};
var defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: noop,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: noop
};
var InternalContext = /* @__PURE__ */ B(defaultInternalContext);
var PublicContext = /* @__PURE__ */ B(defaultPublicContext);
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id,
        key: key2,
        disabled
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id,
        key: key2
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = q2(InternalContext);
  const previousActivatorEvent = usePrevious2(activatorEvent);
  const previousActiveId = usePrevious2(active == null ? void 0 : active.id);
  h2(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node
      } = draggableNode;
      if (!activatorNode.current && !node.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config) {
  return F(() => ({
    draggable: {
      ...defaultMeasuringConfiguration.draggable,
      ...config == null ? void 0 : config.draggable
    },
    droppable: {
      ...defaultMeasuringConfiguration.droppable,
      ...config == null ? void 0 : config.droppable
    },
    dragOverlay: {
      ...defaultMeasuringConfiguration.dragOverlay,
      ...config == null ? void 0 : config.dragOverlay
    }
  }), [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]);
}
function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = _2(false);
  const {
    x: x4,
    y: y3
  } = typeof config === "boolean" ? {
    x: config,
    y: config
  } : config;
  useIsomorphicLayoutEffect(() => {
    const disabled = !x4 && !y3;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node = activeNode == null ? void 0 : activeNode.node.current;
    if (!node || node.isConnected === false) {
      return;
    }
    const rect = measure(node);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x4) {
      rectDelta.x = 0;
    }
    if (!y3) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x4, y3, initialRect, measure]);
}
var ActiveDraggableContext = /* @__PURE__ */ B({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;
(function(Status2) {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
var DndContext = /* @__PURE__ */ R(function DndContext2(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
  let {
    id,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = y2(reducer, void 0, getInitialState);
  const [state, dispatch] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = p2(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId ? draggableNodes.get(activeId) : null;
  const activeRects = _2({
    initial: null,
    translated: null
  });
  const active = F(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = _2(null);
  const [activeSensor, setActiveSensor] = p2(null);
  const [activatorEvent, setActivatorEvent] = p2(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId("DndDescribedBy", id);
  const enabledDroppableContainers = F(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate.x, translate.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = F(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = _2({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  });
  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
  const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors);
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors);
  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = getFirstCollision(collisions, "id");
  const [over, setOver] = p2(null);
  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const instantiateSensor = T2((event, _ref2) => {
    let {
      sensor: Sensor,
      options
    } = _ref2;
    if (activeRef.current == null) {
      return;
    }
    const activeNode2 = draggableNodes.get(activeRef.current);
    if (!activeNode2) {
      return;
    }
    const activatorEvent2 = event.nativeEvent;
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode: activeNode2,
      event: activatorEvent2,
      options,
      context: sensorContext,
      onStart(initialCoordinates) {
        const id2 = activeRef.current;
        if (id2 == null) {
          return;
        }
        const draggableNode = draggableNodes.get(id2);
        if (!draggableNode) {
          return;
        }
        const {
          onDragStart
        } = latestProps.current;
        const event2 = {
          active: {
            id: id2,
            data: draggableNode.data,
            rect: activeRects
          }
        };
        sn(() => {
          onDragStart == null ? void 0 : onDragStart(event2);
          setStatus(Status.Initializing);
          dispatch({
            type: Action.DragStart,
            initialCoordinates,
            active: id2
          });
          dispatchMonitorEvent({
            type: "onDragStart",
            event: event2
          });
        });
      },
      onMove(coordinates) {
        dispatch({
          type: Action.DragMove,
          coordinates
        });
      },
      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    sn(() => {
      setActiveSensor(sensorInstance);
      setActivatorEvent(event.nativeEvent);
    });
    function createHandler(type) {
      return async function handler() {
        const {
          active: active2,
          collisions: collisions2,
          over: over2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        let event2 = null;
        if (active2 && scrollAdjustedTranslate2) {
          const {
            cancelDrop
          } = latestProps.current;
          event2 = {
            activatorEvent: activatorEvent2,
            active: active2,
            collisions: collisions2,
            delta: scrollAdjustedTranslate2,
            over: over2
          };
          if (type === Action.DragEnd && typeof cancelDrop === "function") {
            const shouldCancel = await Promise.resolve(cancelDrop(event2));
            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }
        activeRef.current = null;
        sn(() => {
          dispatch({
            type
          });
          setStatus(Status.Uninitialized);
          setOver(null);
          setActiveSensor(null);
          setActivatorEvent(null);
          const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
          if (event2) {
            const handler2 = latestProps.current[eventName];
            handler2 == null ? void 0 : handler2(event2);
            dispatchMonitorEvent({
              type: eventName,
              event: event2
            });
          }
        });
      };
    }
  }, [draggableNodes]);
  const bindActivatorToSensorInstantiator = T2((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active2);
      if (activeRef.current !== null || !activeDraggableNode || nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event, sensor.options, activationContext);
      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  h2(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      over: over2
    } = sensorContext.current;
    if (!active2 || !activatorEvent2) {
      return;
    }
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    sn(() => {
      onDragMove == null ? void 0 : onDragMove(event);
      dispatchMonitorEvent({
        type: "onDragMove",
        event
      });
    });
  }, [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  h2(() => {
    const {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      droppableContainers: droppableContainers2,
      scrollAdjustedTranslate: scrollAdjustedTranslate2
    } = sensorContext.current;
    if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
      return;
    }
    const {
      onDragOver
    } = latestProps.current;
    const overContainer = droppableContainers2.get(overId);
    const over2 = overContainer && overContainer.rect.current ? {
      id: overContainer.id,
      rect: overContainer.rect.current,
      data: overContainer.data,
      disabled: overContainer.disabled
    } : null;
    const event = {
      active: active2,
      activatorEvent: activatorEvent2,
      collisions: collisions2,
      delta: {
        x: scrollAdjustedTranslate2.x,
        y: scrollAdjustedTranslate2.y
      },
      over: over2
    };
    sn(() => {
      setOver(over2);
      onDragOver == null ? void 0 : onDragOver(event);
      dispatchMonitorEvent({
        type: "onDragOver",
        event
      });
    });
  }, [overId]);
  useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({
    ...autoScrollOptions,
    delta: translate,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = F(() => {
    const context = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = F(() => {
    const context = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return bn.createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, bn.createElement(InternalContext.Provider, {
    value: internalContext
  }, bn.createElement(PublicContext.Provider, {
    value: publicContext
  }, bn.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), bn.createElement(RestoreFocus, {
    disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
  })), bn.createElement(Accessibility, {
    ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
var NullContext = /* @__PURE__ */ B(null);
var defaultRole = "button";
var ID_PREFIX = "Droppable";
function useDraggable(_ref) {
  let {
    id,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key2 = useUniqueId(ID_PREFIX);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = q2(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id;
  const transform = q2(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect(() => {
    draggableNodes.set(id, {
      id,
      key: key2,
      node,
      activatorNode,
      data: dataRef
    });
    return () => {
      const node2 = draggableNodes.get(id);
      if (node2 && node2.key === key2) {
        draggableNodes.delete(id);
      }
    };
  }, [draggableNodes, id]);
  const memoizedAttributes = F(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return q2(PublicContext);
}
var ID_PREFIX$1 = "Droppable";
var defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id,
    resizeObserverConfig
  } = _ref;
  const key2 = useUniqueId(ID_PREFIX$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = q2(InternalContext);
  const previous = _2({
    disabled
  });
  const resizeObserverConnected = _2(false);
  const rect = _2(null);
  const callbackId = _2(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids3 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
  const handleResize = T2(() => {
    if (!resizeObserverConnected.current) {
      resizeObserverConnected.current = true;
      return;
    }
    if (callbackId.current != null) {
      clearTimeout(callbackId.current);
    }
    callbackId.current = setTimeout(() => {
      measureDroppableContainers(Array.isArray(ids3.current) ? ids3.current : [ids3.current]);
      callbackId.current = null;
    }, resizeObserverTimeout);
  }, [resizeObserverTimeout]);
  const resizeObserver = useResizeObserver({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = T2((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  h2(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: Action.RegisterDroppable,
      element: {
        id,
        key: key2,
        disabled,
        node: nodeRef,
        rect,
        data: dataRef
      }
    });
    return () => dispatch({
      type: Action.UnregisterDroppable,
      key: key2,
      id
    });
  }, [id]);
  h2(() => {
    if (disabled !== previous.current.disabled) {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        key: key2,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id, key2, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function AnimationManager(_ref) {
  let {
    animation,
    children
  } = _ref;
  const [clonedChildren, setClonedChildren] = p2(null);
  const [element, setElement] = p2(null);
  const previousChildren = usePrevious2(children);
  if (!children && !clonedChildren && previousChildren) {
    setClonedChildren(previousChildren);
  }
  useIsomorphicLayoutEffect(() => {
    if (!element) {
      return;
    }
    const key2 = clonedChildren == null ? void 0 : clonedChildren.key;
    const id = clonedChildren == null ? void 0 : clonedChildren.props.id;
    if (key2 == null || id == null) {
      setClonedChildren(null);
      return;
    }
    Promise.resolve(animation(id, element)).then(() => {
      setClonedChildren(null);
    });
  }, [animation, clonedChildren, element]);
  return bn.createElement(bn.Fragment, null, children, clonedChildren ? cn(clonedChildren, {
    ref: setElement
  }) : null);
}
var defaultTransform = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function NullifiedContextProvider(_ref) {
  let {
    children
  } = _ref;
  return bn.createElement(InternalContext.Provider, {
    value: defaultInternalContext
  }, bn.createElement(ActiveDraggableContext.Provider, {
    value: defaultTransform
  }, children));
}
var baseStyles = {
  position: "fixed",
  touchAction: "none"
};
var defaultTransition = (activatorEvent) => {
  const isKeyboardActivator = isKeyboardEvent(activatorEvent);
  return isKeyboardActivator ? "transform 250ms ease" : void 0;
};
var PositionedOverlay = /* @__PURE__ */ k3((_ref, ref) => {
  let {
    as,
    activatorEvent,
    adjustScale: adjustScale2,
    children,
    className,
    rect,
    style,
    transform,
    transition = defaultTransition
  } = _ref;
  if (!rect) {
    return null;
  }
  const scaleAdjustedTransform = adjustScale2 ? transform : {
    ...transform,
    scaleX: 1,
    scaleY: 1
  };
  const styles = {
    ...baseStyles,
    width: rect.width,
    height: rect.height,
    top: rect.top,
    left: rect.left,
    transform: CSS.Transform.toString(scaleAdjustedTransform),
    transformOrigin: adjustScale2 && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : void 0,
    transition: typeof transition === "function" ? transition(activatorEvent) : transition,
    ...style
  };
  return bn.createElement(as, {
    className,
    style: styles,
    ref
  }, children);
});
var defaultDropAnimationSideEffects = (options) => (_ref) => {
  let {
    active,
    dragOverlay
  } = _ref;
  const originalStyles = {};
  const {
    styles,
    className
  } = options;
  if (styles != null && styles.active) {
    for (const [key2, value] of Object.entries(styles.active)) {
      if (value === void 0) {
        continue;
      }
      originalStyles[key2] = active.node.style.getPropertyValue(key2);
      active.node.style.setProperty(key2, value);
    }
  }
  if (styles != null && styles.dragOverlay) {
    for (const [key2, value] of Object.entries(styles.dragOverlay)) {
      if (value === void 0) {
        continue;
      }
      dragOverlay.node.style.setProperty(key2, value);
    }
  }
  if (className != null && className.active) {
    active.node.classList.add(className.active);
  }
  if (className != null && className.dragOverlay) {
    dragOverlay.node.classList.add(className.dragOverlay);
  }
  return function cleanup() {
    for (const [key2, value] of Object.entries(originalStyles)) {
      active.node.style.setProperty(key2, value);
    }
    if (className != null && className.active) {
      active.node.classList.remove(className.active);
    }
  };
};
var defaultKeyframeResolver = (_ref2) => {
  let {
    transform: {
      initial,
      final
    }
  } = _ref2;
  return [{
    transform: CSS.Transform.toString(initial)
  }, {
    transform: CSS.Transform.toString(final)
  }];
};
var defaultDropAnimationConfiguration = {
  duration: 250,
  easing: "ease",
  keyframes: defaultKeyframeResolver,
  sideEffects: /* @__PURE__ */ defaultDropAnimationSideEffects({
    styles: {
      active: {
        opacity: "0"
      }
    }
  })
};
function useDropAnimation(_ref3) {
  let {
    config,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  } = _ref3;
  return useEvent((id, node) => {
    if (config === null) {
      return;
    }
    const activeDraggable = draggableNodes.get(id);
    if (!activeDraggable) {
      return;
    }
    const activeNode = activeDraggable.node.current;
    if (!activeNode) {
      return;
    }
    const measurableNode = getMeasurableNode(node);
    if (!measurableNode) {
      return;
    }
    const {
      transform
    } = getWindow(node).getComputedStyle(node);
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return;
    }
    const animation = typeof config === "function" ? config : createDefaultDropAnimation(config);
    scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);
    return animation({
      active: {
        id,
        data: activeDraggable.data,
        node: activeNode,
        rect: measuringConfiguration.draggable.measure(activeNode)
      },
      draggableNodes,
      dragOverlay: {
        node,
        rect: measuringConfiguration.dragOverlay.measure(measurableNode)
      },
      droppableContainers,
      measuringConfiguration,
      transform: parsedTransform
    });
  });
}
function createDefaultDropAnimation(options) {
  const {
    duration,
    easing,
    sideEffects,
    keyframes
  } = {
    ...defaultDropAnimationConfiguration,
    ...options
  };
  return (_ref4) => {
    let {
      active,
      dragOverlay,
      transform,
      ...rest
    } = _ref4;
    if (!duration) {
      return;
    }
    const delta = {
      x: dragOverlay.rect.left - active.rect.left,
      y: dragOverlay.rect.top - active.rect.top
    };
    const scale = {
      scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,
      scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1
    };
    const finalTransform = {
      x: transform.x - delta.x,
      y: transform.y - delta.y,
      ...scale
    };
    const animationKeyframes = keyframes({
      ...rest,
      active,
      dragOverlay,
      transform: {
        initial: transform,
        final: finalTransform
      }
    });
    const [firstKeyframe] = animationKeyframes;
    const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];
    if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {
      return;
    }
    const cleanup = sideEffects == null ? void 0 : sideEffects({
      active,
      dragOverlay,
      ...rest
    });
    const animation = dragOverlay.node.animate(animationKeyframes, {
      duration,
      easing,
      fill: "forwards"
    });
    return new Promise((resolve) => {
      animation.onfinish = () => {
        cleanup == null ? void 0 : cleanup();
        resolve();
      };
    });
  };
}
var key = 0;
function useKey(id) {
  return F(() => {
    if (id == null) {
      return;
    }
    key++;
    return key;
  }, [id]);
}
var DragOverlay = /* @__PURE__ */ bn.memo((_ref) => {
  let {
    adjustScale: adjustScale2 = false,
    children,
    dropAnimation: dropAnimationConfig,
    style,
    transition,
    modifiers,
    wrapperElement = "div",
    className,
    zIndex = 999
  } = _ref;
  const {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggableNodes,
    droppableContainers,
    dragOverlay,
    over,
    measuringConfiguration,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  } = useDndContext();
  const transform = q2(ActiveDraggableContext);
  const key2 = useKey(active == null ? void 0 : active.id);
  const modifiedTransform = applyModifiers(modifiers, {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect: dragOverlay.rect,
    over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    transform,
    windowRect
  });
  const initialRect = useInitialValue(activeNodeRect);
  const dropAnimation = useDropAnimation({
    config: dropAnimationConfig,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  });
  const ref = initialRect ? dragOverlay.setRef : void 0;
  return bn.createElement(NullifiedContextProvider, null, bn.createElement(AnimationManager, {
    animation: dropAnimation
  }, active && key2 ? bn.createElement(PositionedOverlay, {
    key: key2,
    id: active.id,
    ref,
    as: wrapperElement,
    activatorEvent,
    adjustScale: adjustScale2,
    className,
    transition,
    rect: initialRect,
    style: {
      zIndex,
      ...style
    },
    transform: modifiedTransform
  }, children) : null));
});

// node_modules/@dnd-kit/sortable/node_modules/@dnd-kit/utilities/dist/utilities.esm.js
function useCombinedRefs(...refs) {
  return F(() => (node) => {
    refs.forEach((ref) => ref(node));
  }, refs);
}
var canUseDOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow2(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode3(node) {
  return "nodeType" in node;
}
function getWindow2(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow2(target)) {
    return target;
  }
  if (!isNode3(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
var useIsomorphicLayoutEffect2 = canUseDOM2 ? s2 : h2;
var ids2 = {};
function useUniqueId2(prefix, value) {
  return F(() => {
    if (value) {
      return value;
    }
    const id = ids2[prefix] == null ? 0 : ids2[prefix] + 1;
    ids2[prefix] = id;
    return `${prefix}-${id}`;
  }, [prefix, value]);
}
function isKeyboardEvent2(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow2(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}
var CSS2 = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x4,
        y: y3
      } = transform;
      return `translate3d(${x4 ? Math.round(x4) : 0}px, ${y3 ? Math.round(y3) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX,
        scaleY
      } = transform;
      return `scaleX(${scaleX}) scaleY(${scaleY})`;
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS2.Translate.toString(transform), CSS2.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString({
      property,
      duration,
      easing
    }) {
      return `${property} ${duration}ms ${easing}`;
    }
  }
});

// node_modules/@dnd-kit/sortable/dist/sortable.esm.js
function arrayMove(array, from, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index) => {
    const rect = rects.get(id);
    if (rect) {
      accumulator[index] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index) {
  return index !== null && index >= 0;
}
function itemsEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (a3.length !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < a3.length; i3++) {
    if (a3[i3] !== b3[i3]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
var rectSortingStrategy = (_ref) => {
  let {
    rects,
    activeIndex,
    overIndex,
    index
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index];
  const newRect = newRects[index];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
var defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
var verticalListSortingStrategy = (_ref) => {
  var _rects$activeIndex;
  let {
    activeIndex,
    activeNodeRect: fallbackActiveRect,
    index,
    rects,
    overIndex
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index === activeIndex) {
    const overIndexRect = rects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
      ...defaultScale$1
    };
  }
  const itemGap = getItemGap$1(rects, index, activeIndex);
  if (index > activeIndex && index <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }
  if (index < activeIndex && index >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};
function getItemGap$1(clientRects, index, activeIndex) {
  const currentRect = clientRects[index];
  const previousRect = clientRects[index - 1];
  const nextRect = clientRects[index + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
var ID_PREFIX2 = "Sortable";
var Context = /* @__PURE__ */ bn.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX2,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers,
    measuringScheduled
  } = useDndContext();
  const containerId = useUniqueId2(ID_PREFIX2, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = F(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = _2(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect2(() => {
    if (itemsHaveChanged && isDragging && !measuringScheduled) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers, measuringScheduled]);
  h2(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = F(() => ({
    activeIndex,
    containerId,
    disabled,
    disableTransforms,
    items,
    overIndex,
    useDragOverlay,
    sortedRects: getSortedRects(items, droppableRects),
    strategy
  }), [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);
  return bn.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var defaultNewIndexGetter = (_ref) => {
  let {
    id,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id);
};
var defaultAnimateLayoutChanges = (_ref2) => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition
  } = _ref2;
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index && containerId === previousContainerId;
};
var defaultTransition2 = {
  duration: 200,
  easing: "ease"
};
var transitionProperty = "transform";
var disabledTransition = /* @__PURE__ */ CSS2.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
var defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform(_ref) {
  let {
    disabled,
    index,
    node,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = p2(null);
  const previousIndex = _2(index);
  useIsomorphicLayoutEffect2(() => {
    if (!disabled && index !== previousIndex.current && node.current) {
      const initial = rect.current;
      if (initial) {
        const current = getClientRect(node.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current.left,
          y: initial.top - current.top,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index !== previousIndex.current) {
      previousIndex.current = index;
    }
  }, [disabled, index, node, rect]);
  h2(() => {
    if (derivedTransform) {
      requestAnimationFrame(() => {
        setDerivedtransform(null);
      });
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges: animateLayoutChanges2 = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition2
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = q2(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index = items.indexOf(id);
  const data = F(() => ({
    sortable: {
      containerId,
      index,
      items
    },
    ...customData
  }), [containerId, customData, index, items]);
  const itemsAfterCurrentSortable = F(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index;
  const activeId = active == null ? void 0 : active.id;
  const previous = _2({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges2({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index,
    node,
    rect
  });
  h2(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }
    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }
    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  h2(() => {
    if (activeId === previous.current.activeId) {
      return;
    }
    if (activeId && !previous.current.activeId) {
      previous.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (derivedTransform || itemsHaveChanged && previous.current.newIndex === index) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent2(activatorEvent) || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS2.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
var directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];

// src/components/Spaces/TreeView/FolderTreeView.tsx
var import_classnames2 = __toESM(require_classnames());

// src/hooks/useLongPress.tsx
function isMouseEvent(e3) {
  return e3 && "screenX" in e3;
}

// src/components/Spaces/TreeView/SectionView.tsx
var import_obsidian5 = require("obsidian");
var import_classnames = __toESM(require_classnames());
var SectionItem = k3(({
  childCount,
  clone,
  data,
  depth,
  disableSelection,
  disableInteraction,
  ghost,
  handleProps,
  indentationWidth,
  indicator,
  collapsed,
  style,
  onCollapse,
  wrapperRef,
  plugin,
  disabled
}, ref) => {
  const [sections2, setSections] = Recoil_index_14(sections);
  const [focusedFolder2, setFocusedFolder] = Recoil_index_14(focusedFolder);
  const section = sections2.find((s3, i3) => {
    return i3 == data.section;
  });
  const newFolderInSection = () => {
    let vaultChangeModal = new VaultChangeModal(plugin, focusedFolder2, "create folder", data.section);
    vaultChangeModal.open();
  };
  const newFileInSection = async () => {
    const newFile = await createNewMarkdownFile(plugin.app, focusedFolder2, "");
    if (data.section != -1)
      updateSections(sections2.map((f4, i3) => {
        return i3 == data.section ? {
          ...f4,
          children: [newFile.path, ...f4.children]
        } : f4;
      }));
  };
  const updateSections = (sections3) => {
    plugin.settings.spaces = sections3;
    plugin.saveSettings();
  };
  const triggerMenu = (e3) => {
    data.section == -1 ? triggerVaultMenu(e3) : triggerSectionMenu(data.name, data.index, e3);
  };
  const triggerSectionMenu = (section2, index, e3) => {
    const fileMenu = new import_obsidian5.Menu();
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.edit);
      menuItem.setIcon("pencil");
      menuItem.onClick((ev) => {
        let vaultChangeModal = new SectionChangeModal(plugin, section2, index, "rename");
        vaultChangeModal.open();
      });
    });
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.delete);
      menuItem.setIcon("trash");
      menuItem.onClick((ev) => {
        updateSections(sections2.filter((s3, i3) => {
          return i3 != index;
        }));
      });
    });
    if (isMouseEvent(e3)) {
      fileMenu.showAtPosition({ x: e3.pageX, y: e3.pageY });
    } else {
      fileMenu.showAtPosition({ x: e3.nativeEvent.locationX, y: e3.nativeEvent.locationY });
    }
    return false;
  };
  const triggerVaultMenu = (e3) => {
    const fileMenu = new import_obsidian5.Menu();
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.newSpace);
      menuItem.setIcon("plus");
      menuItem.onClick((ev) => {
        let vaultChangeModal = new SectionChangeModal(plugin, "", 0, "create");
        vaultChangeModal.open();
      });
      if (isMouseEvent(e3)) {
        fileMenu.showAtPosition({ x: e3.pageX, y: e3.pageY });
      } else {
        fileMenu.showAtPosition({ x: e3.nativeEvent.locationX, y: e3.nativeEvent.locationY });
      }
      return false;
    });
  };
  return /* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement("div", {
    className: (0, import_classnames.default)("mk-tree-wrapper", "mk-section-wrapper", clone && "mk-clone", ghost && "mk-ghost", disableSelection && "mk-disable-selection", disableInteraction && "mk-disable-interaction"),
    ref: wrapperRef,
    style: {
      ...style,
      ...indicator ? { "--spacing": `${indentationWidth * depth}px` } : {}
    }
  }, /* @__PURE__ */ bn.createElement("div", {
    className: (0, import_classnames.default)("mk-section", indicator ? indicator.state == 2 /* Bottom */ ? "mk-indicator-bottom" : indicator.state == 1 /* Top */ ? "mk-indicator-top" : indicator.state == 3 /* Row */ ? "mk-indicator-row" : "" : "")
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-section-title",
    onContextMenu: (e3) => triggerMenu(e3),
    onClick: (e3) => onCollapse(data),
    ref,
    ...handleProps
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-tree-text"
  }, data.id == "/" ? plugin.app.vault.getName() : data.name), /* @__PURE__ */ bn.createElement("div", {
    className: `mk-collapse ${collapsed ? "mk-collapsed" : ""}`,
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-collapse-sm"] }
  })), /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-buttons"
  }, /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.createFolder,
    onClick: () => {
      newFolderInSection();
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-new-folder"] }
  }), /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.newNote,
    onClick: () => {
      newFileInSection();
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-new-note"] }
  })))), section && !collapsed && section.children.length == 0 && /* @__PURE__ */ bn.createElement("div", {
    className: "mk-tree-empty",
    style: {
      "--spacing": `${indentationWidth}px`
    }
  }, "No Notes Inside"));
});
SectionItem.displayName = "SectionItem";

// src/components/StickerMenu/emojis/default.ts
var emojis = { "smileys_people": [{ "n": ["grinning", "grinning face"], "u": "1f600" }, { "n": ["smiley", "smiling face with open mouth"], "u": "1f603" }, { "n": ["smile", "smiling face with open mouth and smiling eyes"], "u": "1f604" }, { "n": ["grin", "grinning face with smiling eyes"], "u": "1f601" }, { "n": ["laughing", "satisfied", "smiling face with open mouth and tightly-closed eyes"], "u": "1f606" }, { "n": ["sweat smile", "smiling face with open mouth and cold sweat"], "u": "1f605" }, { "n": ["rolling on the floor laughing"], "u": "1f923" }, { "n": ["joy", "face with tears of joy"], "u": "1f602" }, { "n": ["slightly smiling face"], "u": "1f642" }, { "n": ["upside-down face", "upside down face"], "u": "1f643" }, { "n": ["melting face"], "u": "1fae0" }, { "n": ["wink", "winking face"], "u": "1f609" }, { "n": ["blush", "smiling face with smiling eyes"], "u": "1f60a" }, { "n": ["innocent", "smiling face with halo"], "u": "1f607" }, { "n": ["smiling face with 3 hearts", "smiling face with smiling eyes and three hearts"], "u": "1f970" }, { "n": ["heart eyes", "smiling face with heart-shaped eyes"], "u": "1f60d" }, { "n": ["star-struck", "grinning face with star eyes"], "u": "1f929" }, { "n": ["kissing heart", "face throwing a kiss"], "u": "1f618" }, { "n": ["kissing", "kissing face"], "u": "1f617" }, { "n": ["relaxed", "white smiling face"], "u": "263a-fe0f" }, { "n": ["kissing closed eyes", "kissing face with closed eyes"], "u": "1f61a" }, { "n": ["kissing smiling eyes", "kissing face with smiling eyes"], "u": "1f619" }, { "n": ["smiling face with tear"], "u": "1f972" }, { "n": ["yum", "face savouring delicious food"], "u": "1f60b" }, { "n": ["stuck out tongue", "face with stuck-out tongue"], "u": "1f61b" }, { "n": ["stuck out tongue winking eye", "face with stuck-out tongue and winking eye"], "u": "1f61c" }, { "n": ["zany face", "grinning face with one large and one small eye"], "u": "1f92a" }, { "n": ["stuck out tongue closed eyes", "face with stuck-out tongue and tightly-closed eyes"], "u": "1f61d" }, { "n": ["money-mouth face", "money mouth face"], "u": "1f911" }, { "n": ["hugging face"], "u": "1f917" }, { "n": ["face with hand over mouth", "smiling face with smiling eyes and hand covering mouth"], "u": "1f92d" }, { "n": ["face with open eyes and hand over mouth"], "u": "1fae2" }, { "n": ["face with peeking eye"], "u": "1fae3" }, { "n": ["shushing face", "face with finger covering closed lips"], "u": "1f92b" }, { "n": ["thinking face"], "u": "1f914" }, { "n": ["saluting face"], "u": "1fae1" }, { "n": ["zipper-mouth face", "zipper mouth face"], "u": "1f910" }, { "n": ["face with raised eyebrow", "face with one eyebrow raised"], "u": "1f928" }, { "n": ["neutral face"], "u": "1f610" }, { "n": ["expressionless", "expressionless face"], "u": "1f611" }, { "n": ["no mouth", "face without mouth"], "u": "1f636" }, { "n": ["dotted line face"], "u": "1fae5" }, { "n": ["face in clouds"], "u": "1f636-200d-1f32b-fe0f" }, { "n": ["smirk", "smirking face"], "u": "1f60f" }, { "n": ["unamused", "unamused face"], "u": "1f612" }, { "n": ["face with rolling eyes"], "u": "1f644" }, { "n": ["grimacing", "grimacing face"], "u": "1f62c" }, { "n": ["face exhaling"], "u": "1f62e-200d-1f4a8" }, { "n": ["lying face"], "u": "1f925" }, { "n": ["relieved", "relieved face"], "u": "1f60c" }, { "n": ["pensive", "pensive face"], "u": "1f614" }, { "n": ["sleepy", "sleepy face"], "u": "1f62a" }, { "n": ["drooling face"], "u": "1f924" }, { "n": ["sleeping", "sleeping face"], "u": "1f634" }, { "n": ["mask", "face with medical mask"], "u": "1f637" }, { "n": ["face with thermometer"], "u": "1f912" }, { "n": ["face with head-bandage", "face with head bandage"], "u": "1f915" }, { "n": ["nauseated face"], "u": "1f922" }, { "n": ["face vomiting", "face with open mouth vomiting"], "u": "1f92e" }, { "n": ["sneezing face"], "u": "1f927" }, { "n": ["hot face", "overheated face"], "u": "1f975" }, { "n": ["cold face", "freezing face"], "u": "1f976" }, { "n": ["woozy face", "face with uneven eyes and wavy mouth"], "u": "1f974" }, { "n": ["dizzy face"], "u": "1f635" }, { "n": ["face with spiral eyes"], "u": "1f635-200d-1f4ab" }, { "n": ["exploding head", "shocked face with exploding head"], "u": "1f92f" }, { "n": ["face with cowboy hat"], "u": "1f920" }, { "n": ["partying face", "face with party horn and party hat"], "u": "1f973" }, { "n": ["disguised face"], "u": "1f978" }, { "n": ["sunglasses", "smiling face with sunglasses"], "u": "1f60e" }, { "n": ["nerd face"], "u": "1f913" }, { "n": ["face with monocle"], "u": "1f9d0" }, { "n": ["confused", "confused face"], "u": "1f615" }, { "n": ["face with diagonal mouth"], "u": "1fae4" }, { "n": ["worried", "worried face"], "u": "1f61f" }, { "n": ["slightly frowning face"], "u": "1f641" }, { "n": ["frowning face", "white frowning face"], "u": "2639-fe0f" }, { "n": ["open mouth", "face with open mouth"], "u": "1f62e" }, { "n": ["hushed", "hushed face"], "u": "1f62f" }, { "n": ["astonished", "astonished face"], "u": "1f632" }, { "n": ["flushed", "flushed face"], "u": "1f633" }, { "n": ["pleading face", "face with pleading eyes"], "u": "1f97a" }, { "n": ["face holding back tears"], "u": "1f979" }, { "n": ["frowning", "frowning face with open mouth"], "u": "1f626" }, { "n": ["anguished", "anguished face"], "u": "1f627" }, { "n": ["fearful", "fearful face"], "u": "1f628" }, { "n": ["cold sweat", "face with open mouth and cold sweat"], "u": "1f630" }, { "n": ["disappointed relieved", "disappointed but relieved face"], "u": "1f625" }, { "n": ["cry", "crying face"], "u": "1f622" }, { "n": ["sob", "loudly crying face"], "u": "1f62d" }, { "n": ["scream", "face screaming in fear"], "u": "1f631" }, { "n": ["confounded", "confounded face"], "u": "1f616" }, { "n": ["persevere", "persevering face"], "u": "1f623" }, { "n": ["disappointed", "disappointed face"], "u": "1f61e" }, { "n": ["sweat", "face with cold sweat"], "u": "1f613" }, { "n": ["weary", "weary face"], "u": "1f629" }, { "n": ["tired face"], "u": "1f62b" }, { "n": ["yawning face"], "u": "1f971" }, { "n": ["triumph", "face with look of triumph"], "u": "1f624" }, { "n": ["rage", "pouting face"], "u": "1f621" }, { "n": ["angry", "angry face"], "u": "1f620" }, { "n": ["face with symbols on mouth", "serious face with symbols covering mouth"], "u": "1f92c" }, { "n": ["smiling imp", "smiling face with horns"], "u": "1f608" }, { "n": ["imp"], "u": "1f47f" }, { "n": ["skull"], "u": "1f480" }, { "n": ["skull and crossbones"], "u": "2620-fe0f" }, { "n": ["poop", "shit", "hankey", "pile of poo"], "u": "1f4a9" }, { "n": ["clown face"], "u": "1f921" }, { "n": ["japanese ogre"], "u": "1f479" }, { "n": ["japanese goblin"], "u": "1f47a" }, { "n": ["ghost"], "u": "1f47b" }, { "n": ["alien", "extraterrestrial alien"], "u": "1f47d" }, { "n": ["alien monster", "space invader"], "u": "1f47e" }, { "n": ["robot face"], "u": "1f916" }, { "n": ["smiley cat", "smiling cat face with open mouth"], "u": "1f63a" }, { "n": ["smile cat", "grinning cat face with smiling eyes"], "u": "1f638" }, { "n": ["joy cat", "cat face with tears of joy"], "u": "1f639" }, { "n": ["heart eyes cat", "smiling cat face with heart-shaped eyes"], "u": "1f63b" }, { "n": ["smirk cat", "cat face with wry smile"], "u": "1f63c" }, { "n": ["kissing cat", "kissing cat face with closed eyes"], "u": "1f63d" }, { "n": ["scream cat", "weary cat face"], "u": "1f640" }, { "n": ["crying cat face"], "u": "1f63f" }, { "n": ["pouting cat", "pouting cat face"], "u": "1f63e" }, { "n": ["see no evil", "see-no-evil monkey"], "u": "1f648" }, { "n": ["hear no evil", "hear-no-evil monkey"], "u": "1f649" }, { "n": ["speak no evil", "speak-no-evil monkey"], "u": "1f64a" }, { "n": ["kiss", "kiss mark"], "u": "1f48b" }, { "n": ["love letter"], "u": "1f48c" }, { "n": ["cupid", "heart with arrow"], "u": "1f498" }, { "n": ["gift heart", "heart with ribbon"], "u": "1f49d" }, { "n": ["sparkling heart"], "u": "1f496" }, { "n": ["heartpulse", "growing heart"], "u": "1f497" }, { "n": ["heartbeat", "beating heart"], "u": "1f493" }, { "n": ["revolving hearts"], "u": "1f49e" }, { "n": ["two hearts"], "u": "1f495" }, { "n": ["heart decoration"], "u": "1f49f" }, { "n": ["heart exclamation", "heavy heart exclamation mark ornament"], "u": "2763-fe0f" }, { "n": ["broken heart"], "u": "1f494" }, { "n": ["heart on fire"], "u": "2764-fe0f-200d-1f525" }, { "n": ["mending heart"], "u": "2764-fe0f-200d-1fa79" }, { "n": ["heart", "heavy black heart"], "u": "2764-fe0f" }, { "n": ["orange heart"], "u": "1f9e1" }, { "n": ["yellow heart"], "u": "1f49b" }, { "n": ["green heart"], "u": "1f49a" }, { "n": ["blue heart"], "u": "1f499" }, { "n": ["purple heart"], "u": "1f49c" }, { "n": ["brown heart"], "u": "1f90e" }, { "n": ["black heart"], "u": "1f5a4" }, { "n": ["white heart"], "u": "1f90d" }, { "n": ["100", "hundred points symbol"], "u": "1f4af" }, { "n": ["anger", "anger symbol"], "u": "1f4a2" }, { "n": ["boom", "collision", "collision symbol"], "u": "1f4a5" }, { "n": ["dizzy", "dizzy symbol"], "u": "1f4ab" }, { "n": ["sweat drops", "splashing sweat symbol"], "u": "1f4a6" }, { "n": ["dash", "dash symbol"], "u": "1f4a8" }, { "n": ["hole"], "u": "1f573-fe0f" }, { "n": ["bomb"], "u": "1f4a3" }, { "n": ["speech balloon"], "u": "1f4ac" }, { "n": ["eye in speech bubble", "eye-in-speech-bubble"], "u": "1f441-fe0f-200d-1f5e8-fe0f" }, { "n": ["left speech bubble"], "u": "1f5e8-fe0f" }, { "n": ["right anger bubble"], "u": "1f5ef-fe0f" }, { "n": ["thought balloon"], "u": "1f4ad" }, { "n": ["zzz", "sleeping symbol"], "u": "1f4a4" }, { "n": ["wave", "waving hand sign"], "u": "1f44b", "v": ["1f44b-1f3fb", "1f44b-1f3fc", "1f44b-1f3fd", "1f44b-1f3fe", "1f44b-1f3ff"] }, { "n": ["raised back of hand"], "u": "1f91a", "v": ["1f91a-1f3fb", "1f91a-1f3fc", "1f91a-1f3fd", "1f91a-1f3fe", "1f91a-1f3ff"] }, { "n": ["hand with fingers splayed", "raised hand with fingers splayed"], "u": "1f590-fe0f", "v": ["1f590-1f3fb", "1f590-1f3fc", "1f590-1f3fd", "1f590-1f3fe", "1f590-1f3ff"] }, { "n": ["hand", "raised hand"], "u": "270b", "v": ["270b-1f3fb", "270b-1f3fc", "270b-1f3fd", "270b-1f3fe", "270b-1f3ff"] }, { "n": ["spock-hand", "raised hand with part between middle and ring fingers"], "u": "1f596", "v": ["1f596-1f3fb", "1f596-1f3fc", "1f596-1f3fd", "1f596-1f3fe", "1f596-1f3ff"] }, { "n": ["rightwards hand"], "u": "1faf1", "v": ["1faf1-1f3fb", "1faf1-1f3fc", "1faf1-1f3fd", "1faf1-1f3fe", "1faf1-1f3ff"] }, { "n": ["leftwards hand"], "u": "1faf2", "v": ["1faf2-1f3fb", "1faf2-1f3fc", "1faf2-1f3fd", "1faf2-1f3fe", "1faf2-1f3ff"] }, { "n": ["palm down hand"], "u": "1faf3", "v": ["1faf3-1f3fb", "1faf3-1f3fc", "1faf3-1f3fd", "1faf3-1f3fe", "1faf3-1f3ff"] }, { "n": ["palm up hand"], "u": "1faf4", "v": ["1faf4-1f3fb", "1faf4-1f3fc", "1faf4-1f3fd", "1faf4-1f3fe", "1faf4-1f3ff"] }, { "n": ["ok hand", "ok hand sign"], "u": "1f44c", "v": ["1f44c-1f3fb", "1f44c-1f3fc", "1f44c-1f3fd", "1f44c-1f3fe", "1f44c-1f3ff"] }, { "n": ["pinched fingers"], "u": "1f90c", "v": ["1f90c-1f3fb", "1f90c-1f3fc", "1f90c-1f3fd", "1f90c-1f3fe", "1f90c-1f3ff"] }, { "n": ["pinching hand"], "u": "1f90f", "v": ["1f90f-1f3fb", "1f90f-1f3fc", "1f90f-1f3fd", "1f90f-1f3fe", "1f90f-1f3ff"] }, { "n": ["v", "victory hand"], "u": "270c-fe0f", "v": ["270c-1f3fb", "270c-1f3fc", "270c-1f3fd", "270c-1f3fe", "270c-1f3ff"] }, { "n": ["crossed fingers", "hand with index and middle fingers crossed"], "u": "1f91e", "v": ["1f91e-1f3fb", "1f91e-1f3fc", "1f91e-1f3fd", "1f91e-1f3fe", "1f91e-1f3ff"] }, { "n": ["hand with index finger and thumb crossed"], "u": "1faf0", "v": ["1faf0-1f3fb", "1faf0-1f3fc", "1faf0-1f3fd", "1faf0-1f3fe", "1faf0-1f3ff"] }, { "n": ["i love you hand sign"], "u": "1f91f", "v": ["1f91f-1f3fb", "1f91f-1f3fc", "1f91f-1f3fd", "1f91f-1f3fe", "1f91f-1f3ff"] }, { "n": ["the horns", "sign of the horns"], "u": "1f918", "v": ["1f918-1f3fb", "1f918-1f3fc", "1f918-1f3fd", "1f918-1f3fe", "1f918-1f3ff"] }, { "n": ["call me hand"], "u": "1f919", "v": ["1f919-1f3fb", "1f919-1f3fc", "1f919-1f3fd", "1f919-1f3fe", "1f919-1f3ff"] }, { "n": ["point left", "white left pointing backhand index"], "u": "1f448", "v": ["1f448-1f3fb", "1f448-1f3fc", "1f448-1f3fd", "1f448-1f3fe", "1f448-1f3ff"] }, { "n": ["point right", "white right pointing backhand index"], "u": "1f449", "v": ["1f449-1f3fb", "1f449-1f3fc", "1f449-1f3fd", "1f449-1f3fe", "1f449-1f3ff"] }, { "n": ["point up 2", "white up pointing backhand index"], "u": "1f446", "v": ["1f446-1f3fb", "1f446-1f3fc", "1f446-1f3fd", "1f446-1f3fe", "1f446-1f3ff"] }, { "n": ["middle finger", "reversed hand with middle finger extended"], "u": "1f595", "v": ["1f595-1f3fb", "1f595-1f3fc", "1f595-1f3fd", "1f595-1f3fe", "1f595-1f3ff"] }, { "n": ["point down", "white down pointing backhand index"], "u": "1f447", "v": ["1f447-1f3fb", "1f447-1f3fc", "1f447-1f3fd", "1f447-1f3fe", "1f447-1f3ff"] }, { "n": ["point up", "white up pointing index"], "u": "261d-fe0f", "v": ["261d-1f3fb", "261d-1f3fc", "261d-1f3fd", "261d-1f3fe", "261d-1f3ff"] }, { "n": ["index pointing at the viewer"], "u": "1faf5", "v": ["1faf5-1f3fb", "1faf5-1f3fc", "1faf5-1f3fd", "1faf5-1f3fe", "1faf5-1f3ff"] }, { "n": ["+1", "thumbsup", "thumbs up sign"], "u": "1f44d", "v": ["1f44d-1f3fb", "1f44d-1f3fc", "1f44d-1f3fd", "1f44d-1f3fe", "1f44d-1f3ff"] }, { "n": ["-1", "thumbsdown", "thumbs down sign"], "u": "1f44e", "v": ["1f44e-1f3fb", "1f44e-1f3fc", "1f44e-1f3fd", "1f44e-1f3fe", "1f44e-1f3ff"] }, { "n": ["fist", "raised fist"], "u": "270a", "v": ["270a-1f3fb", "270a-1f3fc", "270a-1f3fd", "270a-1f3fe", "270a-1f3ff"] }, { "n": ["punch", "facepunch", "fisted hand sign"], "u": "1f44a", "v": ["1f44a-1f3fb", "1f44a-1f3fc", "1f44a-1f3fd", "1f44a-1f3fe", "1f44a-1f3ff"] }, { "n": ["left-facing fist"], "u": "1f91b", "v": ["1f91b-1f3fb", "1f91b-1f3fc", "1f91b-1f3fd", "1f91b-1f3fe", "1f91b-1f3ff"] }, { "n": ["right-facing fist"], "u": "1f91c", "v": ["1f91c-1f3fb", "1f91c-1f3fc", "1f91c-1f3fd", "1f91c-1f3fe", "1f91c-1f3ff"] }, { "n": ["clap", "clapping hands sign"], "u": "1f44f", "v": ["1f44f-1f3fb", "1f44f-1f3fc", "1f44f-1f3fd", "1f44f-1f3fe", "1f44f-1f3ff"] }, { "n": ["raised hands", "person raising both hands in celebration"], "u": "1f64c", "v": ["1f64c-1f3fb", "1f64c-1f3fc", "1f64c-1f3fd", "1f64c-1f3fe", "1f64c-1f3ff"] }, { "n": ["heart hands"], "u": "1faf6", "v": ["1faf6-1f3fb", "1faf6-1f3fc", "1faf6-1f3fd", "1faf6-1f3fe", "1faf6-1f3ff"] }, { "n": ["open hands", "open hands sign"], "u": "1f450", "v": ["1f450-1f3fb", "1f450-1f3fc", "1f450-1f3fd", "1f450-1f3fe", "1f450-1f3ff"] }, { "n": ["palms up together"], "u": "1f932", "v": ["1f932-1f3fb", "1f932-1f3fc", "1f932-1f3fd", "1f932-1f3fe", "1f932-1f3ff"] }, { "n": ["handshake"], "u": "1f91d", "v": ["1f91d-1f3fb", "1f91d-1f3fc", "1f91d-1f3fd", "1f91d-1f3fe", "1f91d-1f3ff", "1faf1-1f3fb-200d-1faf2-1f3fc", "1faf1-1f3fb-200d-1faf2-1f3fd", "1faf1-1f3fb-200d-1faf2-1f3fe", "1faf1-1f3fb-200d-1faf2-1f3ff", "1faf1-1f3fc-200d-1faf2-1f3fb", "1faf1-1f3fc-200d-1faf2-1f3fd", "1faf1-1f3fc-200d-1faf2-1f3fe", "1faf1-1f3fc-200d-1faf2-1f3ff", "1faf1-1f3fd-200d-1faf2-1f3fb", "1faf1-1f3fd-200d-1faf2-1f3fc", "1faf1-1f3fd-200d-1faf2-1f3fe", "1faf1-1f3fd-200d-1faf2-1f3ff", "1faf1-1f3fe-200d-1faf2-1f3fb", "1faf1-1f3fe-200d-1faf2-1f3fc", "1faf1-1f3fe-200d-1faf2-1f3fd", "1faf1-1f3fe-200d-1faf2-1f3ff", "1faf1-1f3ff-200d-1faf2-1f3fb", "1faf1-1f3ff-200d-1faf2-1f3fc", "1faf1-1f3ff-200d-1faf2-1f3fd", "1faf1-1f3ff-200d-1faf2-1f3fe"] }, { "n": ["pray", "person with folded hands"], "u": "1f64f", "v": ["1f64f-1f3fb", "1f64f-1f3fc", "1f64f-1f3fd", "1f64f-1f3fe", "1f64f-1f3ff"] }, { "n": ["writing hand"], "u": "270d-fe0f", "v": ["270d-1f3fb", "270d-1f3fc", "270d-1f3fd", "270d-1f3fe", "270d-1f3ff"] }, { "n": ["nail care", "nail polish"], "u": "1f485", "v": ["1f485-1f3fb", "1f485-1f3fc", "1f485-1f3fd", "1f485-1f3fe", "1f485-1f3ff"] }, { "n": ["selfie"], "u": "1f933", "v": ["1f933-1f3fb", "1f933-1f3fc", "1f933-1f3fd", "1f933-1f3fe", "1f933-1f3ff"] }, { "n": ["muscle", "flexed biceps"], "u": "1f4aa", "v": ["1f4aa-1f3fb", "1f4aa-1f3fc", "1f4aa-1f3fd", "1f4aa-1f3fe", "1f4aa-1f3ff"] }, { "n": ["mechanical arm"], "u": "1f9be" }, { "n": ["mechanical leg"], "u": "1f9bf" }, { "n": ["leg"], "u": "1f9b5", "v": ["1f9b5-1f3fb", "1f9b5-1f3fc", "1f9b5-1f3fd", "1f9b5-1f3fe", "1f9b5-1f3ff"] }, { "n": ["foot"], "u": "1f9b6", "v": ["1f9b6-1f3fb", "1f9b6-1f3fc", "1f9b6-1f3fd", "1f9b6-1f3fe", "1f9b6-1f3ff"] }, { "n": ["ear"], "u": "1f442", "v": ["1f442-1f3fb", "1f442-1f3fc", "1f442-1f3fd", "1f442-1f3fe", "1f442-1f3ff"] }, { "n": ["ear with hearing aid"], "u": "1f9bb", "v": ["1f9bb-1f3fb", "1f9bb-1f3fc", "1f9bb-1f3fd", "1f9bb-1f3fe", "1f9bb-1f3ff"] }, { "n": ["nose"], "u": "1f443", "v": ["1f443-1f3fb", "1f443-1f3fc", "1f443-1f3fd", "1f443-1f3fe", "1f443-1f3ff"] }, { "n": ["brain"], "u": "1f9e0" }, { "n": ["anatomical heart"], "u": "1fac0" }, { "n": ["lungs"], "u": "1fac1" }, { "n": ["tooth"], "u": "1f9b7" }, { "n": ["bone"], "u": "1f9b4" }, { "n": ["eyes"], "u": "1f440" }, { "n": ["eye"], "u": "1f441-fe0f" }, { "n": ["tongue"], "u": "1f445" }, { "n": ["lips", "mouth"], "u": "1f444" }, { "n": ["biting lip"], "u": "1fae6" }, { "n": ["baby"], "u": "1f476", "v": ["1f476-1f3fb", "1f476-1f3fc", "1f476-1f3fd", "1f476-1f3fe", "1f476-1f3ff"] }, { "n": ["child"], "u": "1f9d2", "v": ["1f9d2-1f3fb", "1f9d2-1f3fc", "1f9d2-1f3fd", "1f9d2-1f3fe", "1f9d2-1f3ff"] }, { "n": ["boy"], "u": "1f466", "v": ["1f466-1f3fb", "1f466-1f3fc", "1f466-1f3fd", "1f466-1f3fe", "1f466-1f3ff"] }, { "n": ["girl"], "u": "1f467", "v": ["1f467-1f3fb", "1f467-1f3fc", "1f467-1f3fd", "1f467-1f3fe", "1f467-1f3ff"] }, { "n": ["adult"], "u": "1f9d1", "v": ["1f9d1-1f3fb", "1f9d1-1f3fc", "1f9d1-1f3fd", "1f9d1-1f3fe", "1f9d1-1f3ff"] }, { "n": ["person with blond hair"], "u": "1f471", "v": ["1f471-1f3fb", "1f471-1f3fc", "1f471-1f3fd", "1f471-1f3fe", "1f471-1f3ff"] }, { "n": ["man"], "u": "1f468", "v": ["1f468-1f3fb", "1f468-1f3fc", "1f468-1f3fd", "1f468-1f3fe", "1f468-1f3ff"] }, { "n": ["bearded person"], "u": "1f9d4", "v": ["1f9d4-1f3fb", "1f9d4-1f3fc", "1f9d4-1f3fd", "1f9d4-1f3fe", "1f9d4-1f3ff"] }, { "n": ["man: beard", "man with beard"], "u": "1f9d4-200d-2642-fe0f", "v": ["1f9d4-1f3fb-200d-2642-fe0f", "1f9d4-1f3fc-200d-2642-fe0f", "1f9d4-1f3fd-200d-2642-fe0f", "1f9d4-1f3fe-200d-2642-fe0f", "1f9d4-1f3ff-200d-2642-fe0f"] }, { "n": ["woman: beard", "woman with beard"], "u": "1f9d4-200d-2640-fe0f", "v": ["1f9d4-1f3fb-200d-2640-fe0f", "1f9d4-1f3fc-200d-2640-fe0f", "1f9d4-1f3fd-200d-2640-fe0f", "1f9d4-1f3fe-200d-2640-fe0f", "1f9d4-1f3ff-200d-2640-fe0f"] }, { "n": ["man: red hair", "red haired man"], "u": "1f468-200d-1f9b0", "v": ["1f468-1f3fb-200d-1f9b0", "1f468-1f3fc-200d-1f9b0", "1f468-1f3fd-200d-1f9b0", "1f468-1f3fe-200d-1f9b0", "1f468-1f3ff-200d-1f9b0"] }, { "n": ["man: curly hair", "curly haired man"], "u": "1f468-200d-1f9b1", "v": ["1f468-1f3fb-200d-1f9b1", "1f468-1f3fc-200d-1f9b1", "1f468-1f3fd-200d-1f9b1", "1f468-1f3fe-200d-1f9b1", "1f468-1f3ff-200d-1f9b1"] }, { "n": ["man: white hair", "white haired man"], "u": "1f468-200d-1f9b3", "v": ["1f468-1f3fb-200d-1f9b3", "1f468-1f3fc-200d-1f9b3", "1f468-1f3fd-200d-1f9b3", "1f468-1f3fe-200d-1f9b3", "1f468-1f3ff-200d-1f9b3"] }, { "n": ["bald man", "man: bald"], "u": "1f468-200d-1f9b2", "v": ["1f468-1f3fb-200d-1f9b2", "1f468-1f3fc-200d-1f9b2", "1f468-1f3fd-200d-1f9b2", "1f468-1f3fe-200d-1f9b2", "1f468-1f3ff-200d-1f9b2"] }, { "n": ["woman"], "u": "1f469", "v": ["1f469-1f3fb", "1f469-1f3fc", "1f469-1f3fd", "1f469-1f3fe", "1f469-1f3ff"] }, { "n": ["woman: red hair", "red haired woman"], "u": "1f469-200d-1f9b0", "v": ["1f469-1f3fb-200d-1f9b0", "1f469-1f3fc-200d-1f9b0", "1f469-1f3fd-200d-1f9b0", "1f469-1f3fe-200d-1f9b0", "1f469-1f3ff-200d-1f9b0"] }, { "n": ["person: red hair", "red haired person"], "u": "1f9d1-200d-1f9b0", "v": ["1f9d1-1f3fb-200d-1f9b0", "1f9d1-1f3fc-200d-1f9b0", "1f9d1-1f3fd-200d-1f9b0", "1f9d1-1f3fe-200d-1f9b0", "1f9d1-1f3ff-200d-1f9b0"] }, { "n": ["woman: curly hair", "curly haired woman"], "u": "1f469-200d-1f9b1", "v": ["1f469-1f3fb-200d-1f9b1", "1f469-1f3fc-200d-1f9b1", "1f469-1f3fd-200d-1f9b1", "1f469-1f3fe-200d-1f9b1", "1f469-1f3ff-200d-1f9b1"] }, { "n": ["person: curly hair", "curly haired person"], "u": "1f9d1-200d-1f9b1", "v": ["1f9d1-1f3fb-200d-1f9b1", "1f9d1-1f3fc-200d-1f9b1", "1f9d1-1f3fd-200d-1f9b1", "1f9d1-1f3fe-200d-1f9b1", "1f9d1-1f3ff-200d-1f9b1"] }, { "n": ["woman: white hair", "white haired woman"], "u": "1f469-200d-1f9b3", "v": ["1f469-1f3fb-200d-1f9b3", "1f469-1f3fc-200d-1f9b3", "1f469-1f3fd-200d-1f9b3", "1f469-1f3fe-200d-1f9b3", "1f469-1f3ff-200d-1f9b3"] }, { "n": ["person: white hair", "white haired person"], "u": "1f9d1-200d-1f9b3", "v": ["1f9d1-1f3fb-200d-1f9b3", "1f9d1-1f3fc-200d-1f9b3", "1f9d1-1f3fd-200d-1f9b3", "1f9d1-1f3fe-200d-1f9b3", "1f9d1-1f3ff-200d-1f9b3"] }, { "n": ["bald woman", "woman: bald"], "u": "1f469-200d-1f9b2", "v": ["1f469-1f3fb-200d-1f9b2", "1f469-1f3fc-200d-1f9b2", "1f469-1f3fd-200d-1f9b2", "1f469-1f3fe-200d-1f9b2", "1f469-1f3ff-200d-1f9b2"] }, { "n": ["bald person", "person: bald"], "u": "1f9d1-200d-1f9b2", "v": ["1f9d1-1f3fb-200d-1f9b2", "1f9d1-1f3fc-200d-1f9b2", "1f9d1-1f3fd-200d-1f9b2", "1f9d1-1f3fe-200d-1f9b2", "1f9d1-1f3ff-200d-1f9b2"] }, { "n": ["woman: blond hair", "blond-haired-woman"], "u": "1f471-200d-2640-fe0f", "v": ["1f471-1f3fb-200d-2640-fe0f", "1f471-1f3fc-200d-2640-fe0f", "1f471-1f3fd-200d-2640-fe0f", "1f471-1f3fe-200d-2640-fe0f", "1f471-1f3ff-200d-2640-fe0f"] }, { "n": ["man: blond hair", "blond-haired-man"], "u": "1f471-200d-2642-fe0f", "v": ["1f471-1f3fb-200d-2642-fe0f", "1f471-1f3fc-200d-2642-fe0f", "1f471-1f3fd-200d-2642-fe0f", "1f471-1f3fe-200d-2642-fe0f", "1f471-1f3ff-200d-2642-fe0f"] }, { "n": ["older adult"], "u": "1f9d3", "v": ["1f9d3-1f3fb", "1f9d3-1f3fc", "1f9d3-1f3fd", "1f9d3-1f3fe", "1f9d3-1f3ff"] }, { "n": ["older man"], "u": "1f474", "v": ["1f474-1f3fb", "1f474-1f3fc", "1f474-1f3fd", "1f474-1f3fe", "1f474-1f3ff"] }, { "n": ["older woman"], "u": "1f475", "v": ["1f475-1f3fb", "1f475-1f3fc", "1f475-1f3fd", "1f475-1f3fe", "1f475-1f3ff"] }, { "n": ["person frowning"], "u": "1f64d", "v": ["1f64d-1f3fb", "1f64d-1f3fc", "1f64d-1f3fd", "1f64d-1f3fe", "1f64d-1f3ff"] }, { "n": ["man frowning", "man-frowning"], "u": "1f64d-200d-2642-fe0f", "v": ["1f64d-1f3fb-200d-2642-fe0f", "1f64d-1f3fc-200d-2642-fe0f", "1f64d-1f3fd-200d-2642-fe0f", "1f64d-1f3fe-200d-2642-fe0f", "1f64d-1f3ff-200d-2642-fe0f"] }, { "n": ["woman frowning", "woman-frowning"], "u": "1f64d-200d-2640-fe0f", "v": ["1f64d-1f3fb-200d-2640-fe0f", "1f64d-1f3fc-200d-2640-fe0f", "1f64d-1f3fd-200d-2640-fe0f", "1f64d-1f3fe-200d-2640-fe0f", "1f64d-1f3ff-200d-2640-fe0f"] }, { "n": ["person with pouting face"], "u": "1f64e", "v": ["1f64e-1f3fb", "1f64e-1f3fc", "1f64e-1f3fd", "1f64e-1f3fe", "1f64e-1f3ff"] }, { "n": ["man pouting", "man-pouting"], "u": "1f64e-200d-2642-fe0f", "v": ["1f64e-1f3fb-200d-2642-fe0f", "1f64e-1f3fc-200d-2642-fe0f", "1f64e-1f3fd-200d-2642-fe0f", "1f64e-1f3fe-200d-2642-fe0f", "1f64e-1f3ff-200d-2642-fe0f"] }, { "n": ["woman pouting", "woman-pouting"], "u": "1f64e-200d-2640-fe0f", "v": ["1f64e-1f3fb-200d-2640-fe0f", "1f64e-1f3fc-200d-2640-fe0f", "1f64e-1f3fd-200d-2640-fe0f", "1f64e-1f3fe-200d-2640-fe0f", "1f64e-1f3ff-200d-2640-fe0f"] }, { "n": ["no good", "face with no good gesture"], "u": "1f645", "v": ["1f645-1f3fb", "1f645-1f3fc", "1f645-1f3fd", "1f645-1f3fe", "1f645-1f3ff"] }, { "n": ["man gesturing no", "man-gesturing-no"], "u": "1f645-200d-2642-fe0f", "v": ["1f645-1f3fb-200d-2642-fe0f", "1f645-1f3fc-200d-2642-fe0f", "1f645-1f3fd-200d-2642-fe0f", "1f645-1f3fe-200d-2642-fe0f", "1f645-1f3ff-200d-2642-fe0f"] }, { "n": ["woman gesturing no", "woman-gesturing-no"], "u": "1f645-200d-2640-fe0f", "v": ["1f645-1f3fb-200d-2640-fe0f", "1f645-1f3fc-200d-2640-fe0f", "1f645-1f3fd-200d-2640-fe0f", "1f645-1f3fe-200d-2640-fe0f", "1f645-1f3ff-200d-2640-fe0f"] }, { "n": ["ok woman", "face with ok gesture"], "u": "1f646", "v": ["1f646-1f3fb", "1f646-1f3fc", "1f646-1f3fd", "1f646-1f3fe", "1f646-1f3ff"] }, { "n": ["man gesturing ok", "man-gesturing-ok"], "u": "1f646-200d-2642-fe0f", "v": ["1f646-1f3fb-200d-2642-fe0f", "1f646-1f3fc-200d-2642-fe0f", "1f646-1f3fd-200d-2642-fe0f", "1f646-1f3fe-200d-2642-fe0f", "1f646-1f3ff-200d-2642-fe0f"] }, { "n": ["woman gesturing ok", "woman-gesturing-ok"], "u": "1f646-200d-2640-fe0f", "v": ["1f646-1f3fb-200d-2640-fe0f", "1f646-1f3fc-200d-2640-fe0f", "1f646-1f3fd-200d-2640-fe0f", "1f646-1f3fe-200d-2640-fe0f", "1f646-1f3ff-200d-2640-fe0f"] }, { "n": ["information desk person"], "u": "1f481", "v": ["1f481-1f3fb", "1f481-1f3fc", "1f481-1f3fd", "1f481-1f3fe", "1f481-1f3ff"] }, { "n": ["man tipping hand", "man-tipping-hand"], "u": "1f481-200d-2642-fe0f", "v": ["1f481-1f3fb-200d-2642-fe0f", "1f481-1f3fc-200d-2642-fe0f", "1f481-1f3fd-200d-2642-fe0f", "1f481-1f3fe-200d-2642-fe0f", "1f481-1f3ff-200d-2642-fe0f"] }, { "n": ["woman tipping hand", "woman-tipping-hand"], "u": "1f481-200d-2640-fe0f", "v": ["1f481-1f3fb-200d-2640-fe0f", "1f481-1f3fc-200d-2640-fe0f", "1f481-1f3fd-200d-2640-fe0f", "1f481-1f3fe-200d-2640-fe0f", "1f481-1f3ff-200d-2640-fe0f"] }, { "n": ["raising hand", "happy person raising one hand"], "u": "1f64b", "v": ["1f64b-1f3fb", "1f64b-1f3fc", "1f64b-1f3fd", "1f64b-1f3fe", "1f64b-1f3ff"] }, { "n": ["man raising hand", "man-raising-hand"], "u": "1f64b-200d-2642-fe0f", "v": ["1f64b-1f3fb-200d-2642-fe0f", "1f64b-1f3fc-200d-2642-fe0f", "1f64b-1f3fd-200d-2642-fe0f", "1f64b-1f3fe-200d-2642-fe0f", "1f64b-1f3ff-200d-2642-fe0f"] }, { "n": ["woman raising hand", "woman-raising-hand"], "u": "1f64b-200d-2640-fe0f", "v": ["1f64b-1f3fb-200d-2640-fe0f", "1f64b-1f3fc-200d-2640-fe0f", "1f64b-1f3fd-200d-2640-fe0f", "1f64b-1f3fe-200d-2640-fe0f", "1f64b-1f3ff-200d-2640-fe0f"] }, { "n": ["deaf person"], "u": "1f9cf", "v": ["1f9cf-1f3fb", "1f9cf-1f3fc", "1f9cf-1f3fd", "1f9cf-1f3fe", "1f9cf-1f3ff"] }, { "n": ["deaf man"], "u": "1f9cf-200d-2642-fe0f", "v": ["1f9cf-1f3fb-200d-2642-fe0f", "1f9cf-1f3fc-200d-2642-fe0f", "1f9cf-1f3fd-200d-2642-fe0f", "1f9cf-1f3fe-200d-2642-fe0f", "1f9cf-1f3ff-200d-2642-fe0f"] }, { "n": ["deaf woman"], "u": "1f9cf-200d-2640-fe0f", "v": ["1f9cf-1f3fb-200d-2640-fe0f", "1f9cf-1f3fc-200d-2640-fe0f", "1f9cf-1f3fd-200d-2640-fe0f", "1f9cf-1f3fe-200d-2640-fe0f", "1f9cf-1f3ff-200d-2640-fe0f"] }, { "n": ["bow", "person bowing deeply"], "u": "1f647", "v": ["1f647-1f3fb", "1f647-1f3fc", "1f647-1f3fd", "1f647-1f3fe", "1f647-1f3ff"] }, { "n": ["man bowing", "man-bowing"], "u": "1f647-200d-2642-fe0f", "v": ["1f647-1f3fb-200d-2642-fe0f", "1f647-1f3fc-200d-2642-fe0f", "1f647-1f3fd-200d-2642-fe0f", "1f647-1f3fe-200d-2642-fe0f", "1f647-1f3ff-200d-2642-fe0f"] }, { "n": ["woman bowing", "woman-bowing"], "u": "1f647-200d-2640-fe0f", "v": ["1f647-1f3fb-200d-2640-fe0f", "1f647-1f3fc-200d-2640-fe0f", "1f647-1f3fd-200d-2640-fe0f", "1f647-1f3fe-200d-2640-fe0f", "1f647-1f3ff-200d-2640-fe0f"] }, { "n": ["face palm"], "u": "1f926", "v": ["1f926-1f3fb", "1f926-1f3fc", "1f926-1f3fd", "1f926-1f3fe", "1f926-1f3ff"] }, { "n": ["man facepalming", "man-facepalming"], "u": "1f926-200d-2642-fe0f", "v": ["1f926-1f3fb-200d-2642-fe0f", "1f926-1f3fc-200d-2642-fe0f", "1f926-1f3fd-200d-2642-fe0f", "1f926-1f3fe-200d-2642-fe0f", "1f926-1f3ff-200d-2642-fe0f"] }, { "n": ["woman facepalming", "woman-facepalming"], "u": "1f926-200d-2640-fe0f", "v": ["1f926-1f3fb-200d-2640-fe0f", "1f926-1f3fc-200d-2640-fe0f", "1f926-1f3fd-200d-2640-fe0f", "1f926-1f3fe-200d-2640-fe0f", "1f926-1f3ff-200d-2640-fe0f"] }, { "n": ["shrug"], "u": "1f937", "v": ["1f937-1f3fb", "1f937-1f3fc", "1f937-1f3fd", "1f937-1f3fe", "1f937-1f3ff"] }, { "n": ["man shrugging", "man-shrugging"], "u": "1f937-200d-2642-fe0f", "v": ["1f937-1f3fb-200d-2642-fe0f", "1f937-1f3fc-200d-2642-fe0f", "1f937-1f3fd-200d-2642-fe0f", "1f937-1f3fe-200d-2642-fe0f", "1f937-1f3ff-200d-2642-fe0f"] }, { "n": ["woman shrugging", "woman-shrugging"], "u": "1f937-200d-2640-fe0f", "v": ["1f937-1f3fb-200d-2640-fe0f", "1f937-1f3fc-200d-2640-fe0f", "1f937-1f3fd-200d-2640-fe0f", "1f937-1f3fe-200d-2640-fe0f", "1f937-1f3ff-200d-2640-fe0f"] }, { "n": ["health worker"], "u": "1f9d1-200d-2695-fe0f", "v": ["1f9d1-1f3fb-200d-2695-fe0f", "1f9d1-1f3fc-200d-2695-fe0f", "1f9d1-1f3fd-200d-2695-fe0f", "1f9d1-1f3fe-200d-2695-fe0f", "1f9d1-1f3ff-200d-2695-fe0f"] }, { "n": ["male-doctor", "man health worker"], "u": "1f468-200d-2695-fe0f", "v": ["1f468-1f3fb-200d-2695-fe0f", "1f468-1f3fc-200d-2695-fe0f", "1f468-1f3fd-200d-2695-fe0f", "1f468-1f3fe-200d-2695-fe0f", "1f468-1f3ff-200d-2695-fe0f"] }, { "n": ["female-doctor", "woman health worker"], "u": "1f469-200d-2695-fe0f", "v": ["1f469-1f3fb-200d-2695-fe0f", "1f469-1f3fc-200d-2695-fe0f", "1f469-1f3fd-200d-2695-fe0f", "1f469-1f3fe-200d-2695-fe0f", "1f469-1f3ff-200d-2695-fe0f"] }, { "n": ["student"], "u": "1f9d1-200d-1f393", "v": ["1f9d1-1f3fb-200d-1f393", "1f9d1-1f3fc-200d-1f393", "1f9d1-1f3fd-200d-1f393", "1f9d1-1f3fe-200d-1f393", "1f9d1-1f3ff-200d-1f393"] }, { "n": ["man student", "male-student"], "u": "1f468-200d-1f393", "v": ["1f468-1f3fb-200d-1f393", "1f468-1f3fc-200d-1f393", "1f468-1f3fd-200d-1f393", "1f468-1f3fe-200d-1f393", "1f468-1f3ff-200d-1f393"] }, { "n": ["woman student", "female-student"], "u": "1f469-200d-1f393", "v": ["1f469-1f3fb-200d-1f393", "1f469-1f3fc-200d-1f393", "1f469-1f3fd-200d-1f393", "1f469-1f3fe-200d-1f393", "1f469-1f3ff-200d-1f393"] }, { "n": ["teacher"], "u": "1f9d1-200d-1f3eb", "v": ["1f9d1-1f3fb-200d-1f3eb", "1f9d1-1f3fc-200d-1f3eb", "1f9d1-1f3fd-200d-1f3eb", "1f9d1-1f3fe-200d-1f3eb", "1f9d1-1f3ff-200d-1f3eb"] }, { "n": ["man teacher", "male-teacher"], "u": "1f468-200d-1f3eb", "v": ["1f468-1f3fb-200d-1f3eb", "1f468-1f3fc-200d-1f3eb", "1f468-1f3fd-200d-1f3eb", "1f468-1f3fe-200d-1f3eb", "1f468-1f3ff-200d-1f3eb"] }, { "n": ["woman teacher", "female-teacher"], "u": "1f469-200d-1f3eb", "v": ["1f469-1f3fb-200d-1f3eb", "1f469-1f3fc-200d-1f3eb", "1f469-1f3fd-200d-1f3eb", "1f469-1f3fe-200d-1f3eb", "1f469-1f3ff-200d-1f3eb"] }, { "n": ["judge"], "u": "1f9d1-200d-2696-fe0f", "v": ["1f9d1-1f3fb-200d-2696-fe0f", "1f9d1-1f3fc-200d-2696-fe0f", "1f9d1-1f3fd-200d-2696-fe0f", "1f9d1-1f3fe-200d-2696-fe0f", "1f9d1-1f3ff-200d-2696-fe0f"] }, { "n": ["man judge", "male-judge"], "u": "1f468-200d-2696-fe0f", "v": ["1f468-1f3fb-200d-2696-fe0f", "1f468-1f3fc-200d-2696-fe0f", "1f468-1f3fd-200d-2696-fe0f", "1f468-1f3fe-200d-2696-fe0f", "1f468-1f3ff-200d-2696-fe0f"] }, { "n": ["woman judge", "female-judge"], "u": "1f469-200d-2696-fe0f", "v": ["1f469-1f3fb-200d-2696-fe0f", "1f469-1f3fc-200d-2696-fe0f", "1f469-1f3fd-200d-2696-fe0f", "1f469-1f3fe-200d-2696-fe0f", "1f469-1f3ff-200d-2696-fe0f"] }, { "n": ["farmer"], "u": "1f9d1-200d-1f33e", "v": ["1f9d1-1f3fb-200d-1f33e", "1f9d1-1f3fc-200d-1f33e", "1f9d1-1f3fd-200d-1f33e", "1f9d1-1f3fe-200d-1f33e", "1f9d1-1f3ff-200d-1f33e"] }, { "n": ["man farmer", "male-farmer"], "u": "1f468-200d-1f33e", "v": ["1f468-1f3fb-200d-1f33e", "1f468-1f3fc-200d-1f33e", "1f468-1f3fd-200d-1f33e", "1f468-1f3fe-200d-1f33e", "1f468-1f3ff-200d-1f33e"] }, { "n": ["woman farmer", "female-farmer"], "u": "1f469-200d-1f33e", "v": ["1f469-1f3fb-200d-1f33e", "1f469-1f3fc-200d-1f33e", "1f469-1f3fd-200d-1f33e", "1f469-1f3fe-200d-1f33e", "1f469-1f3ff-200d-1f33e"] }, { "n": ["cook"], "u": "1f9d1-200d-1f373", "v": ["1f9d1-1f3fb-200d-1f373", "1f9d1-1f3fc-200d-1f373", "1f9d1-1f3fd-200d-1f373", "1f9d1-1f3fe-200d-1f373", "1f9d1-1f3ff-200d-1f373"] }, { "n": ["man cook", "male-cook"], "u": "1f468-200d-1f373", "v": ["1f468-1f3fb-200d-1f373", "1f468-1f3fc-200d-1f373", "1f468-1f3fd-200d-1f373", "1f468-1f3fe-200d-1f373", "1f468-1f3ff-200d-1f373"] }, { "n": ["woman cook", "female-cook"], "u": "1f469-200d-1f373", "v": ["1f469-1f3fb-200d-1f373", "1f469-1f3fc-200d-1f373", "1f469-1f3fd-200d-1f373", "1f469-1f3fe-200d-1f373", "1f469-1f3ff-200d-1f373"] }, { "n": ["mechanic"], "u": "1f9d1-200d-1f527", "v": ["1f9d1-1f3fb-200d-1f527", "1f9d1-1f3fc-200d-1f527", "1f9d1-1f3fd-200d-1f527", "1f9d1-1f3fe-200d-1f527", "1f9d1-1f3ff-200d-1f527"] }, { "n": ["man mechanic", "male-mechanic"], "u": "1f468-200d-1f527", "v": ["1f468-1f3fb-200d-1f527", "1f468-1f3fc-200d-1f527", "1f468-1f3fd-200d-1f527", "1f468-1f3fe-200d-1f527", "1f468-1f3ff-200d-1f527"] }, { "n": ["woman mechanic", "female-mechanic"], "u": "1f469-200d-1f527", "v": ["1f469-1f3fb-200d-1f527", "1f469-1f3fc-200d-1f527", "1f469-1f3fd-200d-1f527", "1f469-1f3fe-200d-1f527", "1f469-1f3ff-200d-1f527"] }, { "n": ["factory worker"], "u": "1f9d1-200d-1f3ed", "v": ["1f9d1-1f3fb-200d-1f3ed", "1f9d1-1f3fc-200d-1f3ed", "1f9d1-1f3fd-200d-1f3ed", "1f9d1-1f3fe-200d-1f3ed", "1f9d1-1f3ff-200d-1f3ed"] }, { "n": ["man factory worker", "male-factory-worker"], "u": "1f468-200d-1f3ed", "v": ["1f468-1f3fb-200d-1f3ed", "1f468-1f3fc-200d-1f3ed", "1f468-1f3fd-200d-1f3ed", "1f468-1f3fe-200d-1f3ed", "1f468-1f3ff-200d-1f3ed"] }, { "n": ["woman factory worker", "female-factory-worker"], "u": "1f469-200d-1f3ed", "v": ["1f469-1f3fb-200d-1f3ed", "1f469-1f3fc-200d-1f3ed", "1f469-1f3fd-200d-1f3ed", "1f469-1f3fe-200d-1f3ed", "1f469-1f3ff-200d-1f3ed"] }, { "n": ["office worker"], "u": "1f9d1-200d-1f4bc", "v": ["1f9d1-1f3fb-200d-1f4bc", "1f9d1-1f3fc-200d-1f4bc", "1f9d1-1f3fd-200d-1f4bc", "1f9d1-1f3fe-200d-1f4bc", "1f9d1-1f3ff-200d-1f4bc"] }, { "n": ["man office worker", "male-office-worker"], "u": "1f468-200d-1f4bc", "v": ["1f468-1f3fb-200d-1f4bc", "1f468-1f3fc-200d-1f4bc", "1f468-1f3fd-200d-1f4bc", "1f468-1f3fe-200d-1f4bc", "1f468-1f3ff-200d-1f4bc"] }, { "n": ["woman office worker", "female-office-worker"], "u": "1f469-200d-1f4bc", "v": ["1f469-1f3fb-200d-1f4bc", "1f469-1f3fc-200d-1f4bc", "1f469-1f3fd-200d-1f4bc", "1f469-1f3fe-200d-1f4bc", "1f469-1f3ff-200d-1f4bc"] }, { "n": ["scientist"], "u": "1f9d1-200d-1f52c", "v": ["1f9d1-1f3fb-200d-1f52c", "1f9d1-1f3fc-200d-1f52c", "1f9d1-1f3fd-200d-1f52c", "1f9d1-1f3fe-200d-1f52c", "1f9d1-1f3ff-200d-1f52c"] }, { "n": ["man scientist", "male-scientist"], "u": "1f468-200d-1f52c", "v": ["1f468-1f3fb-200d-1f52c", "1f468-1f3fc-200d-1f52c", "1f468-1f3fd-200d-1f52c", "1f468-1f3fe-200d-1f52c", "1f468-1f3ff-200d-1f52c"] }, { "n": ["woman scientist", "female-scientist"], "u": "1f469-200d-1f52c", "v": ["1f469-1f3fb-200d-1f52c", "1f469-1f3fc-200d-1f52c", "1f469-1f3fd-200d-1f52c", "1f469-1f3fe-200d-1f52c", "1f469-1f3ff-200d-1f52c"] }, { "n": ["technologist"], "u": "1f9d1-200d-1f4bb", "v": ["1f9d1-1f3fb-200d-1f4bb", "1f9d1-1f3fc-200d-1f4bb", "1f9d1-1f3fd-200d-1f4bb", "1f9d1-1f3fe-200d-1f4bb", "1f9d1-1f3ff-200d-1f4bb"] }, { "n": ["man technologist", "male-technologist"], "u": "1f468-200d-1f4bb", "v": ["1f468-1f3fb-200d-1f4bb", "1f468-1f3fc-200d-1f4bb", "1f468-1f3fd-200d-1f4bb", "1f468-1f3fe-200d-1f4bb", "1f468-1f3ff-200d-1f4bb"] }, { "n": ["woman technologist", "female-technologist"], "u": "1f469-200d-1f4bb", "v": ["1f469-1f3fb-200d-1f4bb", "1f469-1f3fc-200d-1f4bb", "1f469-1f3fd-200d-1f4bb", "1f469-1f3fe-200d-1f4bb", "1f469-1f3ff-200d-1f4bb"] }, { "n": ["singer"], "u": "1f9d1-200d-1f3a4", "v": ["1f9d1-1f3fb-200d-1f3a4", "1f9d1-1f3fc-200d-1f3a4", "1f9d1-1f3fd-200d-1f3a4", "1f9d1-1f3fe-200d-1f3a4", "1f9d1-1f3ff-200d-1f3a4"] }, { "n": ["man singer", "male-singer"], "u": "1f468-200d-1f3a4", "v": ["1f468-1f3fb-200d-1f3a4", "1f468-1f3fc-200d-1f3a4", "1f468-1f3fd-200d-1f3a4", "1f468-1f3fe-200d-1f3a4", "1f468-1f3ff-200d-1f3a4"] }, { "n": ["woman singer", "female-singer"], "u": "1f469-200d-1f3a4", "v": ["1f469-1f3fb-200d-1f3a4", "1f469-1f3fc-200d-1f3a4", "1f469-1f3fd-200d-1f3a4", "1f469-1f3fe-200d-1f3a4", "1f469-1f3ff-200d-1f3a4"] }, { "n": ["artist"], "u": "1f9d1-200d-1f3a8", "v": ["1f9d1-1f3fb-200d-1f3a8", "1f9d1-1f3fc-200d-1f3a8", "1f9d1-1f3fd-200d-1f3a8", "1f9d1-1f3fe-200d-1f3a8", "1f9d1-1f3ff-200d-1f3a8"] }, { "n": ["man artist", "male-artist"], "u": "1f468-200d-1f3a8", "v": ["1f468-1f3fb-200d-1f3a8", "1f468-1f3fc-200d-1f3a8", "1f468-1f3fd-200d-1f3a8", "1f468-1f3fe-200d-1f3a8", "1f468-1f3ff-200d-1f3a8"] }, { "n": ["woman artist", "female-artist"], "u": "1f469-200d-1f3a8", "v": ["1f469-1f3fb-200d-1f3a8", "1f469-1f3fc-200d-1f3a8", "1f469-1f3fd-200d-1f3a8", "1f469-1f3fe-200d-1f3a8", "1f469-1f3ff-200d-1f3a8"] }, { "n": ["pilot"], "u": "1f9d1-200d-2708-fe0f", "v": ["1f9d1-1f3fb-200d-2708-fe0f", "1f9d1-1f3fc-200d-2708-fe0f", "1f9d1-1f3fd-200d-2708-fe0f", "1f9d1-1f3fe-200d-2708-fe0f", "1f9d1-1f3ff-200d-2708-fe0f"] }, { "n": ["man pilot", "male-pilot"], "u": "1f468-200d-2708-fe0f", "v": ["1f468-1f3fb-200d-2708-fe0f", "1f468-1f3fc-200d-2708-fe0f", "1f468-1f3fd-200d-2708-fe0f", "1f468-1f3fe-200d-2708-fe0f", "1f468-1f3ff-200d-2708-fe0f"] }, { "n": ["woman pilot", "female-pilot"], "u": "1f469-200d-2708-fe0f", "v": ["1f469-1f3fb-200d-2708-fe0f", "1f469-1f3fc-200d-2708-fe0f", "1f469-1f3fd-200d-2708-fe0f", "1f469-1f3fe-200d-2708-fe0f", "1f469-1f3ff-200d-2708-fe0f"] }, { "n": ["astronaut"], "u": "1f9d1-200d-1f680", "v": ["1f9d1-1f3fb-200d-1f680", "1f9d1-1f3fc-200d-1f680", "1f9d1-1f3fd-200d-1f680", "1f9d1-1f3fe-200d-1f680", "1f9d1-1f3ff-200d-1f680"] }, { "n": ["man astronaut", "male-astronaut"], "u": "1f468-200d-1f680", "v": ["1f468-1f3fb-200d-1f680", "1f468-1f3fc-200d-1f680", "1f468-1f3fd-200d-1f680", "1f468-1f3fe-200d-1f680", "1f468-1f3ff-200d-1f680"] }, { "n": ["woman astronaut", "female-astronaut"], "u": "1f469-200d-1f680", "v": ["1f469-1f3fb-200d-1f680", "1f469-1f3fc-200d-1f680", "1f469-1f3fd-200d-1f680", "1f469-1f3fe-200d-1f680", "1f469-1f3ff-200d-1f680"] }, { "n": ["firefighter"], "u": "1f9d1-200d-1f692", "v": ["1f9d1-1f3fb-200d-1f692", "1f9d1-1f3fc-200d-1f692", "1f9d1-1f3fd-200d-1f692", "1f9d1-1f3fe-200d-1f692", "1f9d1-1f3ff-200d-1f692"] }, { "n": ["man firefighter", "male-firefighter"], "u": "1f468-200d-1f692", "v": ["1f468-1f3fb-200d-1f692", "1f468-1f3fc-200d-1f692", "1f468-1f3fd-200d-1f692", "1f468-1f3fe-200d-1f692", "1f468-1f3ff-200d-1f692"] }, { "n": ["woman firefighter", "female-firefighter"], "u": "1f469-200d-1f692", "v": ["1f469-1f3fb-200d-1f692", "1f469-1f3fc-200d-1f692", "1f469-1f3fd-200d-1f692", "1f469-1f3fe-200d-1f692", "1f469-1f3ff-200d-1f692"] }, { "n": ["cop", "police officer"], "u": "1f46e", "v": ["1f46e-1f3fb", "1f46e-1f3fc", "1f46e-1f3fd", "1f46e-1f3fe", "1f46e-1f3ff"] }, { "n": ["man police officer", "male-police-officer"], "u": "1f46e-200d-2642-fe0f", "v": ["1f46e-1f3fb-200d-2642-fe0f", "1f46e-1f3fc-200d-2642-fe0f", "1f46e-1f3fd-200d-2642-fe0f", "1f46e-1f3fe-200d-2642-fe0f", "1f46e-1f3ff-200d-2642-fe0f"] }, { "n": ["woman police officer", "female-police-officer"], "u": "1f46e-200d-2640-fe0f", "v": ["1f46e-1f3fb-200d-2640-fe0f", "1f46e-1f3fc-200d-2640-fe0f", "1f46e-1f3fd-200d-2640-fe0f", "1f46e-1f3fe-200d-2640-fe0f", "1f46e-1f3ff-200d-2640-fe0f"] }, { "n": ["detective", "sleuth or spy"], "u": "1f575-fe0f", "v": ["1f575-1f3fb", "1f575-1f3fc", "1f575-1f3fd", "1f575-1f3fe", "1f575-1f3ff"] }, { "n": ["man detective", "male-detective"], "u": "1f575-fe0f-200d-2642-fe0f", "v": ["1f575-1f3fb-200d-2642-fe0f", "1f575-1f3fc-200d-2642-fe0f", "1f575-1f3fd-200d-2642-fe0f", "1f575-1f3fe-200d-2642-fe0f", "1f575-1f3ff-200d-2642-fe0f"] }, { "n": ["woman detective", "female-detective"], "u": "1f575-fe0f-200d-2640-fe0f", "v": ["1f575-1f3fb-200d-2640-fe0f", "1f575-1f3fc-200d-2640-fe0f", "1f575-1f3fd-200d-2640-fe0f", "1f575-1f3fe-200d-2640-fe0f", "1f575-1f3ff-200d-2640-fe0f"] }, { "n": ["guardsman"], "u": "1f482", "v": ["1f482-1f3fb", "1f482-1f3fc", "1f482-1f3fd", "1f482-1f3fe", "1f482-1f3ff"] }, { "n": ["man guard", "male-guard"], "u": "1f482-200d-2642-fe0f", "v": ["1f482-1f3fb-200d-2642-fe0f", "1f482-1f3fc-200d-2642-fe0f", "1f482-1f3fd-200d-2642-fe0f", "1f482-1f3fe-200d-2642-fe0f", "1f482-1f3ff-200d-2642-fe0f"] }, { "n": ["woman guard", "female-guard"], "u": "1f482-200d-2640-fe0f", "v": ["1f482-1f3fb-200d-2640-fe0f", "1f482-1f3fc-200d-2640-fe0f", "1f482-1f3fd-200d-2640-fe0f", "1f482-1f3fe-200d-2640-fe0f", "1f482-1f3ff-200d-2640-fe0f"] }, { "n": ["ninja"], "u": "1f977", "v": ["1f977-1f3fb", "1f977-1f3fc", "1f977-1f3fd", "1f977-1f3fe", "1f977-1f3ff"] }, { "n": ["construction worker"], "u": "1f477", "v": ["1f477-1f3fb", "1f477-1f3fc", "1f477-1f3fd", "1f477-1f3fe", "1f477-1f3ff"] }, { "n": ["man construction worker", "male-construction-worker"], "u": "1f477-200d-2642-fe0f", "v": ["1f477-1f3fb-200d-2642-fe0f", "1f477-1f3fc-200d-2642-fe0f", "1f477-1f3fd-200d-2642-fe0f", "1f477-1f3fe-200d-2642-fe0f", "1f477-1f3ff-200d-2642-fe0f"] }, { "n": ["woman construction worker", "female-construction-worker"], "u": "1f477-200d-2640-fe0f", "v": ["1f477-1f3fb-200d-2640-fe0f", "1f477-1f3fc-200d-2640-fe0f", "1f477-1f3fd-200d-2640-fe0f", "1f477-1f3fe-200d-2640-fe0f", "1f477-1f3ff-200d-2640-fe0f"] }, { "n": ["person with crown"], "u": "1fac5", "v": ["1fac5-1f3fb", "1fac5-1f3fc", "1fac5-1f3fd", "1fac5-1f3fe", "1fac5-1f3ff"] }, { "n": ["prince"], "u": "1f934", "v": ["1f934-1f3fb", "1f934-1f3fc", "1f934-1f3fd", "1f934-1f3fe", "1f934-1f3ff"] }, { "n": ["princess"], "u": "1f478", "v": ["1f478-1f3fb", "1f478-1f3fc", "1f478-1f3fd", "1f478-1f3fe", "1f478-1f3ff"] }, { "n": ["man with turban"], "u": "1f473", "v": ["1f473-1f3fb", "1f473-1f3fc", "1f473-1f3fd", "1f473-1f3fe", "1f473-1f3ff"] }, { "n": ["man wearing turban", "man-wearing-turban"], "u": "1f473-200d-2642-fe0f", "v": ["1f473-1f3fb-200d-2642-fe0f", "1f473-1f3fc-200d-2642-fe0f", "1f473-1f3fd-200d-2642-fe0f", "1f473-1f3fe-200d-2642-fe0f", "1f473-1f3ff-200d-2642-fe0f"] }, { "n": ["woman wearing turban", "woman-wearing-turban"], "u": "1f473-200d-2640-fe0f", "v": ["1f473-1f3fb-200d-2640-fe0f", "1f473-1f3fc-200d-2640-fe0f", "1f473-1f3fd-200d-2640-fe0f", "1f473-1f3fe-200d-2640-fe0f", "1f473-1f3ff-200d-2640-fe0f"] }, { "n": ["man with gua pi mao"], "u": "1f472", "v": ["1f472-1f3fb", "1f472-1f3fc", "1f472-1f3fd", "1f472-1f3fe", "1f472-1f3ff"] }, { "n": ["person with headscarf"], "u": "1f9d5", "v": ["1f9d5-1f3fb", "1f9d5-1f3fc", "1f9d5-1f3fd", "1f9d5-1f3fe", "1f9d5-1f3ff"] }, { "n": ["man in tuxedo", "person in tuxedo"], "u": "1f935", "v": ["1f935-1f3fb", "1f935-1f3fc", "1f935-1f3fd", "1f935-1f3fe", "1f935-1f3ff"] }, { "n": ["man in tuxedo"], "u": "1f935-200d-2642-fe0f", "v": ["1f935-1f3fb-200d-2642-fe0f", "1f935-1f3fc-200d-2642-fe0f", "1f935-1f3fd-200d-2642-fe0f", "1f935-1f3fe-200d-2642-fe0f", "1f935-1f3ff-200d-2642-fe0f"] }, { "n": ["woman in tuxedo"], "u": "1f935-200d-2640-fe0f", "v": ["1f935-1f3fb-200d-2640-fe0f", "1f935-1f3fc-200d-2640-fe0f", "1f935-1f3fd-200d-2640-fe0f", "1f935-1f3fe-200d-2640-fe0f", "1f935-1f3ff-200d-2640-fe0f"] }, { "n": ["bride with veil"], "u": "1f470", "v": ["1f470-1f3fb", "1f470-1f3fc", "1f470-1f3fd", "1f470-1f3fe", "1f470-1f3ff"] }, { "n": ["man with veil"], "u": "1f470-200d-2642-fe0f", "v": ["1f470-1f3fb-200d-2642-fe0f", "1f470-1f3fc-200d-2642-fe0f", "1f470-1f3fd-200d-2642-fe0f", "1f470-1f3fe-200d-2642-fe0f", "1f470-1f3ff-200d-2642-fe0f"] }, { "n": ["woman with veil"], "u": "1f470-200d-2640-fe0f", "v": ["1f470-1f3fb-200d-2640-fe0f", "1f470-1f3fc-200d-2640-fe0f", "1f470-1f3fd-200d-2640-fe0f", "1f470-1f3fe-200d-2640-fe0f", "1f470-1f3ff-200d-2640-fe0f"] }, { "n": ["pregnant woman"], "u": "1f930", "v": ["1f930-1f3fb", "1f930-1f3fc", "1f930-1f3fd", "1f930-1f3fe", "1f930-1f3ff"] }, { "n": ["pregnant man"], "u": "1fac3", "v": ["1fac3-1f3fb", "1fac3-1f3fc", "1fac3-1f3fd", "1fac3-1f3fe", "1fac3-1f3ff"] }, { "n": ["pregnant person"], "u": "1fac4", "v": ["1fac4-1f3fb", "1fac4-1f3fc", "1fac4-1f3fd", "1fac4-1f3fe", "1fac4-1f3ff"] }, { "n": ["breast-feeding"], "u": "1f931", "v": ["1f931-1f3fb", "1f931-1f3fc", "1f931-1f3fd", "1f931-1f3fe", "1f931-1f3ff"] }, { "n": ["woman feeding baby"], "u": "1f469-200d-1f37c", "v": ["1f469-1f3fb-200d-1f37c", "1f469-1f3fc-200d-1f37c", "1f469-1f3fd-200d-1f37c", "1f469-1f3fe-200d-1f37c", "1f469-1f3ff-200d-1f37c"] }, { "n": ["man feeding baby"], "u": "1f468-200d-1f37c", "v": ["1f468-1f3fb-200d-1f37c", "1f468-1f3fc-200d-1f37c", "1f468-1f3fd-200d-1f37c", "1f468-1f3fe-200d-1f37c", "1f468-1f3ff-200d-1f37c"] }, { "n": ["person feeding baby"], "u": "1f9d1-200d-1f37c", "v": ["1f9d1-1f3fb-200d-1f37c", "1f9d1-1f3fc-200d-1f37c", "1f9d1-1f3fd-200d-1f37c", "1f9d1-1f3fe-200d-1f37c", "1f9d1-1f3ff-200d-1f37c"] }, { "n": ["angel", "baby angel"], "u": "1f47c", "v": ["1f47c-1f3fb", "1f47c-1f3fc", "1f47c-1f3fd", "1f47c-1f3fe", "1f47c-1f3ff"] }, { "n": ["santa", "father christmas"], "u": "1f385", "v": ["1f385-1f3fb", "1f385-1f3fc", "1f385-1f3fd", "1f385-1f3fe", "1f385-1f3ff"] }, { "n": ["mrs claus", "mother christmas"], "u": "1f936", "v": ["1f936-1f3fb", "1f936-1f3fc", "1f936-1f3fd", "1f936-1f3fe", "1f936-1f3ff"] }, { "n": ["mx claus"], "u": "1f9d1-200d-1f384", "v": ["1f9d1-1f3fb-200d-1f384", "1f9d1-1f3fc-200d-1f384", "1f9d1-1f3fd-200d-1f384", "1f9d1-1f3fe-200d-1f384", "1f9d1-1f3ff-200d-1f384"] }, { "n": ["superhero"], "u": "1f9b8", "v": ["1f9b8-1f3fb", "1f9b8-1f3fc", "1f9b8-1f3fd", "1f9b8-1f3fe", "1f9b8-1f3ff"] }, { "n": ["man superhero", "male superhero"], "u": "1f9b8-200d-2642-fe0f", "v": ["1f9b8-1f3fb-200d-2642-fe0f", "1f9b8-1f3fc-200d-2642-fe0f", "1f9b8-1f3fd-200d-2642-fe0f", "1f9b8-1f3fe-200d-2642-fe0f", "1f9b8-1f3ff-200d-2642-fe0f"] }, { "n": ["woman superhero", "female superhero"], "u": "1f9b8-200d-2640-fe0f", "v": ["1f9b8-1f3fb-200d-2640-fe0f", "1f9b8-1f3fc-200d-2640-fe0f", "1f9b8-1f3fd-200d-2640-fe0f", "1f9b8-1f3fe-200d-2640-fe0f", "1f9b8-1f3ff-200d-2640-fe0f"] }, { "n": ["supervillain"], "u": "1f9b9", "v": ["1f9b9-1f3fb", "1f9b9-1f3fc", "1f9b9-1f3fd", "1f9b9-1f3fe", "1f9b9-1f3ff"] }, { "n": ["man supervillain", "male supervillain"], "u": "1f9b9-200d-2642-fe0f", "v": ["1f9b9-1f3fb-200d-2642-fe0f", "1f9b9-1f3fc-200d-2642-fe0f", "1f9b9-1f3fd-200d-2642-fe0f", "1f9b9-1f3fe-200d-2642-fe0f", "1f9b9-1f3ff-200d-2642-fe0f"] }, { "n": ["woman supervillain", "female supervillain"], "u": "1f9b9-200d-2640-fe0f", "v": ["1f9b9-1f3fb-200d-2640-fe0f", "1f9b9-1f3fc-200d-2640-fe0f", "1f9b9-1f3fd-200d-2640-fe0f", "1f9b9-1f3fe-200d-2640-fe0f", "1f9b9-1f3ff-200d-2640-fe0f"] }, { "n": ["mage"], "u": "1f9d9", "v": ["1f9d9-1f3fb", "1f9d9-1f3fc", "1f9d9-1f3fd", "1f9d9-1f3fe", "1f9d9-1f3ff"] }, { "n": ["man mage", "male mage"], "u": "1f9d9-200d-2642-fe0f", "v": ["1f9d9-1f3fb-200d-2642-fe0f", "1f9d9-1f3fc-200d-2642-fe0f", "1f9d9-1f3fd-200d-2642-fe0f", "1f9d9-1f3fe-200d-2642-fe0f", "1f9d9-1f3ff-200d-2642-fe0f"] }, { "n": ["woman mage", "female mage"], "u": "1f9d9-200d-2640-fe0f", "v": ["1f9d9-1f3fb-200d-2640-fe0f", "1f9d9-1f3fc-200d-2640-fe0f", "1f9d9-1f3fd-200d-2640-fe0f", "1f9d9-1f3fe-200d-2640-fe0f", "1f9d9-1f3ff-200d-2640-fe0f"] }, { "n": ["fairy"], "u": "1f9da", "v": ["1f9da-1f3fb", "1f9da-1f3fc", "1f9da-1f3fd", "1f9da-1f3fe", "1f9da-1f3ff"] }, { "n": ["man fairy", "male fairy"], "u": "1f9da-200d-2642-fe0f", "v": ["1f9da-1f3fb-200d-2642-fe0f", "1f9da-1f3fc-200d-2642-fe0f", "1f9da-1f3fd-200d-2642-fe0f", "1f9da-1f3fe-200d-2642-fe0f", "1f9da-1f3ff-200d-2642-fe0f"] }, { "n": ["woman fairy", "female fairy"], "u": "1f9da-200d-2640-fe0f", "v": ["1f9da-1f3fb-200d-2640-fe0f", "1f9da-1f3fc-200d-2640-fe0f", "1f9da-1f3fd-200d-2640-fe0f", "1f9da-1f3fe-200d-2640-fe0f", "1f9da-1f3ff-200d-2640-fe0f"] }, { "n": ["vampire"], "u": "1f9db", "v": ["1f9db-1f3fb", "1f9db-1f3fc", "1f9db-1f3fd", "1f9db-1f3fe", "1f9db-1f3ff"] }, { "n": ["man vampire", "male vampire"], "u": "1f9db-200d-2642-fe0f", "v": ["1f9db-1f3fb-200d-2642-fe0f", "1f9db-1f3fc-200d-2642-fe0f", "1f9db-1f3fd-200d-2642-fe0f", "1f9db-1f3fe-200d-2642-fe0f", "1f9db-1f3ff-200d-2642-fe0f"] }, { "n": ["woman vampire", "female vampire"], "u": "1f9db-200d-2640-fe0f", "v": ["1f9db-1f3fb-200d-2640-fe0f", "1f9db-1f3fc-200d-2640-fe0f", "1f9db-1f3fd-200d-2640-fe0f", "1f9db-1f3fe-200d-2640-fe0f", "1f9db-1f3ff-200d-2640-fe0f"] }, { "n": ["merperson"], "u": "1f9dc", "v": ["1f9dc-1f3fb", "1f9dc-1f3fc", "1f9dc-1f3fd", "1f9dc-1f3fe", "1f9dc-1f3ff"] }, { "n": ["merman"], "u": "1f9dc-200d-2642-fe0f", "v": ["1f9dc-1f3fb-200d-2642-fe0f", "1f9dc-1f3fc-200d-2642-fe0f", "1f9dc-1f3fd-200d-2642-fe0f", "1f9dc-1f3fe-200d-2642-fe0f", "1f9dc-1f3ff-200d-2642-fe0f"] }, { "n": ["mermaid"], "u": "1f9dc-200d-2640-fe0f", "v": ["1f9dc-1f3fb-200d-2640-fe0f", "1f9dc-1f3fc-200d-2640-fe0f", "1f9dc-1f3fd-200d-2640-fe0f", "1f9dc-1f3fe-200d-2640-fe0f", "1f9dc-1f3ff-200d-2640-fe0f"] }, { "n": ["elf"], "u": "1f9dd", "v": ["1f9dd-1f3fb", "1f9dd-1f3fc", "1f9dd-1f3fd", "1f9dd-1f3fe", "1f9dd-1f3ff"] }, { "n": ["man elf", "male elf"], "u": "1f9dd-200d-2642-fe0f", "v": ["1f9dd-1f3fb-200d-2642-fe0f", "1f9dd-1f3fc-200d-2642-fe0f", "1f9dd-1f3fd-200d-2642-fe0f", "1f9dd-1f3fe-200d-2642-fe0f", "1f9dd-1f3ff-200d-2642-fe0f"] }, { "n": ["woman elf", "female elf"], "u": "1f9dd-200d-2640-fe0f", "v": ["1f9dd-1f3fb-200d-2640-fe0f", "1f9dd-1f3fc-200d-2640-fe0f", "1f9dd-1f3fd-200d-2640-fe0f", "1f9dd-1f3fe-200d-2640-fe0f", "1f9dd-1f3ff-200d-2640-fe0f"] }, { "n": ["genie"], "u": "1f9de" }, { "n": ["man genie", "male genie"], "u": "1f9de-200d-2642-fe0f" }, { "n": ["woman genie", "female genie"], "u": "1f9de-200d-2640-fe0f" }, { "n": ["zombie"], "u": "1f9df" }, { "n": ["man zombie", "male zombie"], "u": "1f9df-200d-2642-fe0f" }, { "n": ["woman zombie", "female zombie"], "u": "1f9df-200d-2640-fe0f" }, { "n": ["troll"], "u": "1f9cc" }, { "n": ["massage", "face massage"], "u": "1f486", "v": ["1f486-1f3fb", "1f486-1f3fc", "1f486-1f3fd", "1f486-1f3fe", "1f486-1f3ff"] }, { "n": ["man getting massage", "man-getting-massage"], "u": "1f486-200d-2642-fe0f", "v": ["1f486-1f3fb-200d-2642-fe0f", "1f486-1f3fc-200d-2642-fe0f", "1f486-1f3fd-200d-2642-fe0f", "1f486-1f3fe-200d-2642-fe0f", "1f486-1f3ff-200d-2642-fe0f"] }, { "n": ["woman getting massage", "woman-getting-massage"], "u": "1f486-200d-2640-fe0f", "v": ["1f486-1f3fb-200d-2640-fe0f", "1f486-1f3fc-200d-2640-fe0f", "1f486-1f3fd-200d-2640-fe0f", "1f486-1f3fe-200d-2640-fe0f", "1f486-1f3ff-200d-2640-fe0f"] }, { "n": ["haircut"], "u": "1f487", "v": ["1f487-1f3fb", "1f487-1f3fc", "1f487-1f3fd", "1f487-1f3fe", "1f487-1f3ff"] }, { "n": ["man getting haircut", "man-getting-haircut"], "u": "1f487-200d-2642-fe0f", "v": ["1f487-1f3fb-200d-2642-fe0f", "1f487-1f3fc-200d-2642-fe0f", "1f487-1f3fd-200d-2642-fe0f", "1f487-1f3fe-200d-2642-fe0f", "1f487-1f3ff-200d-2642-fe0f"] }, { "n": ["woman getting haircut", "woman-getting-haircut"], "u": "1f487-200d-2640-fe0f", "v": ["1f487-1f3fb-200d-2640-fe0f", "1f487-1f3fc-200d-2640-fe0f", "1f487-1f3fd-200d-2640-fe0f", "1f487-1f3fe-200d-2640-fe0f", "1f487-1f3ff-200d-2640-fe0f"] }, { "n": ["walking", "pedestrian"], "u": "1f6b6", "v": ["1f6b6-1f3fb", "1f6b6-1f3fc", "1f6b6-1f3fd", "1f6b6-1f3fe", "1f6b6-1f3ff"] }, { "n": ["man walking", "man-walking"], "u": "1f6b6-200d-2642-fe0f", "v": ["1f6b6-1f3fb-200d-2642-fe0f", "1f6b6-1f3fc-200d-2642-fe0f", "1f6b6-1f3fd-200d-2642-fe0f", "1f6b6-1f3fe-200d-2642-fe0f", "1f6b6-1f3ff-200d-2642-fe0f"] }, { "n": ["woman walking", "woman-walking"], "u": "1f6b6-200d-2640-fe0f", "v": ["1f6b6-1f3fb-200d-2640-fe0f", "1f6b6-1f3fc-200d-2640-fe0f", "1f6b6-1f3fd-200d-2640-fe0f", "1f6b6-1f3fe-200d-2640-fe0f", "1f6b6-1f3ff-200d-2640-fe0f"] }, { "n": ["standing person"], "u": "1f9cd", "v": ["1f9cd-1f3fb", "1f9cd-1f3fc", "1f9cd-1f3fd", "1f9cd-1f3fe", "1f9cd-1f3ff"] }, { "n": ["man standing"], "u": "1f9cd-200d-2642-fe0f", "v": ["1f9cd-1f3fb-200d-2642-fe0f", "1f9cd-1f3fc-200d-2642-fe0f", "1f9cd-1f3fd-200d-2642-fe0f", "1f9cd-1f3fe-200d-2642-fe0f", "1f9cd-1f3ff-200d-2642-fe0f"] }, { "n": ["woman standing"], "u": "1f9cd-200d-2640-fe0f", "v": ["1f9cd-1f3fb-200d-2640-fe0f", "1f9cd-1f3fc-200d-2640-fe0f", "1f9cd-1f3fd-200d-2640-fe0f", "1f9cd-1f3fe-200d-2640-fe0f", "1f9cd-1f3ff-200d-2640-fe0f"] }, { "n": ["kneeling person"], "u": "1f9ce", "v": ["1f9ce-1f3fb", "1f9ce-1f3fc", "1f9ce-1f3fd", "1f9ce-1f3fe", "1f9ce-1f3ff"] }, { "n": ["man kneeling"], "u": "1f9ce-200d-2642-fe0f", "v": ["1f9ce-1f3fb-200d-2642-fe0f", "1f9ce-1f3fc-200d-2642-fe0f", "1f9ce-1f3fd-200d-2642-fe0f", "1f9ce-1f3fe-200d-2642-fe0f", "1f9ce-1f3ff-200d-2642-fe0f"] }, { "n": ["woman kneeling"], "u": "1f9ce-200d-2640-fe0f", "v": ["1f9ce-1f3fb-200d-2640-fe0f", "1f9ce-1f3fc-200d-2640-fe0f", "1f9ce-1f3fd-200d-2640-fe0f", "1f9ce-1f3fe-200d-2640-fe0f", "1f9ce-1f3ff-200d-2640-fe0f"] }, { "n": ["person with white cane", "person with probing cane"], "u": "1f9d1-200d-1f9af", "v": ["1f9d1-1f3fb-200d-1f9af", "1f9d1-1f3fc-200d-1f9af", "1f9d1-1f3fd-200d-1f9af", "1f9d1-1f3fe-200d-1f9af", "1f9d1-1f3ff-200d-1f9af"] }, { "n": ["man with white cane", "man with probing cane"], "u": "1f468-200d-1f9af", "v": ["1f468-1f3fb-200d-1f9af", "1f468-1f3fc-200d-1f9af", "1f468-1f3fd-200d-1f9af", "1f468-1f3fe-200d-1f9af", "1f468-1f3ff-200d-1f9af"] }, { "n": ["woman with white cane", "woman with probing cane"], "u": "1f469-200d-1f9af", "v": ["1f469-1f3fb-200d-1f9af", "1f469-1f3fc-200d-1f9af", "1f469-1f3fd-200d-1f9af", "1f469-1f3fe-200d-1f9af", "1f469-1f3ff-200d-1f9af"] }, { "n": ["person in motorized wheelchair"], "u": "1f9d1-200d-1f9bc", "v": ["1f9d1-1f3fb-200d-1f9bc", "1f9d1-1f3fc-200d-1f9bc", "1f9d1-1f3fd-200d-1f9bc", "1f9d1-1f3fe-200d-1f9bc", "1f9d1-1f3ff-200d-1f9bc"] }, { "n": ["man in motorized wheelchair"], "u": "1f468-200d-1f9bc", "v": ["1f468-1f3fb-200d-1f9bc", "1f468-1f3fc-200d-1f9bc", "1f468-1f3fd-200d-1f9bc", "1f468-1f3fe-200d-1f9bc", "1f468-1f3ff-200d-1f9bc"] }, { "n": ["woman in motorized wheelchair"], "u": "1f469-200d-1f9bc", "v": ["1f469-1f3fb-200d-1f9bc", "1f469-1f3fc-200d-1f9bc", "1f469-1f3fd-200d-1f9bc", "1f469-1f3fe-200d-1f9bc", "1f469-1f3ff-200d-1f9bc"] }, { "n": ["person in manual wheelchair"], "u": "1f9d1-200d-1f9bd", "v": ["1f9d1-1f3fb-200d-1f9bd", "1f9d1-1f3fc-200d-1f9bd", "1f9d1-1f3fd-200d-1f9bd", "1f9d1-1f3fe-200d-1f9bd", "1f9d1-1f3ff-200d-1f9bd"] }, { "n": ["man in manual wheelchair"], "u": "1f468-200d-1f9bd", "v": ["1f468-1f3fb-200d-1f9bd", "1f468-1f3fc-200d-1f9bd", "1f468-1f3fd-200d-1f9bd", "1f468-1f3fe-200d-1f9bd", "1f468-1f3ff-200d-1f9bd"] }, { "n": ["woman in manual wheelchair"], "u": "1f469-200d-1f9bd", "v": ["1f469-1f3fb-200d-1f9bd", "1f469-1f3fc-200d-1f9bd", "1f469-1f3fd-200d-1f9bd", "1f469-1f3fe-200d-1f9bd", "1f469-1f3ff-200d-1f9bd"] }, { "n": ["runner", "running"], "u": "1f3c3", "v": ["1f3c3-1f3fb", "1f3c3-1f3fc", "1f3c3-1f3fd", "1f3c3-1f3fe", "1f3c3-1f3ff"] }, { "n": ["man running", "man-running"], "u": "1f3c3-200d-2642-fe0f", "v": ["1f3c3-1f3fb-200d-2642-fe0f", "1f3c3-1f3fc-200d-2642-fe0f", "1f3c3-1f3fd-200d-2642-fe0f", "1f3c3-1f3fe-200d-2642-fe0f", "1f3c3-1f3ff-200d-2642-fe0f"] }, { "n": ["woman running", "woman-running"], "u": "1f3c3-200d-2640-fe0f", "v": ["1f3c3-1f3fb-200d-2640-fe0f", "1f3c3-1f3fc-200d-2640-fe0f", "1f3c3-1f3fd-200d-2640-fe0f", "1f3c3-1f3fe-200d-2640-fe0f", "1f3c3-1f3ff-200d-2640-fe0f"] }, { "n": ["dancer"], "u": "1f483", "v": ["1f483-1f3fb", "1f483-1f3fc", "1f483-1f3fd", "1f483-1f3fe", "1f483-1f3ff"] }, { "n": ["man dancing"], "u": "1f57a", "v": ["1f57a-1f3fb", "1f57a-1f3fc", "1f57a-1f3fd", "1f57a-1f3fe", "1f57a-1f3ff"] }, { "n": ["person in suit levitating", "man in business suit levitating"], "u": "1f574-fe0f", "v": ["1f574-1f3fb", "1f574-1f3fc", "1f574-1f3fd", "1f574-1f3fe", "1f574-1f3ff"] }, { "n": ["dancers", "woman with bunny ears"], "u": "1f46f" }, { "n": ["men with bunny ears", "men-with-bunny-ears-partying", "man-with-bunny-ears-partying"], "u": "1f46f-200d-2642-fe0f" }, { "n": ["women with bunny ears", "women-with-bunny-ears-partying", "woman-with-bunny-ears-partying"], "u": "1f46f-200d-2640-fe0f" }, { "n": ["person in steamy room"], "u": "1f9d6", "v": ["1f9d6-1f3fb", "1f9d6-1f3fc", "1f9d6-1f3fd", "1f9d6-1f3fe", "1f9d6-1f3ff"] }, { "n": ["man in steamy room"], "u": "1f9d6-200d-2642-fe0f", "v": ["1f9d6-1f3fb-200d-2642-fe0f", "1f9d6-1f3fc-200d-2642-fe0f", "1f9d6-1f3fd-200d-2642-fe0f", "1f9d6-1f3fe-200d-2642-fe0f", "1f9d6-1f3ff-200d-2642-fe0f"] }, { "n": ["woman in steamy room"], "u": "1f9d6-200d-2640-fe0f", "v": ["1f9d6-1f3fb-200d-2640-fe0f", "1f9d6-1f3fc-200d-2640-fe0f", "1f9d6-1f3fd-200d-2640-fe0f", "1f9d6-1f3fe-200d-2640-fe0f", "1f9d6-1f3ff-200d-2640-fe0f"] }, { "n": ["person climbing"], "u": "1f9d7", "v": ["1f9d7-1f3fb", "1f9d7-1f3fc", "1f9d7-1f3fd", "1f9d7-1f3fe", "1f9d7-1f3ff"] }, { "n": ["man climbing"], "u": "1f9d7-200d-2642-fe0f", "v": ["1f9d7-1f3fb-200d-2642-fe0f", "1f9d7-1f3fc-200d-2642-fe0f", "1f9d7-1f3fd-200d-2642-fe0f", "1f9d7-1f3fe-200d-2642-fe0f", "1f9d7-1f3ff-200d-2642-fe0f"] }, { "n": ["woman climbing"], "u": "1f9d7-200d-2640-fe0f", "v": ["1f9d7-1f3fb-200d-2640-fe0f", "1f9d7-1f3fc-200d-2640-fe0f", "1f9d7-1f3fd-200d-2640-fe0f", "1f9d7-1f3fe-200d-2640-fe0f", "1f9d7-1f3ff-200d-2640-fe0f"] }, { "n": ["fencer"], "u": "1f93a" }, { "n": ["horse racing"], "u": "1f3c7", "v": ["1f3c7-1f3fb", "1f3c7-1f3fc", "1f3c7-1f3fd", "1f3c7-1f3fe", "1f3c7-1f3ff"] }, { "n": ["skier"], "u": "26f7-fe0f" }, { "n": ["snowboarder"], "u": "1f3c2", "v": ["1f3c2-1f3fb", "1f3c2-1f3fc", "1f3c2-1f3fd", "1f3c2-1f3fe", "1f3c2-1f3ff"] }, { "n": ["golfer", "person golfing"], "u": "1f3cc-fe0f", "v": ["1f3cc-1f3fb", "1f3cc-1f3fc", "1f3cc-1f3fd", "1f3cc-1f3fe", "1f3cc-1f3ff"] }, { "n": ["man golfing", "man-golfing"], "u": "1f3cc-fe0f-200d-2642-fe0f", "v": ["1f3cc-1f3fb-200d-2642-fe0f", "1f3cc-1f3fc-200d-2642-fe0f", "1f3cc-1f3fd-200d-2642-fe0f", "1f3cc-1f3fe-200d-2642-fe0f", "1f3cc-1f3ff-200d-2642-fe0f"] }, { "n": ["woman golfing", "woman-golfing"], "u": "1f3cc-fe0f-200d-2640-fe0f", "v": ["1f3cc-1f3fb-200d-2640-fe0f", "1f3cc-1f3fc-200d-2640-fe0f", "1f3cc-1f3fd-200d-2640-fe0f", "1f3cc-1f3fe-200d-2640-fe0f", "1f3cc-1f3ff-200d-2640-fe0f"] }, { "n": ["surfer"], "u": "1f3c4", "v": ["1f3c4-1f3fb", "1f3c4-1f3fc", "1f3c4-1f3fd", "1f3c4-1f3fe", "1f3c4-1f3ff"] }, { "n": ["man surfing", "man-surfing"], "u": "1f3c4-200d-2642-fe0f", "v": ["1f3c4-1f3fb-200d-2642-fe0f", "1f3c4-1f3fc-200d-2642-fe0f", "1f3c4-1f3fd-200d-2642-fe0f", "1f3c4-1f3fe-200d-2642-fe0f", "1f3c4-1f3ff-200d-2642-fe0f"] }, { "n": ["woman surfing", "woman-surfing"], "u": "1f3c4-200d-2640-fe0f", "v": ["1f3c4-1f3fb-200d-2640-fe0f", "1f3c4-1f3fc-200d-2640-fe0f", "1f3c4-1f3fd-200d-2640-fe0f", "1f3c4-1f3fe-200d-2640-fe0f", "1f3c4-1f3ff-200d-2640-fe0f"] }, { "n": ["rowboat"], "u": "1f6a3", "v": ["1f6a3-1f3fb", "1f6a3-1f3fc", "1f6a3-1f3fd", "1f6a3-1f3fe", "1f6a3-1f3ff"] }, { "n": ["man rowing boat", "man-rowing-boat"], "u": "1f6a3-200d-2642-fe0f", "v": ["1f6a3-1f3fb-200d-2642-fe0f", "1f6a3-1f3fc-200d-2642-fe0f", "1f6a3-1f3fd-200d-2642-fe0f", "1f6a3-1f3fe-200d-2642-fe0f", "1f6a3-1f3ff-200d-2642-fe0f"] }, { "n": ["woman rowing boat", "woman-rowing-boat"], "u": "1f6a3-200d-2640-fe0f", "v": ["1f6a3-1f3fb-200d-2640-fe0f", "1f6a3-1f3fc-200d-2640-fe0f", "1f6a3-1f3fd-200d-2640-fe0f", "1f6a3-1f3fe-200d-2640-fe0f", "1f6a3-1f3ff-200d-2640-fe0f"] }, { "n": ["swimmer"], "u": "1f3ca", "v": ["1f3ca-1f3fb", "1f3ca-1f3fc", "1f3ca-1f3fd", "1f3ca-1f3fe", "1f3ca-1f3ff"] }, { "n": ["man swimming", "man-swimming"], "u": "1f3ca-200d-2642-fe0f", "v": ["1f3ca-1f3fb-200d-2642-fe0f", "1f3ca-1f3fc-200d-2642-fe0f", "1f3ca-1f3fd-200d-2642-fe0f", "1f3ca-1f3fe-200d-2642-fe0f", "1f3ca-1f3ff-200d-2642-fe0f"] }, { "n": ["woman swimming", "woman-swimming"], "u": "1f3ca-200d-2640-fe0f", "v": ["1f3ca-1f3fb-200d-2640-fe0f", "1f3ca-1f3fc-200d-2640-fe0f", "1f3ca-1f3fd-200d-2640-fe0f", "1f3ca-1f3fe-200d-2640-fe0f", "1f3ca-1f3ff-200d-2640-fe0f"] }, { "n": ["person with ball", "person bouncing ball"], "u": "26f9-fe0f", "v": ["26f9-1f3fb", "26f9-1f3fc", "26f9-1f3fd", "26f9-1f3fe", "26f9-1f3ff"] }, { "n": ["man bouncing ball", "man-bouncing-ball"], "u": "26f9-fe0f-200d-2642-fe0f", "v": ["26f9-1f3fb-200d-2642-fe0f", "26f9-1f3fc-200d-2642-fe0f", "26f9-1f3fd-200d-2642-fe0f", "26f9-1f3fe-200d-2642-fe0f", "26f9-1f3ff-200d-2642-fe0f"] }, { "n": ["woman bouncing ball", "woman-bouncing-ball"], "u": "26f9-fe0f-200d-2640-fe0f", "v": ["26f9-1f3fb-200d-2640-fe0f", "26f9-1f3fc-200d-2640-fe0f", "26f9-1f3fd-200d-2640-fe0f", "26f9-1f3fe-200d-2640-fe0f", "26f9-1f3ff-200d-2640-fe0f"] }, { "n": ["weight lifter", "person lifting weights"], "u": "1f3cb-fe0f", "v": ["1f3cb-1f3fb", "1f3cb-1f3fc", "1f3cb-1f3fd", "1f3cb-1f3fe", "1f3cb-1f3ff"] }, { "n": ["man lifting weights", "man-lifting-weights"], "u": "1f3cb-fe0f-200d-2642-fe0f", "v": ["1f3cb-1f3fb-200d-2642-fe0f", "1f3cb-1f3fc-200d-2642-fe0f", "1f3cb-1f3fd-200d-2642-fe0f", "1f3cb-1f3fe-200d-2642-fe0f", "1f3cb-1f3ff-200d-2642-fe0f"] }, { "n": ["woman lifting weights", "woman-lifting-weights"], "u": "1f3cb-fe0f-200d-2640-fe0f", "v": ["1f3cb-1f3fb-200d-2640-fe0f", "1f3cb-1f3fc-200d-2640-fe0f", "1f3cb-1f3fd-200d-2640-fe0f", "1f3cb-1f3fe-200d-2640-fe0f", "1f3cb-1f3ff-200d-2640-fe0f"] }, { "n": ["bicyclist"], "u": "1f6b4", "v": ["1f6b4-1f3fb", "1f6b4-1f3fc", "1f6b4-1f3fd", "1f6b4-1f3fe", "1f6b4-1f3ff"] }, { "n": ["man biking", "man-biking"], "u": "1f6b4-200d-2642-fe0f", "v": ["1f6b4-1f3fb-200d-2642-fe0f", "1f6b4-1f3fc-200d-2642-fe0f", "1f6b4-1f3fd-200d-2642-fe0f", "1f6b4-1f3fe-200d-2642-fe0f", "1f6b4-1f3ff-200d-2642-fe0f"] }, { "n": ["woman biking", "woman-biking"], "u": "1f6b4-200d-2640-fe0f", "v": ["1f6b4-1f3fb-200d-2640-fe0f", "1f6b4-1f3fc-200d-2640-fe0f", "1f6b4-1f3fd-200d-2640-fe0f", "1f6b4-1f3fe-200d-2640-fe0f", "1f6b4-1f3ff-200d-2640-fe0f"] }, { "n": ["mountain bicyclist"], "u": "1f6b5", "v": ["1f6b5-1f3fb", "1f6b5-1f3fc", "1f6b5-1f3fd", "1f6b5-1f3fe", "1f6b5-1f3ff"] }, { "n": ["man mountain biking", "man-mountain-biking"], "u": "1f6b5-200d-2642-fe0f", "v": ["1f6b5-1f3fb-200d-2642-fe0f", "1f6b5-1f3fc-200d-2642-fe0f", "1f6b5-1f3fd-200d-2642-fe0f", "1f6b5-1f3fe-200d-2642-fe0f", "1f6b5-1f3ff-200d-2642-fe0f"] }, { "n": ["woman mountain biking", "woman-mountain-biking"], "u": "1f6b5-200d-2640-fe0f", "v": ["1f6b5-1f3fb-200d-2640-fe0f", "1f6b5-1f3fc-200d-2640-fe0f", "1f6b5-1f3fd-200d-2640-fe0f", "1f6b5-1f3fe-200d-2640-fe0f", "1f6b5-1f3ff-200d-2640-fe0f"] }, { "n": ["person doing cartwheel"], "u": "1f938", "v": ["1f938-1f3fb", "1f938-1f3fc", "1f938-1f3fd", "1f938-1f3fe", "1f938-1f3ff"] }, { "n": ["man cartwheeling", "man-cartwheeling"], "u": "1f938-200d-2642-fe0f", "v": ["1f938-1f3fb-200d-2642-fe0f", "1f938-1f3fc-200d-2642-fe0f", "1f938-1f3fd-200d-2642-fe0f", "1f938-1f3fe-200d-2642-fe0f", "1f938-1f3ff-200d-2642-fe0f"] }, { "n": ["woman cartwheeling", "woman-cartwheeling"], "u": "1f938-200d-2640-fe0f", "v": ["1f938-1f3fb-200d-2640-fe0f", "1f938-1f3fc-200d-2640-fe0f", "1f938-1f3fd-200d-2640-fe0f", "1f938-1f3fe-200d-2640-fe0f", "1f938-1f3ff-200d-2640-fe0f"] }, { "n": ["wrestlers"], "u": "1f93c" }, { "n": ["men wrestling", "man-wrestling"], "u": "1f93c-200d-2642-fe0f" }, { "n": ["women wrestling", "woman-wrestling"], "u": "1f93c-200d-2640-fe0f" }, { "n": ["water polo"], "u": "1f93d", "v": ["1f93d-1f3fb", "1f93d-1f3fc", "1f93d-1f3fd", "1f93d-1f3fe", "1f93d-1f3ff"] }, { "n": ["man playing water polo", "man-playing-water-polo"], "u": "1f93d-200d-2642-fe0f", "v": ["1f93d-1f3fb-200d-2642-fe0f", "1f93d-1f3fc-200d-2642-fe0f", "1f93d-1f3fd-200d-2642-fe0f", "1f93d-1f3fe-200d-2642-fe0f", "1f93d-1f3ff-200d-2642-fe0f"] }, { "n": ["woman playing water polo", "woman-playing-water-polo"], "u": "1f93d-200d-2640-fe0f", "v": ["1f93d-1f3fb-200d-2640-fe0f", "1f93d-1f3fc-200d-2640-fe0f", "1f93d-1f3fd-200d-2640-fe0f", "1f93d-1f3fe-200d-2640-fe0f", "1f93d-1f3ff-200d-2640-fe0f"] }, { "n": ["handball"], "u": "1f93e", "v": ["1f93e-1f3fb", "1f93e-1f3fc", "1f93e-1f3fd", "1f93e-1f3fe", "1f93e-1f3ff"] }, { "n": ["man playing handball", "man-playing-handball"], "u": "1f93e-200d-2642-fe0f", "v": ["1f93e-1f3fb-200d-2642-fe0f", "1f93e-1f3fc-200d-2642-fe0f", "1f93e-1f3fd-200d-2642-fe0f", "1f93e-1f3fe-200d-2642-fe0f", "1f93e-1f3ff-200d-2642-fe0f"] }, { "n": ["woman playing handball", "woman-playing-handball"], "u": "1f93e-200d-2640-fe0f", "v": ["1f93e-1f3fb-200d-2640-fe0f", "1f93e-1f3fc-200d-2640-fe0f", "1f93e-1f3fd-200d-2640-fe0f", "1f93e-1f3fe-200d-2640-fe0f", "1f93e-1f3ff-200d-2640-fe0f"] }, { "n": ["juggling"], "u": "1f939", "v": ["1f939-1f3fb", "1f939-1f3fc", "1f939-1f3fd", "1f939-1f3fe", "1f939-1f3ff"] }, { "n": ["man juggling", "man-juggling"], "u": "1f939-200d-2642-fe0f", "v": ["1f939-1f3fb-200d-2642-fe0f", "1f939-1f3fc-200d-2642-fe0f", "1f939-1f3fd-200d-2642-fe0f", "1f939-1f3fe-200d-2642-fe0f", "1f939-1f3ff-200d-2642-fe0f"] }, { "n": ["woman juggling", "woman-juggling"], "u": "1f939-200d-2640-fe0f", "v": ["1f939-1f3fb-200d-2640-fe0f", "1f939-1f3fc-200d-2640-fe0f", "1f939-1f3fd-200d-2640-fe0f", "1f939-1f3fe-200d-2640-fe0f", "1f939-1f3ff-200d-2640-fe0f"] }, { "n": ["person in lotus position"], "u": "1f9d8", "v": ["1f9d8-1f3fb", "1f9d8-1f3fc", "1f9d8-1f3fd", "1f9d8-1f3fe", "1f9d8-1f3ff"] }, { "n": ["man in lotus position"], "u": "1f9d8-200d-2642-fe0f", "v": ["1f9d8-1f3fb-200d-2642-fe0f", "1f9d8-1f3fc-200d-2642-fe0f", "1f9d8-1f3fd-200d-2642-fe0f", "1f9d8-1f3fe-200d-2642-fe0f", "1f9d8-1f3ff-200d-2642-fe0f"] }, { "n": ["woman in lotus position"], "u": "1f9d8-200d-2640-fe0f", "v": ["1f9d8-1f3fb-200d-2640-fe0f", "1f9d8-1f3fc-200d-2640-fe0f", "1f9d8-1f3fd-200d-2640-fe0f", "1f9d8-1f3fe-200d-2640-fe0f", "1f9d8-1f3ff-200d-2640-fe0f"] }, { "n": ["bath"], "u": "1f6c0", "v": ["1f6c0-1f3fb", "1f6c0-1f3fc", "1f6c0-1f3fd", "1f6c0-1f3fe", "1f6c0-1f3ff"] }, { "n": ["sleeping accommodation"], "u": "1f6cc", "v": ["1f6cc-1f3fb", "1f6cc-1f3fc", "1f6cc-1f3fd", "1f6cc-1f3fe", "1f6cc-1f3ff"] }, { "n": ["people holding hands"], "u": "1f9d1-200d-1f91d-200d-1f9d1", "v": ["1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fb", "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fc", "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fd", "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fe", "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3ff", "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fb", "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fc", "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fd", "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fe", "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3ff", "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fb", "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fc", "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fd", "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fe", "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3ff", "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fb", "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fc", "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fd", "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fe", "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3ff", "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fb", "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fc", "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fd", "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3fe", "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3ff"] }, { "n": ["women holding hands", "two women holding hands"], "u": "1f46d", "v": ["1f46d-1f3fb", "1f46d-1f3fc", "1f46d-1f3fd", "1f46d-1f3fe", "1f46d-1f3ff", "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fc", "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fd", "1f469-1f3fb-200d-1f91d-200d-1f469-1f3fe", "1f469-1f3fb-200d-1f91d-200d-1f469-1f3ff", "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fb", "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fd", "1f469-1f3fc-200d-1f91d-200d-1f469-1f3fe", "1f469-1f3fc-200d-1f91d-200d-1f469-1f3ff", "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fb", "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fc", "1f469-1f3fd-200d-1f91d-200d-1f469-1f3fe", "1f469-1f3fd-200d-1f91d-200d-1f469-1f3ff", "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fb", "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fc", "1f469-1f3fe-200d-1f91d-200d-1f469-1f3fd", "1f469-1f3fe-200d-1f91d-200d-1f469-1f3ff", "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fb", "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fc", "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fd", "1f469-1f3ff-200d-1f91d-200d-1f469-1f3fe"] }, { "n": ["couple", "man and woman holding hands", "woman and man holding hands"], "u": "1f46b", "v": ["1f46b-1f3fb", "1f46b-1f3fc", "1f46b-1f3fd", "1f46b-1f3fe", "1f46b-1f3ff", "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fc", "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fd", "1f469-1f3fb-200d-1f91d-200d-1f468-1f3fe", "1f469-1f3fb-200d-1f91d-200d-1f468-1f3ff", "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fb", "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fd", "1f469-1f3fc-200d-1f91d-200d-1f468-1f3fe", "1f469-1f3fc-200d-1f91d-200d-1f468-1f3ff", "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fb", "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fc", "1f469-1f3fd-200d-1f91d-200d-1f468-1f3fe", "1f469-1f3fd-200d-1f91d-200d-1f468-1f3ff", "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fb", "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fc", "1f469-1f3fe-200d-1f91d-200d-1f468-1f3fd", "1f469-1f3fe-200d-1f91d-200d-1f468-1f3ff", "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fb", "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fc", "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fd", "1f469-1f3ff-200d-1f91d-200d-1f468-1f3fe"] }, { "n": ["men holding hands", "two men holding hands"], "u": "1f46c", "v": ["1f46c-1f3fb", "1f46c-1f3fc", "1f46c-1f3fd", "1f46c-1f3fe", "1f46c-1f3ff", "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fc", "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fd", "1f468-1f3fb-200d-1f91d-200d-1f468-1f3fe", "1f468-1f3fb-200d-1f91d-200d-1f468-1f3ff", "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fb", "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fd", "1f468-1f3fc-200d-1f91d-200d-1f468-1f3fe", "1f468-1f3fc-200d-1f91d-200d-1f468-1f3ff", "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fb", "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fc", "1f468-1f3fd-200d-1f91d-200d-1f468-1f3fe", "1f468-1f3fd-200d-1f91d-200d-1f468-1f3ff", "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fb", "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fc", "1f468-1f3fe-200d-1f91d-200d-1f468-1f3fd", "1f468-1f3fe-200d-1f91d-200d-1f468-1f3ff", "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fb", "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fc", "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fd", "1f468-1f3ff-200d-1f91d-200d-1f468-1f3fe"] }, { "n": ["kiss", "couplekiss"], "u": "1f48f", "v": ["1f48f-1f3fb", "1f48f-1f3fc", "1f48f-1f3fd", "1f48f-1f3fe", "1f48f-1f3ff", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3ff", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fb", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fc", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fd", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f9d1-1f3fe"] }, { "n": ["woman-kiss-man", "kiss: woman, man"], "u": "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468", "v": ["1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff"] }, { "n": ["man-kiss-man", "kiss: man, man"], "u": "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468", "v": ["1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff"] }, { "n": ["woman-kiss-woman", "kiss: woman, woman"], "u": "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469", "v": ["1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff"] }, { "n": ["couple with heart"], "u": "1f491", "v": ["1f491-1f3fb", "1f491-1f3fc", "1f491-1f3fd", "1f491-1f3fe", "1f491-1f3ff", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fc", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fd", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3fe", "1f9d1-1f3fb-200d-2764-fe0f-200d-1f9d1-1f3ff", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fb", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fd", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3fe", "1f9d1-1f3fc-200d-2764-fe0f-200d-1f9d1-1f3ff", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fb", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fc", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3fe", "1f9d1-1f3fd-200d-2764-fe0f-200d-1f9d1-1f3ff", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fb", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fc", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3fd", "1f9d1-1f3fe-200d-2764-fe0f-200d-1f9d1-1f3ff", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fb", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fc", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fd", "1f9d1-1f3ff-200d-2764-fe0f-200d-1f9d1-1f3fe"] }, { "n": ["woman-heart-man", "couple with heart: woman, man"], "u": "1f469-200d-2764-fe0f-200d-1f468", "v": ["1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb", "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fc", "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fd", "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fe", "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3ff", "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fb", "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc", "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fd", "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fe", "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3ff", "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fb", "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fc", "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd", "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fe", "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3ff", "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fb", "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fc", "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fd", "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe", "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3ff", "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fb", "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fc", "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fd", "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3fe", "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff"] }, { "n": ["man-heart-man", "couple with heart: man, man"], "u": "1f468-200d-2764-fe0f-200d-1f468", "v": ["1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb", "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fc", "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fd", "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fe", "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3ff", "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fb", "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc", "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fd", "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fe", "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3ff", "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fb", "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fc", "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd", "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fe", "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3ff", "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fb", "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fc", "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fd", "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe", "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3ff", "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fb", "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fc", "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fd", "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3fe", "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff"] }, { "n": ["woman-heart-woman", "couple with heart: woman, woman"], "u": "1f469-200d-2764-fe0f-200d-1f469", "v": ["1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fb", "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fc", "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fd", "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fe", "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3ff", "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fb", "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fc", "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fd", "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fe", "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3ff", "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fb", "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fc", "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fd", "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fe", "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3ff", "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fb", "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fc", "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fd", "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fe", "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3ff", "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fb", "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fc", "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fd", "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3fe", "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3ff"] }, { "n": ["family"], "u": "1f46a" }, { "n": ["man-woman-boy", "family: man, woman, boy"], "u": "1f468-200d-1f469-200d-1f466" }, { "n": ["man-woman-girl", "family: man, woman, girl"], "u": "1f468-200d-1f469-200d-1f467" }, { "n": ["man-woman-girl-boy", "family: man, woman, girl, boy"], "u": "1f468-200d-1f469-200d-1f467-200d-1f466" }, { "n": ["man-woman-boy-boy", "family: man, woman, boy, boy"], "u": "1f468-200d-1f469-200d-1f466-200d-1f466" }, { "n": ["man-woman-girl-girl", "family: man, woman, girl, girl"], "u": "1f468-200d-1f469-200d-1f467-200d-1f467" }, { "n": ["man-man-boy", "family: man, man, boy"], "u": "1f468-200d-1f468-200d-1f466" }, { "n": ["man-man-girl", "family: man, man, girl"], "u": "1f468-200d-1f468-200d-1f467" }, { "n": ["man-man-girl-boy", "family: man, man, girl, boy"], "u": "1f468-200d-1f468-200d-1f467-200d-1f466" }, { "n": ["man-man-boy-boy", "family: man, man, boy, boy"], "u": "1f468-200d-1f468-200d-1f466-200d-1f466" }, { "n": ["man-man-girl-girl", "family: man, man, girl, girl"], "u": "1f468-200d-1f468-200d-1f467-200d-1f467" }, { "n": ["woman-woman-boy", "family: woman, woman, boy"], "u": "1f469-200d-1f469-200d-1f466" }, { "n": ["woman-woman-girl", "family: woman, woman, girl"], "u": "1f469-200d-1f469-200d-1f467" }, { "n": ["woman-woman-girl-boy", "family: woman, woman, girl, boy"], "u": "1f469-200d-1f469-200d-1f467-200d-1f466" }, { "n": ["woman-woman-boy-boy", "family: woman, woman, boy, boy"], "u": "1f469-200d-1f469-200d-1f466-200d-1f466" }, { "n": ["woman-woman-girl-girl", "family: woman, woman, girl, girl"], "u": "1f469-200d-1f469-200d-1f467-200d-1f467" }, { "n": ["man-boy", "family: man, boy"], "u": "1f468-200d-1f466" }, { "n": ["man-boy-boy", "family: man, boy, boy"], "u": "1f468-200d-1f466-200d-1f466" }, { "n": ["man-girl", "family: man, girl"], "u": "1f468-200d-1f467" }, { "n": ["man-girl-boy", "family: man, girl, boy"], "u": "1f468-200d-1f467-200d-1f466" }, { "n": ["man-girl-girl", "family: man, girl, girl"], "u": "1f468-200d-1f467-200d-1f467" }, { "n": ["woman-boy", "family: woman, boy"], "u": "1f469-200d-1f466" }, { "n": ["woman-boy-boy", "family: woman, boy, boy"], "u": "1f469-200d-1f466-200d-1f466" }, { "n": ["woman-girl", "family: woman, girl"], "u": "1f469-200d-1f467" }, { "n": ["woman-girl-boy", "family: woman, girl, boy"], "u": "1f469-200d-1f467-200d-1f466" }, { "n": ["woman-girl-girl", "family: woman, girl, girl"], "u": "1f469-200d-1f467-200d-1f467" }, { "n": ["speaking head", "speaking head in silhouette"], "u": "1f5e3-fe0f" }, { "n": ["bust in silhouette"], "u": "1f464" }, { "n": ["busts in silhouette"], "u": "1f465" }, { "n": ["people hugging"], "u": "1fac2" }, { "n": ["footprints"], "u": "1f463" }], "animals_nature": [{ "n": ["monkey face"], "u": "1f435" }, { "n": ["monkey"], "u": "1f412" }, { "n": ["gorilla"], "u": "1f98d" }, { "n": ["orangutan"], "u": "1f9a7" }, { "n": ["dog", "dog face"], "u": "1f436" }, { "n": ["dog", "dog2"], "u": "1f415" }, { "n": ["guide dog"], "u": "1f9ae" }, { "n": ["service dog"], "u": "1f415-200d-1f9ba" }, { "n": ["poodle"], "u": "1f429" }, { "n": ["wolf", "wolf face"], "u": "1f43a" }, { "n": ["fox face"], "u": "1f98a" }, { "n": ["raccoon"], "u": "1f99d" }, { "n": ["cat", "cat face"], "u": "1f431" }, { "n": ["cat", "cat2"], "u": "1f408" }, { "n": ["black cat"], "u": "1f408-200d-2b1b" }, { "n": ["lion face"], "u": "1f981" }, { "n": ["tiger", "tiger face"], "u": "1f42f" }, { "n": ["tiger", "tiger2"], "u": "1f405" }, { "n": ["leopard"], "u": "1f406" }, { "n": ["horse", "horse face"], "u": "1f434" }, { "n": ["horse", "racehorse"], "u": "1f40e" }, { "n": ["unicorn face"], "u": "1f984" }, { "n": ["zebra face"], "u": "1f993" }, { "n": ["deer"], "u": "1f98c" }, { "n": ["bison"], "u": "1f9ac" }, { "n": ["cow", "cow face"], "u": "1f42e" }, { "n": ["ox"], "u": "1f402" }, { "n": ["water buffalo"], "u": "1f403" }, { "n": ["cow", "cow2"], "u": "1f404" }, { "n": ["pig", "pig face"], "u": "1f437" }, { "n": ["pig", "pig2"], "u": "1f416" }, { "n": ["boar"], "u": "1f417" }, { "n": ["pig nose"], "u": "1f43d" }, { "n": ["ram"], "u": "1f40f" }, { "n": ["sheep"], "u": "1f411" }, { "n": ["goat"], "u": "1f410" }, { "n": ["dromedary camel"], "u": "1f42a" }, { "n": ["camel", "bactrian camel"], "u": "1f42b" }, { "n": ["llama"], "u": "1f999" }, { "n": ["giraffe face"], "u": "1f992" }, { "n": ["elephant"], "u": "1f418" }, { "n": ["mammoth"], "u": "1f9a3" }, { "n": ["rhinoceros"], "u": "1f98f" }, { "n": ["hippopotamus"], "u": "1f99b" }, { "n": ["mouse", "mouse face"], "u": "1f42d" }, { "n": ["mouse", "mouse2"], "u": "1f401" }, { "n": ["rat"], "u": "1f400" }, { "n": ["hamster", "hamster face"], "u": "1f439" }, { "n": ["rabbit", "rabbit face"], "u": "1f430" }, { "n": ["rabbit", "rabbit2"], "u": "1f407" }, { "n": ["chipmunk"], "u": "1f43f-fe0f" }, { "n": ["beaver"], "u": "1f9ab" }, { "n": ["hedgehog"], "u": "1f994" }, { "n": ["bat"], "u": "1f987" }, { "n": ["bear", "bear face"], "u": "1f43b" }, { "n": ["polar bear"], "u": "1f43b-200d-2744-fe0f" }, { "n": ["koala"], "u": "1f428" }, { "n": ["panda face"], "u": "1f43c" }, { "n": ["sloth"], "u": "1f9a5" }, { "n": ["otter"], "u": "1f9a6" }, { "n": ["skunk"], "u": "1f9a8" }, { "n": ["kangaroo"], "u": "1f998" }, { "n": ["badger"], "u": "1f9a1" }, { "n": ["feet", "paw prints"], "u": "1f43e" }, { "n": ["turkey"], "u": "1f983" }, { "n": ["chicken"], "u": "1f414" }, { "n": ["rooster"], "u": "1f413" }, { "n": ["hatching chick"], "u": "1f423" }, { "n": ["baby chick"], "u": "1f424" }, { "n": ["hatched chick", "front-facing baby chick"], "u": "1f425" }, { "n": ["bird"], "u": "1f426" }, { "n": ["penguin"], "u": "1f427" }, { "n": ["dove", "dove of peace"], "u": "1f54a-fe0f" }, { "n": ["eagle"], "u": "1f985" }, { "n": ["duck"], "u": "1f986" }, { "n": ["swan"], "u": "1f9a2" }, { "n": ["owl"], "u": "1f989" }, { "n": ["dodo"], "u": "1f9a4" }, { "n": ["feather"], "u": "1fab6" }, { "n": ["flamingo"], "u": "1f9a9" }, { "n": ["peacock"], "u": "1f99a" }, { "n": ["parrot"], "u": "1f99c" }, { "n": ["frog", "frog face"], "u": "1f438" }, { "n": ["crocodile"], "u": "1f40a" }, { "n": ["turtle"], "u": "1f422" }, { "n": ["lizard"], "u": "1f98e" }, { "n": ["snake"], "u": "1f40d" }, { "n": ["dragon face"], "u": "1f432" }, { "n": ["dragon"], "u": "1f409" }, { "n": ["sauropod"], "u": "1f995" }, { "n": ["t-rex"], "u": "1f996" }, { "n": ["whale", "spouting whale"], "u": "1f433" }, { "n": ["whale", "whale2"], "u": "1f40b" }, { "n": ["dolphin", "flipper"], "u": "1f42c" }, { "n": ["seal"], "u": "1f9ad" }, { "n": ["fish"], "u": "1f41f" }, { "n": ["tropical fish"], "u": "1f420" }, { "n": ["blowfish"], "u": "1f421" }, { "n": ["shark"], "u": "1f988" }, { "n": ["octopus"], "u": "1f419" }, { "n": ["shell", "spiral shell"], "u": "1f41a" }, { "n": ["coral"], "u": "1fab8" }, { "n": ["snail"], "u": "1f40c" }, { "n": ["butterfly"], "u": "1f98b" }, { "n": ["bug"], "u": "1f41b" }, { "n": ["ant"], "u": "1f41c" }, { "n": ["bee", "honeybee"], "u": "1f41d" }, { "n": ["beetle"], "u": "1fab2" }, { "n": ["ladybug", "lady beetle"], "u": "1f41e" }, { "n": ["cricket"], "u": "1f997" }, { "n": ["cockroach"], "u": "1fab3" }, { "n": ["spider"], "u": "1f577-fe0f" }, { "n": ["spider web"], "u": "1f578-fe0f" }, { "n": ["scorpion"], "u": "1f982" }, { "n": ["mosquito"], "u": "1f99f" }, { "n": ["fly"], "u": "1fab0" }, { "n": ["worm"], "u": "1fab1" }, { "n": ["microbe"], "u": "1f9a0" }, { "n": ["bouquet"], "u": "1f490" }, { "n": ["cherry blossom"], "u": "1f338" }, { "n": ["white flower"], "u": "1f4ae" }, { "n": ["lotus"], "u": "1fab7" }, { "n": ["rosette"], "u": "1f3f5-fe0f" }, { "n": ["rose"], "u": "1f339" }, { "n": ["wilted flower"], "u": "1f940" }, { "n": ["hibiscus"], "u": "1f33a" }, { "n": ["sunflower"], "u": "1f33b" }, { "n": ["blossom"], "u": "1f33c" }, { "n": ["tulip"], "u": "1f337" }, { "n": ["seedling"], "u": "1f331" }, { "n": ["potted plant"], "u": "1fab4" }, { "n": ["evergreen tree"], "u": "1f332" }, { "n": ["deciduous tree"], "u": "1f333" }, { "n": ["palm tree"], "u": "1f334" }, { "n": ["cactus"], "u": "1f335" }, { "n": ["ear of rice"], "u": "1f33e" }, { "n": ["herb"], "u": "1f33f" }, { "n": ["shamrock"], "u": "2618-fe0f" }, { "n": ["four leaf clover"], "u": "1f340" }, { "n": ["maple leaf"], "u": "1f341" }, { "n": ["fallen leaf"], "u": "1f342" }, { "n": ["leaves", "leaf fluttering in wind"], "u": "1f343" }, { "n": ["empty nest"], "u": "1fab9" }, { "n": ["nest with eggs"], "u": "1faba" }], "food_drink": [{ "n": ["grapes"], "u": "1f347" }, { "n": ["melon"], "u": "1f348" }, { "n": ["watermelon"], "u": "1f349" }, { "n": ["tangerine"], "u": "1f34a" }, { "n": ["lemon"], "u": "1f34b" }, { "n": ["banana"], "u": "1f34c" }, { "n": ["pineapple"], "u": "1f34d" }, { "n": ["mango"], "u": "1f96d" }, { "n": ["apple", "red apple"], "u": "1f34e" }, { "n": ["green apple"], "u": "1f34f" }, { "n": ["pear"], "u": "1f350" }, { "n": ["peach"], "u": "1f351" }, { "n": ["cherries"], "u": "1f352" }, { "n": ["strawberry"], "u": "1f353" }, { "n": ["blueberries"], "u": "1fad0" }, { "n": ["kiwifruit"], "u": "1f95d" }, { "n": ["tomato"], "u": "1f345" }, { "n": ["olive"], "u": "1fad2" }, { "n": ["coconut"], "u": "1f965" }, { "n": ["avocado"], "u": "1f951" }, { "n": ["eggplant", "aubergine"], "u": "1f346" }, { "n": ["potato"], "u": "1f954" }, { "n": ["carrot"], "u": "1f955" }, { "n": ["corn", "ear of maize"], "u": "1f33d" }, { "n": ["hot pepper"], "u": "1f336-fe0f" }, { "n": ["bell pepper"], "u": "1fad1" }, { "n": ["cucumber"], "u": "1f952" }, { "n": ["leafy green"], "u": "1f96c" }, { "n": ["broccoli"], "u": "1f966" }, { "n": ["garlic"], "u": "1f9c4" }, { "n": ["onion"], "u": "1f9c5" }, { "n": ["mushroom"], "u": "1f344" }, { "n": ["peanuts"], "u": "1f95c" }, { "n": ["beans"], "u": "1fad8" }, { "n": ["chestnut"], "u": "1f330" }, { "n": ["bread"], "u": "1f35e" }, { "n": ["croissant"], "u": "1f950" }, { "n": ["baguette bread"], "u": "1f956" }, { "n": ["flatbread"], "u": "1fad3" }, { "n": ["pretzel"], "u": "1f968" }, { "n": ["bagel"], "u": "1f96f" }, { "n": ["pancakes"], "u": "1f95e" }, { "n": ["waffle"], "u": "1f9c7" }, { "n": ["cheese wedge"], "u": "1f9c0" }, { "n": ["meat on bone"], "u": "1f356" }, { "n": ["poultry leg"], "u": "1f357" }, { "n": ["cut of meat"], "u": "1f969" }, { "n": ["bacon"], "u": "1f953" }, { "n": ["hamburger"], "u": "1f354" }, { "n": ["fries", "french fries"], "u": "1f35f" }, { "n": ["pizza", "slice of pizza"], "u": "1f355" }, { "n": ["hotdog", "hot dog"], "u": "1f32d" }, { "n": ["sandwich"], "u": "1f96a" }, { "n": ["taco"], "u": "1f32e" }, { "n": ["burrito"], "u": "1f32f" }, { "n": ["tamale"], "u": "1fad4" }, { "n": ["stuffed flatbread"], "u": "1f959" }, { "n": ["falafel"], "u": "1f9c6" }, { "n": ["egg"], "u": "1f95a" }, { "n": ["cooking", "fried egg"], "u": "1f373" }, { "n": ["shallow pan of food"], "u": "1f958" }, { "n": ["stew", "pot of food"], "u": "1f372" }, { "n": ["fondue"], "u": "1fad5" }, { "n": ["bowl with spoon"], "u": "1f963" }, { "n": ["green salad"], "u": "1f957" }, { "n": ["popcorn"], "u": "1f37f" }, { "n": ["butter"], "u": "1f9c8" }, { "n": ["salt", "salt shaker"], "u": "1f9c2" }, { "n": ["canned food"], "u": "1f96b" }, { "n": ["bento", "bento box"], "u": "1f371" }, { "n": ["rice cracker"], "u": "1f358" }, { "n": ["rice ball"], "u": "1f359" }, { "n": ["rice", "cooked rice"], "u": "1f35a" }, { "n": ["curry", "curry and rice"], "u": "1f35b" }, { "n": ["ramen", "steaming bowl"], "u": "1f35c" }, { "n": ["spaghetti"], "u": "1f35d" }, { "n": ["sweet potato", "roasted sweet potato"], "u": "1f360" }, { "n": ["oden"], "u": "1f362" }, { "n": ["sushi"], "u": "1f363" }, { "n": ["fried shrimp"], "u": "1f364" }, { "n": ["fish cake", "fish cake with swirl design"], "u": "1f365" }, { "n": ["moon cake"], "u": "1f96e" }, { "n": ["dango"], "u": "1f361" }, { "n": ["dumpling"], "u": "1f95f" }, { "n": ["fortune cookie"], "u": "1f960" }, { "n": ["takeout box"], "u": "1f961" }, { "n": ["crab"], "u": "1f980" }, { "n": ["lobster"], "u": "1f99e" }, { "n": ["shrimp"], "u": "1f990" }, { "n": ["squid"], "u": "1f991" }, { "n": ["oyster"], "u": "1f9aa" }, { "n": ["icecream", "soft ice cream"], "u": "1f366" }, { "n": ["shaved ice"], "u": "1f367" }, { "n": ["ice cream"], "u": "1f368" }, { "n": ["doughnut"], "u": "1f369" }, { "n": ["cookie"], "u": "1f36a" }, { "n": ["birthday", "birthday cake"], "u": "1f382" }, { "n": ["cake", "shortcake"], "u": "1f370" }, { "n": ["cupcake"], "u": "1f9c1" }, { "n": ["pie"], "u": "1f967" }, { "n": ["chocolate bar"], "u": "1f36b" }, { "n": ["candy"], "u": "1f36c" }, { "n": ["lollipop"], "u": "1f36d" }, { "n": ["custard"], "u": "1f36e" }, { "n": ["honey pot"], "u": "1f36f" }, { "n": ["baby bottle"], "u": "1f37c" }, { "n": ["glass of milk"], "u": "1f95b" }, { "n": ["coffee", "hot beverage"], "u": "2615" }, { "n": ["teapot"], "u": "1fad6" }, { "n": ["tea", "teacup without handle"], "u": "1f375" }, { "n": ["sake", "sake bottle and cup"], "u": "1f376" }, { "n": ["champagne", "bottle with popping cork"], "u": "1f37e" }, { "n": ["wine glass"], "u": "1f377" }, { "n": ["cocktail", "cocktail glass"], "u": "1f378" }, { "n": ["tropical drink"], "u": "1f379" }, { "n": ["beer", "beer mug"], "u": "1f37a" }, { "n": ["beers", "clinking beer mugs"], "u": "1f37b" }, { "n": ["clinking glasses"], "u": "1f942" }, { "n": ["tumbler glass"], "u": "1f943" }, { "n": ["pouring liquid"], "u": "1fad7" }, { "n": ["cup with straw"], "u": "1f964" }, { "n": ["bubble tea"], "u": "1f9cb" }, { "n": ["beverage box"], "u": "1f9c3" }, { "n": ["mate drink"], "u": "1f9c9" }, { "n": ["ice cube"], "u": "1f9ca" }, { "n": ["chopsticks"], "u": "1f962" }, { "n": ["knife fork plate", "fork and knife with plate"], "u": "1f37d-fe0f" }, { "n": ["fork and knife"], "u": "1f374" }, { "n": ["spoon"], "u": "1f944" }, { "n": ["hocho", "knife"], "u": "1f52a" }, { "n": ["jar"], "u": "1fad9" }, { "n": ["amphora"], "u": "1f3fa" }], "travel_places": [{ "n": ["earth africa", "earth globe europe-africa"], "u": "1f30d" }, { "n": ["earth americas", "earth globe americas"], "u": "1f30e" }, { "n": ["earth asia", "earth globe asia-australia"], "u": "1f30f" }, { "n": ["globe with meridians"], "u": "1f310" }, { "n": ["world map"], "u": "1f5fa-fe0f" }, { "n": ["japan", "silhouette of japan"], "u": "1f5fe" }, { "n": ["compass"], "u": "1f9ed" }, { "n": ["snow-capped mountain", "snow capped mountain"], "u": "1f3d4-fe0f" }, { "n": ["mountain"], "u": "26f0-fe0f" }, { "n": ["volcano"], "u": "1f30b" }, { "n": ["mount fuji"], "u": "1f5fb" }, { "n": ["camping"], "u": "1f3d5-fe0f" }, { "n": ["beach with umbrella"], "u": "1f3d6-fe0f" }, { "n": ["desert"], "u": "1f3dc-fe0f" }, { "n": ["desert island"], "u": "1f3dd-fe0f" }, { "n": ["national park"], "u": "1f3de-fe0f" }, { "n": ["stadium"], "u": "1f3df-fe0f" }, { "n": ["classical building"], "u": "1f3db-fe0f" }, { "n": ["building construction"], "u": "1f3d7-fe0f" }, { "n": ["brick", "bricks"], "u": "1f9f1" }, { "n": ["rock"], "u": "1faa8" }, { "n": ["wood"], "u": "1fab5" }, { "n": ["hut"], "u": "1f6d6" }, { "n": ["houses", "house buildings"], "u": "1f3d8-fe0f" }, { "n": ["derelict house", "derelict house building"], "u": "1f3da-fe0f" }, { "n": ["house", "house building"], "u": "1f3e0" }, { "n": ["house with garden"], "u": "1f3e1" }, { "n": ["office", "office building"], "u": "1f3e2" }, { "n": ["post office", "japanese post office"], "u": "1f3e3" }, { "n": ["european post office"], "u": "1f3e4" }, { "n": ["hospital"], "u": "1f3e5" }, { "n": ["bank"], "u": "1f3e6" }, { "n": ["hotel"], "u": "1f3e8" }, { "n": ["love hotel"], "u": "1f3e9" }, { "n": ["convenience store"], "u": "1f3ea" }, { "n": ["school"], "u": "1f3eb" }, { "n": ["department store"], "u": "1f3ec" }, { "n": ["factory"], "u": "1f3ed" }, { "n": ["japanese castle"], "u": "1f3ef" }, { "n": ["european castle"], "u": "1f3f0" }, { "n": ["wedding"], "u": "1f492" }, { "n": ["tokyo tower"], "u": "1f5fc" }, { "n": ["statue of liberty"], "u": "1f5fd" }, { "n": ["church"], "u": "26ea" }, { "n": ["mosque"], "u": "1f54c" }, { "n": ["hindu temple"], "u": "1f6d5" }, { "n": ["synagogue"], "u": "1f54d" }, { "n": ["shinto shrine"], "u": "26e9-fe0f" }, { "n": ["kaaba"], "u": "1f54b" }, { "n": ["fountain"], "u": "26f2" }, { "n": ["tent"], "u": "26fa" }, { "n": ["foggy"], "u": "1f301" }, { "n": ["night with stars"], "u": "1f303" }, { "n": ["cityscape"], "u": "1f3d9-fe0f" }, { "n": ["sunrise over mountains"], "u": "1f304" }, { "n": ["sunrise"], "u": "1f305" }, { "n": ["city sunset", "cityscape at dusk"], "u": "1f306" }, { "n": ["city sunrise", "sunset over buildings"], "u": "1f307" }, { "n": ["bridge at night"], "u": "1f309" }, { "n": ["hotsprings", "hot springs"], "u": "2668-fe0f" }, { "n": ["carousel horse"], "u": "1f3a0" }, { "n": ["playground slide"], "u": "1f6dd" }, { "n": ["ferris wheel"], "u": "1f3a1" }, { "n": ["roller coaster"], "u": "1f3a2" }, { "n": ["barber", "barber pole"], "u": "1f488" }, { "n": ["circus tent"], "u": "1f3aa" }, { "n": ["steam locomotive"], "u": "1f682" }, { "n": ["railway car"], "u": "1f683" }, { "n": ["high-speed train", "bullettrain side"], "u": "1f684" }, { "n": ["bullettrain front", "high-speed train with bullet nose"], "u": "1f685" }, { "n": ["train", "train2"], "u": "1f686" }, { "n": ["metro"], "u": "1f687" }, { "n": ["light rail"], "u": "1f688" }, { "n": ["station"], "u": "1f689" }, { "n": ["tram"], "u": "1f68a" }, { "n": ["monorail"], "u": "1f69d" }, { "n": ["mountain railway"], "u": "1f69e" }, { "n": ["train", "tram car"], "u": "1f68b" }, { "n": ["bus"], "u": "1f68c" }, { "n": ["oncoming bus"], "u": "1f68d" }, { "n": ["trolleybus"], "u": "1f68e" }, { "n": ["minibus"], "u": "1f690" }, { "n": ["ambulance"], "u": "1f691" }, { "n": ["fire engine"], "u": "1f692" }, { "n": ["police car"], "u": "1f693" }, { "n": ["oncoming police car"], "u": "1f694" }, { "n": ["taxi"], "u": "1f695" }, { "n": ["oncoming taxi"], "u": "1f696" }, { "n": ["car", "red car", "automobile"], "u": "1f697" }, { "n": ["oncoming automobile"], "u": "1f698" }, { "n": ["blue car", "recreational vehicle"], "u": "1f699" }, { "n": ["pickup truck"], "u": "1f6fb" }, { "n": ["truck", "delivery truck"], "u": "1f69a" }, { "n": ["articulated lorry"], "u": "1f69b" }, { "n": ["tractor"], "u": "1f69c" }, { "n": ["racing car"], "u": "1f3ce-fe0f" }, { "n": ["motorcycle", "racing motorcycle"], "u": "1f3cd-fe0f" }, { "n": ["motor scooter"], "u": "1f6f5" }, { "n": ["manual wheelchair"], "u": "1f9bd" }, { "n": ["motorized wheelchair"], "u": "1f9bc" }, { "n": ["auto rickshaw"], "u": "1f6fa" }, { "n": ["bike", "bicycle"], "u": "1f6b2" }, { "n": ["scooter"], "u": "1f6f4" }, { "n": ["skateboard"], "u": "1f6f9" }, { "n": ["roller skate"], "u": "1f6fc" }, { "n": ["busstop", "bus stop"], "u": "1f68f" }, { "n": ["motorway"], "u": "1f6e3-fe0f" }, { "n": ["railway track"], "u": "1f6e4-fe0f" }, { "n": ["oil drum"], "u": "1f6e2-fe0f" }, { "n": ["fuelpump", "fuel pump"], "u": "26fd" }, { "n": ["wheel"], "u": "1f6de" }, { "n": ["rotating light", "police cars revolving light"], "u": "1f6a8" }, { "n": ["traffic light", "horizontal traffic light"], "u": "1f6a5" }, { "n": ["vertical traffic light"], "u": "1f6a6" }, { "n": ["octagonal sign"], "u": "1f6d1" }, { "n": ["construction", "construction sign"], "u": "1f6a7" }, { "n": ["anchor"], "u": "2693" }, { "n": ["ring buoy"], "u": "1f6df" }, { "n": ["boat", "sailboat"], "u": "26f5" }, { "n": ["canoe"], "u": "1f6f6" }, { "n": ["speedboat"], "u": "1f6a4" }, { "n": ["passenger ship"], "u": "1f6f3-fe0f" }, { "n": ["ferry"], "u": "26f4-fe0f" }, { "n": ["motor boat"], "u": "1f6e5-fe0f" }, { "n": ["ship"], "u": "1f6a2" }, { "n": ["airplane"], "u": "2708-fe0f" }, { "n": ["small airplane"], "u": "1f6e9-fe0f" }, { "n": ["airplane departure"], "u": "1f6eb" }, { "n": ["airplane arriving"], "u": "1f6ec" }, { "n": ["parachute"], "u": "1fa82" }, { "n": ["seat"], "u": "1f4ba" }, { "n": ["helicopter"], "u": "1f681" }, { "n": ["suspension railway"], "u": "1f69f" }, { "n": ["mountain cableway"], "u": "1f6a0" }, { "n": ["aerial tramway"], "u": "1f6a1" }, { "n": ["satellite"], "u": "1f6f0-fe0f" }, { "n": ["rocket"], "u": "1f680" }, { "n": ["flying saucer"], "u": "1f6f8" }, { "n": ["bellhop bell"], "u": "1f6ce-fe0f" }, { "n": ["luggage"], "u": "1f9f3" }, { "n": ["hourglass"], "u": "231b" }, { "n": ["hourglass flowing sand", "hourglass with flowing sand"], "u": "23f3" }, { "n": ["watch"], "u": "231a" }, { "n": ["alarm clock"], "u": "23f0" }, { "n": ["stopwatch"], "u": "23f1-fe0f" }, { "n": ["timer clock"], "u": "23f2-fe0f" }, { "n": ["mantelpiece clock"], "u": "1f570-fe0f" }, { "n": ["clock12", "clock face twelve oclock"], "u": "1f55b" }, { "n": ["clock1230", "clock face twelve-thirty"], "u": "1f567" }, { "n": ["clock1", "clock face one oclock"], "u": "1f550" }, { "n": ["clock130", "clock face one-thirty"], "u": "1f55c" }, { "n": ["clock2", "clock face two oclock"], "u": "1f551" }, { "n": ["clock230", "clock face two-thirty"], "u": "1f55d" }, { "n": ["clock3", "clock face three oclock"], "u": "1f552" }, { "n": ["clock330", "clock face three-thirty"], "u": "1f55e" }, { "n": ["clock4", "clock face four oclock"], "u": "1f553" }, { "n": ["clock430", "clock face four-thirty"], "u": "1f55f" }, { "n": ["clock5", "clock face five oclock"], "u": "1f554" }, { "n": ["clock530", "clock face five-thirty"], "u": "1f560" }, { "n": ["clock6", "clock face six oclock"], "u": "1f555" }, { "n": ["clock630", "clock face six-thirty"], "u": "1f561" }, { "n": ["clock7", "clock face seven oclock"], "u": "1f556" }, { "n": ["clock730", "clock face seven-thirty"], "u": "1f562" }, { "n": ["clock8", "clock face eight oclock"], "u": "1f557" }, { "n": ["clock830", "clock face eight-thirty"], "u": "1f563" }, { "n": ["clock9", "clock face nine oclock"], "u": "1f558" }, { "n": ["clock930", "clock face nine-thirty"], "u": "1f564" }, { "n": ["clock10", "clock face ten oclock"], "u": "1f559" }, { "n": ["clock1030", "clock face ten-thirty"], "u": "1f565" }, { "n": ["clock11", "clock face eleven oclock"], "u": "1f55a" }, { "n": ["clock1130", "clock face eleven-thirty"], "u": "1f566" }, { "n": ["new moon", "new moon symbol"], "u": "1f311" }, { "n": ["waxing crescent moon", "waxing crescent moon symbol"], "u": "1f312" }, { "n": ["first quarter moon", "first quarter moon symbol"], "u": "1f313" }, { "n": ["moon", "waxing gibbous moon", "waxing gibbous moon symbol"], "u": "1f314" }, { "n": ["full moon", "full moon symbol"], "u": "1f315" }, { "n": ["waning gibbous moon", "waning gibbous moon symbol"], "u": "1f316" }, { "n": ["last quarter moon", "last quarter moon symbol"], "u": "1f317" }, { "n": ["waning crescent moon", "waning crescent moon symbol"], "u": "1f318" }, { "n": ["crescent moon"], "u": "1f319" }, { "n": ["new moon with face"], "u": "1f31a" }, { "n": ["first quarter moon with face"], "u": "1f31b" }, { "n": ["last quarter moon with face"], "u": "1f31c" }, { "n": ["thermometer"], "u": "1f321-fe0f" }, { "n": ["sunny", "black sun with rays"], "u": "2600-fe0f" }, { "n": ["full moon with face"], "u": "1f31d" }, { "n": ["sun with face"], "u": "1f31e" }, { "n": ["ringed planet"], "u": "1fa90" }, { "n": ["star", "white medium star"], "u": "2b50" }, { "n": ["star2", "glowing star"], "u": "1f31f" }, { "n": ["stars", "shooting star"], "u": "1f320" }, { "n": ["milky way"], "u": "1f30c" }, { "n": ["cloud"], "u": "2601-fe0f" }, { "n": ["partly sunny", "sun behind cloud"], "u": "26c5" }, { "n": ["thunder cloud and rain", "cloud with lightning and rain"], "u": "26c8-fe0f" }, { "n": ["mostly sunny", "sun small cloud", "sun behind small cloud"], "u": "1f324-fe0f" }, { "n": ["barely sunny", "sun behind cloud", "sun behind large cloud"], "u": "1f325-fe0f" }, { "n": ["partly sunny rain", "sun behind rain cloud"], "u": "1f326-fe0f" }, { "n": ["rain cloud", "cloud with rain"], "u": "1f327-fe0f" }, { "n": ["snow cloud", "cloud with snow"], "u": "1f328-fe0f" }, { "n": ["lightning", "lightning cloud", "cloud with lightning"], "u": "1f329-fe0f" }, { "n": ["tornado", "tornado cloud"], "u": "1f32a-fe0f" }, { "n": ["fog"], "u": "1f32b-fe0f" }, { "n": ["wind face", "wind blowing face"], "u": "1f32c-fe0f" }, { "n": ["cyclone"], "u": "1f300" }, { "n": ["rainbow"], "u": "1f308" }, { "n": ["closed umbrella"], "u": "1f302" }, { "n": ["umbrella"], "u": "2602-fe0f" }, { "n": ["umbrella with rain drops"], "u": "2614" }, { "n": ["umbrella on ground"], "u": "26f1-fe0f" }, { "n": ["zap", "high voltage sign"], "u": "26a1" }, { "n": ["snowflake"], "u": "2744-fe0f" }, { "n": ["snowman"], "u": "2603-fe0f" }, { "n": ["snowman without snow"], "u": "26c4" }, { "n": ["comet"], "u": "2604-fe0f" }, { "n": ["fire"], "u": "1f525" }, { "n": ["droplet"], "u": "1f4a7" }, { "n": ["ocean", "water wave"], "u": "1f30a" }], "activities": [{ "n": ["jack-o-lantern", "jack o lantern"], "u": "1f383" }, { "n": ["christmas tree"], "u": "1f384" }, { "n": ["fireworks"], "u": "1f386" }, { "n": ["sparkler", "firework sparkler"], "u": "1f387" }, { "n": ["firecracker"], "u": "1f9e8" }, { "n": ["sparkles"], "u": "2728" }, { "n": ["balloon"], "u": "1f388" }, { "n": ["tada", "party popper"], "u": "1f389" }, { "n": ["confetti ball"], "u": "1f38a" }, { "n": ["tanabata tree"], "u": "1f38b" }, { "n": ["bamboo", "pine decoration"], "u": "1f38d" }, { "n": ["dolls", "japanese dolls"], "u": "1f38e" }, { "n": ["flags", "carp streamer"], "u": "1f38f" }, { "n": ["wind chime"], "u": "1f390" }, { "n": ["rice scene", "moon viewing ceremony"], "u": "1f391" }, { "n": ["red envelope", "red gift envelope"], "u": "1f9e7" }, { "n": ["ribbon"], "u": "1f380" }, { "n": ["gift", "wrapped present"], "u": "1f381" }, { "n": ["reminder ribbon"], "u": "1f397-fe0f" }, { "n": ["admission tickets"], "u": "1f39f-fe0f" }, { "n": ["ticket"], "u": "1f3ab" }, { "n": ["medal", "military medal"], "u": "1f396-fe0f" }, { "n": ["trophy"], "u": "1f3c6" }, { "n": ["sports medal"], "u": "1f3c5" }, { "n": ["first place medal"], "u": "1f947" }, { "n": ["second place medal"], "u": "1f948" }, { "n": ["third place medal"], "u": "1f949" }, { "n": ["soccer", "soccer ball"], "u": "26bd" }, { "n": ["baseball"], "u": "26be" }, { "n": ["softball"], "u": "1f94e" }, { "n": ["basketball", "basketball and hoop"], "u": "1f3c0" }, { "n": ["volleyball"], "u": "1f3d0" }, { "n": ["football", "american football"], "u": "1f3c8" }, { "n": ["rugby football"], "u": "1f3c9" }, { "n": ["tennis", "tennis racquet and ball"], "u": "1f3be" }, { "n": ["flying disc"], "u": "1f94f" }, { "n": ["bowling"], "u": "1f3b3" }, { "n": ["cricket bat and ball"], "u": "1f3cf" }, { "n": ["field hockey stick and ball"], "u": "1f3d1" }, { "n": ["ice hockey stick and puck"], "u": "1f3d2" }, { "n": ["lacrosse", "lacrosse stick and ball"], "u": "1f94d" }, { "n": ["table tennis paddle and ball"], "u": "1f3d3" }, { "n": ["badminton racquet and shuttlecock"], "u": "1f3f8" }, { "n": ["boxing glove"], "u": "1f94a" }, { "n": ["martial arts uniform"], "u": "1f94b" }, { "n": ["goal net"], "u": "1f945" }, { "n": ["golf", "flag in hole"], "u": "26f3" }, { "n": ["ice skate"], "u": "26f8-fe0f" }, { "n": ["fishing pole and fish"], "u": "1f3a3" }, { "n": ["diving mask"], "u": "1f93f" }, { "n": ["running shirt with sash"], "u": "1f3bd" }, { "n": ["ski", "ski and ski boot"], "u": "1f3bf" }, { "n": ["sled"], "u": "1f6f7" }, { "n": ["curling stone"], "u": "1f94c" }, { "n": ["dart", "direct hit"], "u": "1f3af" }, { "n": ["yo-yo"], "u": "1fa80" }, { "n": ["kite"], "u": "1fa81" }, { "n": ["8ball", "billiards"], "u": "1f3b1" }, { "n": ["crystal ball"], "u": "1f52e" }, { "n": ["magic wand"], "u": "1fa84" }, { "n": ["nazar amulet"], "u": "1f9ff" }, { "n": ["hamsa"], "u": "1faac" }, { "n": ["video game"], "u": "1f3ae" }, { "n": ["joystick"], "u": "1f579-fe0f" }, { "n": ["slot machine"], "u": "1f3b0" }, { "n": ["game die"], "u": "1f3b2" }, { "n": ["jigsaw", "jigsaw puzzle piece"], "u": "1f9e9" }, { "n": ["teddy bear"], "u": "1f9f8" }, { "n": ["pinata"], "u": "1fa85" }, { "n": ["mirror ball"], "u": "1faa9" }, { "n": ["nesting dolls"], "u": "1fa86" }, { "n": ["spades", "black spade suit"], "u": "2660-fe0f" }, { "n": ["hearts", "black heart suit"], "u": "2665-fe0f" }, { "n": ["diamonds", "black diamond suit"], "u": "2666-fe0f" }, { "n": ["clubs", "black club suit"], "u": "2663-fe0f" }, { "n": ["chess pawn"], "u": "265f-fe0f" }, { "n": ["black joker", "playing card black joker"], "u": "1f0cf" }, { "n": ["mahjong", "mahjong tile red dragon"], "u": "1f004" }, { "n": ["flower playing cards"], "u": "1f3b4" }, { "n": ["performing arts"], "u": "1f3ad" }, { "n": ["framed picture", "frame with picture"], "u": "1f5bc-fe0f" }, { "n": ["art", "artist palette"], "u": "1f3a8" }, { "n": ["thread", "spool of thread"], "u": "1f9f5" }, { "n": ["sewing needle"], "u": "1faa1" }, { "n": ["yarn", "ball of yarn"], "u": "1f9f6" }, { "n": ["knot"], "u": "1faa2" }], "objects": [{ "n": ["eyeglasses"], "u": "1f453" }, { "n": ["sunglasses", "dark sunglasses"], "u": "1f576-fe0f" }, { "n": ["goggles"], "u": "1f97d" }, { "n": ["lab coat"], "u": "1f97c" }, { "n": ["safety vest"], "u": "1f9ba" }, { "n": ["necktie"], "u": "1f454" }, { "n": ["shirt", "tshirt", "t-shirt"], "u": "1f455" }, { "n": ["jeans"], "u": "1f456" }, { "n": ["scarf"], "u": "1f9e3" }, { "n": ["gloves"], "u": "1f9e4" }, { "n": ["coat"], "u": "1f9e5" }, { "n": ["socks"], "u": "1f9e6" }, { "n": ["dress"], "u": "1f457" }, { "n": ["kimono"], "u": "1f458" }, { "n": ["sari"], "u": "1f97b" }, { "n": ["one-piece swimsuit"], "u": "1fa71" }, { "n": ["briefs"], "u": "1fa72" }, { "n": ["shorts"], "u": "1fa73" }, { "n": ["bikini"], "u": "1f459" }, { "n": ["womans clothes"], "u": "1f45a" }, { "n": ["purse"], "u": "1f45b" }, { "n": ["handbag"], "u": "1f45c" }, { "n": ["pouch"], "u": "1f45d" }, { "n": ["shopping bags"], "u": "1f6cd-fe0f" }, { "n": ["school satchel"], "u": "1f392" }, { "n": ["thong sandal"], "u": "1fa74" }, { "n": ["shoe", "mans shoe"], "u": "1f45e" }, { "n": ["athletic shoe"], "u": "1f45f" }, { "n": ["hiking boot"], "u": "1f97e" }, { "n": ["flat shoe", "womans flat shoe"], "u": "1f97f" }, { "n": ["high heel", "high-heeled shoe"], "u": "1f460" }, { "n": ["sandal", "womans sandal"], "u": "1f461" }, { "n": ["ballet shoes"], "u": "1fa70" }, { "n": ["boot", "womans boots"], "u": "1f462" }, { "n": ["crown"], "u": "1f451" }, { "n": ["womans hat"], "u": "1f452" }, { "n": ["tophat", "top hat"], "u": "1f3a9" }, { "n": ["mortar board", "graduation cap"], "u": "1f393" }, { "n": ["billed cap"], "u": "1f9e2" }, { "n": ["military helmet"], "u": "1fa96" }, { "n": ["rescue worker\u2019s helmet", "helmet with white cross"], "u": "26d1-fe0f" }, { "n": ["prayer beads"], "u": "1f4ff" }, { "n": ["lipstick"], "u": "1f484" }, { "n": ["ring"], "u": "1f48d" }, { "n": ["gem", "gem stone"], "u": "1f48e" }, { "n": ["mute", "speaker with cancellation stroke"], "u": "1f507" }, { "n": ["speaker"], "u": "1f508" }, { "n": ["sound", "speaker with one sound wave"], "u": "1f509" }, { "n": ["loud sound", "speaker with three sound waves"], "u": "1f50a" }, { "n": ["loudspeaker", "public address loudspeaker"], "u": "1f4e2" }, { "n": ["mega", "cheering megaphone"], "u": "1f4e3" }, { "n": ["postal horn"], "u": "1f4ef" }, { "n": ["bell"], "u": "1f514" }, { "n": ["no bell", "bell with cancellation stroke"], "u": "1f515" }, { "n": ["musical score"], "u": "1f3bc" }, { "n": ["musical note"], "u": "1f3b5" }, { "n": ["notes", "multiple musical notes"], "u": "1f3b6" }, { "n": ["studio microphone"], "u": "1f399-fe0f" }, { "n": ["level slider"], "u": "1f39a-fe0f" }, { "n": ["control knobs"], "u": "1f39b-fe0f" }, { "n": ["microphone"], "u": "1f3a4" }, { "n": ["headphone", "headphones"], "u": "1f3a7" }, { "n": ["radio"], "u": "1f4fb" }, { "n": ["saxophone"], "u": "1f3b7" }, { "n": ["accordion"], "u": "1fa97" }, { "n": ["guitar"], "u": "1f3b8" }, { "n": ["musical keyboard"], "u": "1f3b9" }, { "n": ["trumpet"], "u": "1f3ba" }, { "n": ["violin"], "u": "1f3bb" }, { "n": ["banjo"], "u": "1fa95" }, { "n": ["drum with drumsticks"], "u": "1f941" }, { "n": ["long drum"], "u": "1fa98" }, { "n": ["iphone", "mobile phone"], "u": "1f4f1" }, { "n": ["calling", "mobile phone with rightwards arrow at left"], "u": "1f4f2" }, { "n": ["phone", "telephone", "black telephone"], "u": "260e-fe0f" }, { "n": ["telephone receiver"], "u": "1f4de" }, { "n": ["pager"], "u": "1f4df" }, { "n": ["fax", "fax machine"], "u": "1f4e0" }, { "n": ["battery"], "u": "1f50b" }, { "n": ["low battery"], "u": "1faab" }, { "n": ["electric plug"], "u": "1f50c" }, { "n": ["computer", "personal computer"], "u": "1f4bb" }, { "n": ["desktop computer"], "u": "1f5a5-fe0f" }, { "n": ["printer"], "u": "1f5a8-fe0f" }, { "n": ["keyboard"], "u": "2328-fe0f" }, { "n": ["computer mouse", "three button mouse"], "u": "1f5b1-fe0f" }, { "n": ["trackball"], "u": "1f5b2-fe0f" }, { "n": ["minidisc"], "u": "1f4bd" }, { "n": ["floppy disk"], "u": "1f4be" }, { "n": ["cd", "optical disc"], "u": "1f4bf" }, { "n": ["dvd"], "u": "1f4c0" }, { "n": ["abacus"], "u": "1f9ee" }, { "n": ["movie camera"], "u": "1f3a5" }, { "n": ["film frames"], "u": "1f39e-fe0f" }, { "n": ["film projector"], "u": "1f4fd-fe0f" }, { "n": ["clapper", "clapper board"], "u": "1f3ac" }, { "n": ["tv", "television"], "u": "1f4fa" }, { "n": ["camera"], "u": "1f4f7" }, { "n": ["camera with flash"], "u": "1f4f8" }, { "n": ["video camera"], "u": "1f4f9" }, { "n": ["vhs", "videocassette"], "u": "1f4fc" }, { "n": ["mag", "left-pointing magnifying glass"], "u": "1f50d" }, { "n": ["mag right", "right-pointing magnifying glass"], "u": "1f50e" }, { "n": ["candle"], "u": "1f56f-fe0f" }, { "n": ["bulb", "electric light bulb"], "u": "1f4a1" }, { "n": ["flashlight", "electric torch"], "u": "1f526" }, { "n": ["lantern", "izakaya lantern"], "u": "1f3ee" }, { "n": ["diya lamp"], "u": "1fa94" }, { "n": ["notebook with decorative cover"], "u": "1f4d4" }, { "n": ["closed book"], "u": "1f4d5" }, { "n": ["book", "open book"], "u": "1f4d6" }, { "n": ["green book"], "u": "1f4d7" }, { "n": ["blue book"], "u": "1f4d8" }, { "n": ["orange book"], "u": "1f4d9" }, { "n": ["books"], "u": "1f4da" }, { "n": ["notebook"], "u": "1f4d3" }, { "n": ["ledger"], "u": "1f4d2" }, { "n": ["page with curl"], "u": "1f4c3" }, { "n": ["scroll"], "u": "1f4dc" }, { "n": ["page facing up"], "u": "1f4c4" }, { "n": ["newspaper"], "u": "1f4f0" }, { "n": ["rolled-up newspaper", "rolled up newspaper"], "u": "1f5de-fe0f" }, { "n": ["bookmark tabs"], "u": "1f4d1" }, { "n": ["bookmark"], "u": "1f516" }, { "n": ["label"], "u": "1f3f7-fe0f" }, { "n": ["moneybag", "money bag"], "u": "1f4b0" }, { "n": ["coin"], "u": "1fa99" }, { "n": ["yen", "banknote with yen sign"], "u": "1f4b4" }, { "n": ["dollar", "banknote with dollar sign"], "u": "1f4b5" }, { "n": ["euro", "banknote with euro sign"], "u": "1f4b6" }, { "n": ["pound", "banknote with pound sign"], "u": "1f4b7" }, { "n": ["money with wings"], "u": "1f4b8" }, { "n": ["credit card"], "u": "1f4b3" }, { "n": ["receipt"], "u": "1f9fe" }, { "n": ["chart", "chart with upwards trend and yen sign"], "u": "1f4b9" }, { "n": ["email", "envelope"], "u": "2709-fe0f" }, { "n": ["e-mail", "e-mail symbol"], "u": "1f4e7" }, { "n": ["incoming envelope"], "u": "1f4e8" }, { "n": ["envelope with arrow", "envelope with downwards arrow above"], "u": "1f4e9" }, { "n": ["outbox tray"], "u": "1f4e4" }, { "n": ["inbox tray"], "u": "1f4e5" }, { "n": ["package"], "u": "1f4e6" }, { "n": ["mailbox", "closed mailbox with raised flag"], "u": "1f4eb" }, { "n": ["mailbox closed", "closed mailbox with lowered flag"], "u": "1f4ea" }, { "n": ["mailbox with mail", "open mailbox with raised flag"], "u": "1f4ec" }, { "n": ["mailbox with no mail", "open mailbox with lowered flag"], "u": "1f4ed" }, { "n": ["postbox"], "u": "1f4ee" }, { "n": ["ballot box with ballot"], "u": "1f5f3-fe0f" }, { "n": ["pencil", "pencil2"], "u": "270f-fe0f" }, { "n": ["black nib"], "u": "2712-fe0f" }, { "n": ["fountain pen", "lower left fountain pen"], "u": "1f58b-fe0f" }, { "n": ["pen", "lower left ballpoint pen"], "u": "1f58a-fe0f" }, { "n": ["paintbrush", "lower left paintbrush"], "u": "1f58c-fe0f" }, { "n": ["crayon", "lower left crayon"], "u": "1f58d-fe0f" }, { "n": ["memo", "pencil"], "u": "1f4dd" }, { "n": ["briefcase"], "u": "1f4bc" }, { "n": ["file folder"], "u": "1f4c1" }, { "n": ["open file folder"], "u": "1f4c2" }, { "n": ["card index dividers"], "u": "1f5c2-fe0f" }, { "n": ["date", "calendar"], "u": "1f4c5" }, { "n": ["calendar", "tear-off calendar"], "u": "1f4c6" }, { "n": ["spiral notepad", "spiral note pad"], "u": "1f5d2-fe0f" }, { "n": ["spiral calendar", "spiral calendar pad"], "u": "1f5d3-fe0f" }, { "n": ["card index"], "u": "1f4c7" }, { "n": ["chart with upwards trend"], "u": "1f4c8" }, { "n": ["chart with downwards trend"], "u": "1f4c9" }, { "n": ["bar chart"], "u": "1f4ca" }, { "n": ["clipboard"], "u": "1f4cb" }, { "n": ["pushpin"], "u": "1f4cc" }, { "n": ["round pushpin"], "u": "1f4cd" }, { "n": ["paperclip"], "u": "1f4ce" }, { "n": ["linked paperclips"], "u": "1f587-fe0f" }, { "n": ["straight ruler"], "u": "1f4cf" }, { "n": ["triangular ruler"], "u": "1f4d0" }, { "n": ["scissors", "black scissors"], "u": "2702-fe0f" }, { "n": ["card file box"], "u": "1f5c3-fe0f" }, { "n": ["file cabinet"], "u": "1f5c4-fe0f" }, { "n": ["wastebasket"], "u": "1f5d1-fe0f" }, { "n": ["lock"], "u": "1f512" }, { "n": ["unlock", "open lock"], "u": "1f513" }, { "n": ["lock with ink pen"], "u": "1f50f" }, { "n": ["closed lock with key"], "u": "1f510" }, { "n": ["key"], "u": "1f511" }, { "n": ["old key"], "u": "1f5dd-fe0f" }, { "n": ["hammer"], "u": "1f528" }, { "n": ["axe"], "u": "1fa93" }, { "n": ["pick"], "u": "26cf-fe0f" }, { "n": ["hammer and pick"], "u": "2692-fe0f" }, { "n": ["hammer and wrench"], "u": "1f6e0-fe0f" }, { "n": ["dagger", "dagger knife"], "u": "1f5e1-fe0f" }, { "n": ["crossed swords"], "u": "2694-fe0f" }, { "n": ["gun", "pistol"], "u": "1f52b" }, { "n": ["boomerang"], "u": "1fa83" }, { "n": ["bow and arrow"], "u": "1f3f9" }, { "n": ["shield"], "u": "1f6e1-fe0f" }, { "n": ["carpentry saw"], "u": "1fa9a" }, { "n": ["wrench"], "u": "1f527" }, { "n": ["screwdriver"], "u": "1fa9b" }, { "n": ["nut and bolt"], "u": "1f529" }, { "n": ["gear"], "u": "2699-fe0f" }, { "n": ["clamp", "compression"], "u": "1f5dc-fe0f" }, { "n": ["scales", "balance scale"], "u": "2696-fe0f" }, { "n": ["probing cane"], "u": "1f9af" }, { "n": ["link", "link symbol"], "u": "1f517" }, { "n": ["chains"], "u": "26d3-fe0f" }, { "n": ["hook"], "u": "1fa9d" }, { "n": ["toolbox"], "u": "1f9f0" }, { "n": ["magnet"], "u": "1f9f2" }, { "n": ["ladder"], "u": "1fa9c" }, { "n": ["alembic"], "u": "2697-fe0f" }, { "n": ["test tube"], "u": "1f9ea" }, { "n": ["petri dish"], "u": "1f9eb" }, { "n": ["dna", "dna double helix"], "u": "1f9ec" }, { "n": ["microscope"], "u": "1f52c" }, { "n": ["telescope"], "u": "1f52d" }, { "n": ["satellite antenna"], "u": "1f4e1" }, { "n": ["syringe"], "u": "1f489" }, { "n": ["drop of blood"], "u": "1fa78" }, { "n": ["pill"], "u": "1f48a" }, { "n": ["adhesive bandage"], "u": "1fa79" }, { "n": ["crutch"], "u": "1fa7c" }, { "n": ["stethoscope"], "u": "1fa7a" }, { "n": ["x-ray"], "u": "1fa7b" }, { "n": ["door"], "u": "1f6aa" }, { "n": ["elevator"], "u": "1f6d7" }, { "n": ["mirror"], "u": "1fa9e" }, { "n": ["window"], "u": "1fa9f" }, { "n": ["bed"], "u": "1f6cf-fe0f" }, { "n": ["couch and lamp"], "u": "1f6cb-fe0f" }, { "n": ["chair"], "u": "1fa91" }, { "n": ["toilet"], "u": "1f6bd" }, { "n": ["plunger"], "u": "1faa0" }, { "n": ["shower"], "u": "1f6bf" }, { "n": ["bathtub"], "u": "1f6c1" }, { "n": ["mouse trap"], "u": "1faa4" }, { "n": ["razor"], "u": "1fa92" }, { "n": ["lotion bottle"], "u": "1f9f4" }, { "n": ["safety pin"], "u": "1f9f7" }, { "n": ["broom"], "u": "1f9f9" }, { "n": ["basket"], "u": "1f9fa" }, { "n": ["roll of paper"], "u": "1f9fb" }, { "n": ["bucket"], "u": "1faa3" }, { "n": ["soap", "bar of soap"], "u": "1f9fc" }, { "n": ["bubbles"], "u": "1fae7" }, { "n": ["toothbrush"], "u": "1faa5" }, { "n": ["sponge"], "u": "1f9fd" }, { "n": ["fire extinguisher"], "u": "1f9ef" }, { "n": ["shopping trolley"], "u": "1f6d2" }, { "n": ["smoking", "smoking symbol"], "u": "1f6ac" }, { "n": ["coffin"], "u": "26b0-fe0f" }, { "n": ["headstone"], "u": "1faa6" }, { "n": ["funeral urn"], "u": "26b1-fe0f" }, { "n": ["moyai"], "u": "1f5ff" }, { "n": ["placard"], "u": "1faa7" }, { "n": ["identification card"], "u": "1faaa" }], "symbols": [{ "n": ["atm", "automated teller machine"], "u": "1f3e7" }, { "n": ["put litter in its place", "put litter in its place symbol"], "u": "1f6ae" }, { "n": ["potable water", "potable water symbol"], "u": "1f6b0" }, { "n": ["wheelchair", "wheelchair symbol"], "u": "267f" }, { "n": ["mens", "mens symbol"], "u": "1f6b9" }, { "n": ["womens", "womens symbol"], "u": "1f6ba" }, { "n": ["restroom"], "u": "1f6bb" }, { "n": ["baby symbol"], "u": "1f6bc" }, { "n": ["wc", "water closet"], "u": "1f6be" }, { "n": ["passport control"], "u": "1f6c2" }, { "n": ["customs"], "u": "1f6c3" }, { "n": ["baggage claim"], "u": "1f6c4" }, { "n": ["left luggage"], "u": "1f6c5" }, { "n": ["warning", "warning sign"], "u": "26a0-fe0f" }, { "n": ["children crossing"], "u": "1f6b8" }, { "n": ["no entry"], "u": "26d4" }, { "n": ["no entry sign"], "u": "1f6ab" }, { "n": ["no bicycles"], "u": "1f6b3" }, { "n": ["no smoking", "no smoking symbol"], "u": "1f6ad" }, { "n": ["do not litter", "do not litter symbol"], "u": "1f6af" }, { "n": ["non-potable water", "non-potable water symbol"], "u": "1f6b1" }, { "n": ["no pedestrians"], "u": "1f6b7" }, { "n": ["no mobile phones"], "u": "1f4f5" }, { "n": ["underage", "no one under eighteen symbol"], "u": "1f51e" }, { "n": ["radioactive", "radioactive sign"], "u": "2622-fe0f" }, { "n": ["biohazard", "biohazard sign"], "u": "2623-fe0f" }, { "n": ["arrow up", "upwards black arrow"], "u": "2b06-fe0f" }, { "n": ["north east arrow", "arrow upper right"], "u": "2197-fe0f" }, { "n": ["arrow right", "black rightwards arrow"], "u": "27a1-fe0f" }, { "n": ["south east arrow", "arrow lower right"], "u": "2198-fe0f" }, { "n": ["arrow down", "downwards black arrow"], "u": "2b07-fe0f" }, { "n": ["south west arrow", "arrow lower left"], "u": "2199-fe0f" }, { "n": ["arrow left", "leftwards black arrow"], "u": "2b05-fe0f" }, { "n": ["north west arrow", "arrow upper left"], "u": "2196-fe0f" }, { "n": ["up down arrow", "arrow up down"], "u": "2195-fe0f" }, { "n": ["left right arrow"], "u": "2194-fe0f" }, { "n": ["leftwards arrow with hook"], "u": "21a9-fe0f" }, { "n": ["arrow right hook", "rightwards arrow with hook"], "u": "21aa-fe0f" }, { "n": ["arrow heading up", "arrow pointing rightwards then curving upwards"], "u": "2934-fe0f" }, { "n": ["arrow heading down", "arrow pointing rightwards then curving downwards"], "u": "2935-fe0f" }, { "n": ["arrows clockwise", "clockwise downwards and upwards open circle arrows"], "u": "1f503" }, { "n": ["arrows counterclockwise", "anticlockwise downwards and upwards open circle arrows"], "u": "1f504" }, { "n": ["back", "back with leftwards arrow above"], "u": "1f519" }, { "n": ["end", "end with leftwards arrow above"], "u": "1f51a" }, { "n": ["on", "on with exclamation mark with left right arrow above"], "u": "1f51b" }, { "n": ["soon", "soon with rightwards arrow above"], "u": "1f51c" }, { "n": ["top", "top with upwards arrow above"], "u": "1f51d" }, { "n": ["place of worship"], "u": "1f6d0" }, { "n": ["atom symbol"], "u": "269b-fe0f" }, { "n": ["om", "om symbol"], "u": "1f549-fe0f" }, { "n": ["star of david"], "u": "2721-fe0f" }, { "n": ["wheel of dharma"], "u": "2638-fe0f" }, { "n": ["yin yang"], "u": "262f-fe0f" }, { "n": ["latin cross"], "u": "271d-fe0f" }, { "n": ["orthodox cross"], "u": "2626-fe0f" }, { "n": ["star and crescent"], "u": "262a-fe0f" }, { "n": ["peace symbol"], "u": "262e-fe0f" }, { "n": ["menorah with nine branches"], "u": "1f54e" }, { "n": ["six pointed star", "six pointed star with middle dot"], "u": "1f52f" }, { "n": ["aries"], "u": "2648" }, { "n": ["taurus"], "u": "2649" }, { "n": ["gemini"], "u": "264a" }, { "n": ["cancer"], "u": "264b" }, { "n": ["leo"], "u": "264c" }, { "n": ["virgo"], "u": "264d" }, { "n": ["libra"], "u": "264e" }, { "n": ["scorpius"], "u": "264f" }, { "n": ["sagittarius"], "u": "2650" }, { "n": ["capricorn"], "u": "2651" }, { "n": ["aquarius"], "u": "2652" }, { "n": ["pisces"], "u": "2653" }, { "n": ["ophiuchus"], "u": "26ce" }, { "n": ["twisted rightwards arrows"], "u": "1f500" }, { "n": ["repeat", "clockwise rightwards and leftwards open circle arrows"], "u": "1f501" }, { "n": ["repeat one", "clockwise rightwards and leftwards open circle arrows with circled one overlay"], "u": "1f502" }, { "n": ["arrow forward", "black right-pointing triangle"], "u": "25b6-fe0f" }, { "n": ["fast forward", "black right-pointing double triangle"], "u": "23e9" }, { "n": ["next track button", "black right pointing double triangle with vertical bar"], "u": "23ed-fe0f" }, { "n": ["play or pause button", "black right pointing triangle with double vertical bar"], "u": "23ef-fe0f" }, { "n": ["arrow backward", "black left-pointing triangle"], "u": "25c0-fe0f" }, { "n": ["rewind", "black left-pointing double triangle"], "u": "23ea" }, { "n": ["last track button", "black left pointing double triangle with vertical bar"], "u": "23ee-fe0f" }, { "n": ["arrow up small", "up-pointing small red triangle"], "u": "1f53c" }, { "n": ["arrow double up", "black up-pointing double triangle"], "u": "23eb" }, { "n": ["arrow down small", "down-pointing small red triangle"], "u": "1f53d" }, { "n": ["arrow double down", "black down-pointing double triangle"], "u": "23ec" }, { "n": ["pause button", "double vertical bar"], "u": "23f8-fe0f" }, { "n": ["stop button", "black square for stop"], "u": "23f9-fe0f" }, { "n": ["record button", "black circle for record"], "u": "23fa-fe0f" }, { "n": ["eject", "eject button"], "u": "23cf-fe0f" }, { "n": ["cinema"], "u": "1f3a6" }, { "n": ["low brightness", "low brightness symbol"], "u": "1f505" }, { "n": ["high brightness", "high brightness symbol"], "u": "1f506" }, { "n": ["signal strength", "antenna with bars"], "u": "1f4f6" }, { "n": ["vibration mode"], "u": "1f4f3" }, { "n": ["mobile phone off"], "u": "1f4f4" }, { "n": ["female sign"], "u": "2640-fe0f" }, { "n": ["male sign"], "u": "2642-fe0f" }, { "n": ["transgender symbol"], "u": "26a7-fe0f" }, { "n": ["heavy multiplication x"], "u": "2716-fe0f" }, { "n": ["heavy plus sign"], "u": "2795" }, { "n": ["heavy minus sign"], "u": "2796" }, { "n": ["heavy division sign"], "u": "2797" }, { "n": ["heavy equals sign"], "u": "1f7f0" }, { "n": ["infinity"], "u": "267e-fe0f" }, { "n": ["bangbang", "double exclamation mark"], "u": "203c-fe0f" }, { "n": ["interrobang", "exclamation question mark"], "u": "2049-fe0f" }, { "n": ["question", "black question mark ornament"], "u": "2753" }, { "n": ["grey question", "white question mark ornament"], "u": "2754" }, { "n": ["grey exclamation", "white exclamation mark ornament"], "u": "2755" }, { "n": ["exclamation", "heavy exclamation mark", "heavy exclamation mark symbol"], "u": "2757" }, { "n": ["wavy dash"], "u": "3030-fe0f" }, { "n": ["currency exchange"], "u": "1f4b1" }, { "n": ["heavy dollar sign"], "u": "1f4b2" }, { "n": ["medical symbol", "staff of aesculapius"], "u": "2695-fe0f" }, { "n": ["recycle", "black universal recycling symbol"], "u": "267b-fe0f" }, { "n": ["fleur-de-lis", "fleur de lis"], "u": "269c-fe0f" }, { "n": ["trident", "trident emblem"], "u": "1f531" }, { "n": ["name badge"], "u": "1f4db" }, { "n": ["beginner", "japanese symbol for beginner"], "u": "1f530" }, { "n": ["o", "heavy large circle"], "u": "2b55" }, { "n": ["white check mark", "white heavy check mark"], "u": "2705" }, { "n": ["ballot box with check"], "u": "2611-fe0f" }, { "n": ["heavy check mark"], "u": "2714-fe0f" }, { "n": ["x", "cross mark"], "u": "274c" }, { "n": ["negative squared cross mark"], "u": "274e" }, { "n": ["curly loop"], "u": "27b0" }, { "n": ["loop", "double curly loop"], "u": "27bf" }, { "n": ["part alternation mark"], "u": "303d-fe0f" }, { "n": ["eight spoked asterisk"], "u": "2733-fe0f" }, { "n": ["eight pointed black star"], "u": "2734-fe0f" }, { "n": ["sparkle"], "u": "2747-fe0f" }, { "n": ["copyright", "copyright sign"], "u": "00a9-fe0f" }, { "n": ["registered", "registered sign"], "u": "00ae-fe0f" }, { "n": ["tm", "trade mark sign"], "u": "2122-fe0f" }, { "n": ["hash", "hash key"], "u": "0023-fe0f-20e3" }, { "n": ["keycap: *", "keycap star"], "u": "002a-fe0f-20e3" }, { "n": ["zero", "keycap 0"], "u": "0030-fe0f-20e3" }, { "n": ["one", "keycap 1"], "u": "0031-fe0f-20e3" }, { "n": ["two", "keycap 2"], "u": "0032-fe0f-20e3" }, { "n": ["three", "keycap 3"], "u": "0033-fe0f-20e3" }, { "n": ["four", "keycap 4"], "u": "0034-fe0f-20e3" }, { "n": ["five", "keycap 5"], "u": "0035-fe0f-20e3" }, { "n": ["six", "keycap 6"], "u": "0036-fe0f-20e3" }, { "n": ["seven", "keycap 7"], "u": "0037-fe0f-20e3" }, { "n": ["eight", "keycap 8"], "u": "0038-fe0f-20e3" }, { "n": ["nine", "keycap 9"], "u": "0039-fe0f-20e3" }, { "n": ["keycap ten"], "u": "1f51f" }, { "n": ["capital abcd", "input symbol for latin capital letters"], "u": "1f520" }, { "n": ["abcd", "input symbol for latin small letters"], "u": "1f521" }, { "n": ["1234", "input symbol for numbers"], "u": "1f522" }, { "n": ["symbols", "input symbol for symbols"], "u": "1f523" }, { "n": ["abc", "input symbol for latin letters"], "u": "1f524" }, { "n": ["a", "negative squared latin capital letter a"], "u": "1f170-fe0f" }, { "n": ["ab", "negative squared ab"], "u": "1f18e" }, { "n": ["b", "negative squared latin capital letter b"], "u": "1f171-fe0f" }, { "n": ["cl", "squared cl"], "u": "1f191" }, { "n": ["cool", "squared cool"], "u": "1f192" }, { "n": ["free", "squared free"], "u": "1f193" }, { "n": ["information source"], "u": "2139-fe0f" }, { "n": ["id", "squared id"], "u": "1f194" }, { "n": ["m", "circled latin capital letter m"], "u": "24c2-fe0f" }, { "n": ["new", "squared new"], "u": "1f195" }, { "n": ["ng", "squared ng"], "u": "1f196" }, { "n": ["o2", "negative squared latin capital letter o"], "u": "1f17e-fe0f" }, { "n": ["ok", "squared ok"], "u": "1f197" }, { "n": ["parking", "negative squared latin capital letter p"], "u": "1f17f-fe0f" }, { "n": ["sos", "squared sos"], "u": "1f198" }, { "n": ["up", "squared up with exclamation mark"], "u": "1f199" }, { "n": ["vs", "squared vs"], "u": "1f19a" }, { "n": ["koko", "squared katakana koko"], "u": "1f201" }, { "n": ["sa", "squared katakana sa"], "u": "1f202-fe0f" }, { "n": ["u6708", "squared cjk unified ideograph-6708"], "u": "1f237-fe0f" }, { "n": ["u6709", "squared cjk unified ideograph-6709"], "u": "1f236" }, { "n": ["u6307", "squared cjk unified ideograph-6307"], "u": "1f22f" }, { "n": ["ideograph advantage", "circled ideograph advantage"], "u": "1f250" }, { "n": ["u5272", "squared cjk unified ideograph-5272"], "u": "1f239" }, { "n": ["u7121", "squared cjk unified ideograph-7121"], "u": "1f21a" }, { "n": ["u7981", "squared cjk unified ideograph-7981"], "u": "1f232" }, { "n": ["accept", "circled ideograph accept"], "u": "1f251" }, { "n": ["u7533", "squared cjk unified ideograph-7533"], "u": "1f238" }, { "n": ["u5408", "squared cjk unified ideograph-5408"], "u": "1f234" }, { "n": ["u7a7a", "squared cjk unified ideograph-7a7a"], "u": "1f233" }, { "n": ["congratulations", "circled ideograph congratulation"], "u": "3297-fe0f" }, { "n": ["secret", "circled ideograph secret"], "u": "3299-fe0f" }, { "n": ["u55b6", "squared cjk unified ideograph-55b6"], "u": "1f23a" }, { "n": ["u6e80", "squared cjk unified ideograph-6e80"], "u": "1f235" }, { "n": ["red circle", "large red circle"], "u": "1f534" }, { "n": ["large orange circle"], "u": "1f7e0" }, { "n": ["large yellow circle"], "u": "1f7e1" }, { "n": ["large green circle"], "u": "1f7e2" }, { "n": ["large blue circle"], "u": "1f535" }, { "n": ["large purple circle"], "u": "1f7e3" }, { "n": ["large brown circle"], "u": "1f7e4" }, { "n": ["black circle", "medium black circle"], "u": "26ab" }, { "n": ["white circle", "medium white circle"], "u": "26aa" }, { "n": ["large red square"], "u": "1f7e5" }, { "n": ["large orange square"], "u": "1f7e7" }, { "n": ["large yellow square"], "u": "1f7e8" }, { "n": ["large green square"], "u": "1f7e9" }, { "n": ["large blue square"], "u": "1f7e6" }, { "n": ["large purple square"], "u": "1f7ea" }, { "n": ["large brown square"], "u": "1f7eb" }, { "n": ["black large square"], "u": "2b1b" }, { "n": ["white large square"], "u": "2b1c" }, { "n": ["black medium square"], "u": "25fc-fe0f" }, { "n": ["white medium square"], "u": "25fb-fe0f" }, { "n": ["black medium small square"], "u": "25fe" }, { "n": ["white medium small square"], "u": "25fd" }, { "n": ["black small square"], "u": "25aa-fe0f" }, { "n": ["white small square"], "u": "25ab-fe0f" }, { "n": ["large orange diamond"], "u": "1f536" }, { "n": ["large blue diamond"], "u": "1f537" }, { "n": ["small orange diamond"], "u": "1f538" }, { "n": ["small blue diamond"], "u": "1f539" }, { "n": ["small red triangle", "up-pointing red triangle"], "u": "1f53a" }, { "n": ["small red triangle down", "down-pointing red triangle"], "u": "1f53b" }, { "n": ["diamond shape with a dot inside"], "u": "1f4a0" }, { "n": ["radio button"], "u": "1f518" }, { "n": ["white square button"], "u": "1f533" }, { "n": ["black square button"], "u": "1f532" }], "flags": [{ "n": ["chequered flag", "checkered flag"], "u": "1f3c1" }, { "n": ["triangular flag on post"], "u": "1f6a9" }, { "n": ["crossed flags"], "u": "1f38c" }, { "n": ["waving black flag"], "u": "1f3f4" }, { "n": ["white flag", "waving white flag"], "u": "1f3f3-fe0f" }, { "n": ["rainbow flag", "rainbow-flag"], "u": "1f3f3-fe0f-200d-1f308" }, { "n": ["transgender flag"], "u": "1f3f3-fe0f-200d-26a7-fe0f" }, { "n": ["pirate flag"], "u": "1f3f4-200d-2620-fe0f" }, { "n": ["flag-ac", "ascension island flag"], "u": "1f1e6-1f1e8" }, { "n": ["flag-ad", "andorra flag"], "u": "1f1e6-1f1e9" }, { "n": ["flag-ae", "united arab emirates flag"], "u": "1f1e6-1f1ea" }, { "n": ["flag-af", "afghanistan flag"], "u": "1f1e6-1f1eb" }, { "n": ["flag-ag", "antigua & barbuda flag"], "u": "1f1e6-1f1ec" }, { "n": ["flag-ai", "anguilla flag"], "u": "1f1e6-1f1ee" }, { "n": ["flag-al", "albania flag"], "u": "1f1e6-1f1f1" }, { "n": ["flag-am", "armenia flag"], "u": "1f1e6-1f1f2" }, { "n": ["flag-ao", "angola flag"], "u": "1f1e6-1f1f4" }, { "n": ["flag-aq", "antarctica flag"], "u": "1f1e6-1f1f6" }, { "n": ["flag-ar", "argentina flag"], "u": "1f1e6-1f1f7" }, { "n": ["flag-as", "american samoa flag"], "u": "1f1e6-1f1f8" }, { "n": ["flag-at", "austria flag"], "u": "1f1e6-1f1f9" }, { "n": ["flag-au", "australia flag"], "u": "1f1e6-1f1fa" }, { "n": ["flag-aw", "aruba flag"], "u": "1f1e6-1f1fc" }, { "n": ["flag-ax", "\xE5land islands flag"], "u": "1f1e6-1f1fd" }, { "n": ["flag-az", "azerbaijan flag"], "u": "1f1e6-1f1ff" }, { "n": ["flag-ba", "bosnia & herzegovina flag"], "u": "1f1e7-1f1e6" }, { "n": ["flag-bb", "barbados flag"], "u": "1f1e7-1f1e7" }, { "n": ["flag-bd", "bangladesh flag"], "u": "1f1e7-1f1e9" }, { "n": ["flag-be", "belgium flag"], "u": "1f1e7-1f1ea" }, { "n": ["flag-bf", "burkina faso flag"], "u": "1f1e7-1f1eb" }, { "n": ["flag-bg", "bulgaria flag"], "u": "1f1e7-1f1ec" }, { "n": ["flag-bh", "bahrain flag"], "u": "1f1e7-1f1ed" }, { "n": ["flag-bi", "burundi flag"], "u": "1f1e7-1f1ee" }, { "n": ["flag-bj", "benin flag"], "u": "1f1e7-1f1ef" }, { "n": ["flag-bl", "st. barth\xE9lemy flag"], "u": "1f1e7-1f1f1" }, { "n": ["flag-bm", "bermuda flag"], "u": "1f1e7-1f1f2" }, { "n": ["flag-bn", "brunei flag"], "u": "1f1e7-1f1f3" }, { "n": ["flag-bo", "bolivia flag"], "u": "1f1e7-1f1f4" }, { "n": ["flag-bq", "caribbean netherlands flag"], "u": "1f1e7-1f1f6" }, { "n": ["flag-br", "brazil flag"], "u": "1f1e7-1f1f7" }, { "n": ["flag-bs", "bahamas flag"], "u": "1f1e7-1f1f8" }, { "n": ["flag-bt", "bhutan flag"], "u": "1f1e7-1f1f9" }, { "n": ["flag-bv", "bouvet island flag"], "u": "1f1e7-1f1fb" }, { "n": ["flag-bw", "botswana flag"], "u": "1f1e7-1f1fc" }, { "n": ["flag-by", "belarus flag"], "u": "1f1e7-1f1fe" }, { "n": ["flag-bz", "belize flag"], "u": "1f1e7-1f1ff" }, { "n": ["flag-ca", "canada flag"], "u": "1f1e8-1f1e6" }, { "n": ["flag-cc", "cocos (keeling) islands flag"], "u": "1f1e8-1f1e8" }, { "n": ["flag-cd", "congo - kinshasa flag"], "u": "1f1e8-1f1e9" }, { "n": ["flag-cf", "central african republic flag"], "u": "1f1e8-1f1eb" }, { "n": ["flag-cg", "congo - brazzaville flag"], "u": "1f1e8-1f1ec" }, { "n": ["flag-ch", "switzerland flag"], "u": "1f1e8-1f1ed" }, { "n": ["flag-ci", "c\xF4te d\u2019ivoire flag"], "u": "1f1e8-1f1ee" }, { "n": ["flag-ck", "cook islands flag"], "u": "1f1e8-1f1f0" }, { "n": ["flag-cl", "chile flag"], "u": "1f1e8-1f1f1" }, { "n": ["flag-cm", "cameroon flag"], "u": "1f1e8-1f1f2" }, { "n": ["cn", "flag-cn", "china flag"], "u": "1f1e8-1f1f3" }, { "n": ["flag-co", "colombia flag"], "u": "1f1e8-1f1f4" }, { "n": ["flag-cp", "clipperton island flag"], "u": "1f1e8-1f1f5" }, { "n": ["flag-cr", "costa rica flag"], "u": "1f1e8-1f1f7" }, { "n": ["flag-cu", "cuba flag"], "u": "1f1e8-1f1fa" }, { "n": ["flag-cv", "cape verde flag"], "u": "1f1e8-1f1fb" }, { "n": ["flag-cw", "cura\xE7ao flag"], "u": "1f1e8-1f1fc" }, { "n": ["flag-cx", "christmas island flag"], "u": "1f1e8-1f1fd" }, { "n": ["flag-cy", "cyprus flag"], "u": "1f1e8-1f1fe" }, { "n": ["flag-cz", "czechia flag"], "u": "1f1e8-1f1ff" }, { "n": ["de", "flag-de", "germany flag"], "u": "1f1e9-1f1ea" }, { "n": ["flag-dg", "diego garcia flag"], "u": "1f1e9-1f1ec" }, { "n": ["flag-dj", "djibouti flag"], "u": "1f1e9-1f1ef" }, { "n": ["flag-dk", "denmark flag"], "u": "1f1e9-1f1f0" }, { "n": ["flag-dm", "dominica flag"], "u": "1f1e9-1f1f2" }, { "n": ["flag-do", "dominican republic flag"], "u": "1f1e9-1f1f4" }, { "n": ["flag-dz", "algeria flag"], "u": "1f1e9-1f1ff" }, { "n": ["flag-ea", "ceuta & melilla flag"], "u": "1f1ea-1f1e6" }, { "n": ["flag-ec", "ecuador flag"], "u": "1f1ea-1f1e8" }, { "n": ["flag-ee", "estonia flag"], "u": "1f1ea-1f1ea" }, { "n": ["flag-eg", "egypt flag"], "u": "1f1ea-1f1ec" }, { "n": ["flag-eh", "western sahara flag"], "u": "1f1ea-1f1ed" }, { "n": ["flag-er", "eritrea flag"], "u": "1f1ea-1f1f7" }, { "n": ["es", "flag-es", "spain flag"], "u": "1f1ea-1f1f8" }, { "n": ["flag-et", "ethiopia flag"], "u": "1f1ea-1f1f9" }, { "n": ["flag-eu", "european union flag"], "u": "1f1ea-1f1fa" }, { "n": ["flag-fi", "finland flag"], "u": "1f1eb-1f1ee" }, { "n": ["flag-fj", "fiji flag"], "u": "1f1eb-1f1ef" }, { "n": ["flag-fk", "falkland islands flag"], "u": "1f1eb-1f1f0" }, { "n": ["flag-fm", "micronesia flag"], "u": "1f1eb-1f1f2" }, { "n": ["flag-fo", "faroe islands flag"], "u": "1f1eb-1f1f4" }, { "n": ["fr", "flag-fr", "france flag"], "u": "1f1eb-1f1f7" }, { "n": ["flag-ga", "gabon flag"], "u": "1f1ec-1f1e6" }, { "n": ["gb", "uk", "flag-gb", "united kingdom flag"], "u": "1f1ec-1f1e7" }, { "n": ["flag-gd", "grenada flag"], "u": "1f1ec-1f1e9" }, { "n": ["flag-ge", "georgia flag"], "u": "1f1ec-1f1ea" }, { "n": ["flag-gf", "french guiana flag"], "u": "1f1ec-1f1eb" }, { "n": ["flag-gg", "guernsey flag"], "u": "1f1ec-1f1ec" }, { "n": ["flag-gh", "ghana flag"], "u": "1f1ec-1f1ed" }, { "n": ["flag-gi", "gibraltar flag"], "u": "1f1ec-1f1ee" }, { "n": ["flag-gl", "greenland flag"], "u": "1f1ec-1f1f1" }, { "n": ["flag-gm", "gambia flag"], "u": "1f1ec-1f1f2" }, { "n": ["flag-gn", "guinea flag"], "u": "1f1ec-1f1f3" }, { "n": ["flag-gp", "guadeloupe flag"], "u": "1f1ec-1f1f5" }, { "n": ["flag-gq", "equatorial guinea flag"], "u": "1f1ec-1f1f6" }, { "n": ["flag-gr", "greece flag"], "u": "1f1ec-1f1f7" }, { "n": ["flag-gs", "south georgia & south sandwich islands flag"], "u": "1f1ec-1f1f8" }, { "n": ["flag-gt", "guatemala flag"], "u": "1f1ec-1f1f9" }, { "n": ["flag-gu", "guam flag"], "u": "1f1ec-1f1fa" }, { "n": ["flag-gw", "guinea-bissau flag"], "u": "1f1ec-1f1fc" }, { "n": ["flag-gy", "guyana flag"], "u": "1f1ec-1f1fe" }, { "n": ["flag-hk", "hong kong sar china flag"], "u": "1f1ed-1f1f0" }, { "n": ["flag-hm", "heard & mcdonald islands flag"], "u": "1f1ed-1f1f2" }, { "n": ["flag-hn", "honduras flag"], "u": "1f1ed-1f1f3" }, { "n": ["flag-hr", "croatia flag"], "u": "1f1ed-1f1f7" }, { "n": ["flag-ht", "haiti flag"], "u": "1f1ed-1f1f9" }, { "n": ["flag-hu", "hungary flag"], "u": "1f1ed-1f1fa" }, { "n": ["flag-ic", "canary islands flag"], "u": "1f1ee-1f1e8" }, { "n": ["flag-id", "indonesia flag"], "u": "1f1ee-1f1e9" }, { "n": ["flag-ie", "ireland flag"], "u": "1f1ee-1f1ea" }, { "n": ["flag-il", "israel flag"], "u": "1f1ee-1f1f1" }, { "n": ["flag-im", "isle of man flag"], "u": "1f1ee-1f1f2" }, { "n": ["flag-in", "india flag"], "u": "1f1ee-1f1f3" }, { "n": ["flag-io", "british indian ocean territory flag"], "u": "1f1ee-1f1f4" }, { "n": ["flag-iq", "iraq flag"], "u": "1f1ee-1f1f6" }, { "n": ["flag-ir", "iran flag"], "u": "1f1ee-1f1f7" }, { "n": ["flag-is", "iceland flag"], "u": "1f1ee-1f1f8" }, { "n": ["it", "flag-it", "italy flag"], "u": "1f1ee-1f1f9" }, { "n": ["flag-je", "jersey flag"], "u": "1f1ef-1f1ea" }, { "n": ["flag-jm", "jamaica flag"], "u": "1f1ef-1f1f2" }, { "n": ["flag-jo", "jordan flag"], "u": "1f1ef-1f1f4" }, { "n": ["jp", "flag-jp", "japan flag"], "u": "1f1ef-1f1f5" }, { "n": ["flag-ke", "kenya flag"], "u": "1f1f0-1f1ea" }, { "n": ["flag-kg", "kyrgyzstan flag"], "u": "1f1f0-1f1ec" }, { "n": ["flag-kh", "cambodia flag"], "u": "1f1f0-1f1ed" }, { "n": ["flag-ki", "kiribati flag"], "u": "1f1f0-1f1ee" }, { "n": ["flag-km", "comoros flag"], "u": "1f1f0-1f1f2" }, { "n": ["flag-kn", "st. kitts & nevis flag"], "u": "1f1f0-1f1f3" }, { "n": ["flag-kp", "north korea flag"], "u": "1f1f0-1f1f5" }, { "n": ["kr", "flag-kr", "south korea flag"], "u": "1f1f0-1f1f7" }, { "n": ["flag-kw", "kuwait flag"], "u": "1f1f0-1f1fc" }, { "n": ["flag-ky", "cayman islands flag"], "u": "1f1f0-1f1fe" }, { "n": ["flag-kz", "kazakhstan flag"], "u": "1f1f0-1f1ff" }, { "n": ["flag-la", "laos flag"], "u": "1f1f1-1f1e6" }, { "n": ["flag-lb", "lebanon flag"], "u": "1f1f1-1f1e7" }, { "n": ["flag-lc", "st. lucia flag"], "u": "1f1f1-1f1e8" }, { "n": ["flag-li", "liechtenstein flag"], "u": "1f1f1-1f1ee" }, { "n": ["flag-lk", "sri lanka flag"], "u": "1f1f1-1f1f0" }, { "n": ["flag-lr", "liberia flag"], "u": "1f1f1-1f1f7" }, { "n": ["flag-ls", "lesotho flag"], "u": "1f1f1-1f1f8" }, { "n": ["flag-lt", "lithuania flag"], "u": "1f1f1-1f1f9" }, { "n": ["flag-lu", "luxembourg flag"], "u": "1f1f1-1f1fa" }, { "n": ["flag-lv", "latvia flag"], "u": "1f1f1-1f1fb" }, { "n": ["flag-ly", "libya flag"], "u": "1f1f1-1f1fe" }, { "n": ["flag-ma", "morocco flag"], "u": "1f1f2-1f1e6" }, { "n": ["flag-mc", "monaco flag"], "u": "1f1f2-1f1e8" }, { "n": ["flag-md", "moldova flag"], "u": "1f1f2-1f1e9" }, { "n": ["flag-me", "montenegro flag"], "u": "1f1f2-1f1ea" }, { "n": ["flag-mf", "st. martin flag"], "u": "1f1f2-1f1eb" }, { "n": ["flag-mg", "madagascar flag"], "u": "1f1f2-1f1ec" }, { "n": ["flag-mh", "marshall islands flag"], "u": "1f1f2-1f1ed" }, { "n": ["flag-mk", "north macedonia flag"], "u": "1f1f2-1f1f0" }, { "n": ["flag-ml", "mali flag"], "u": "1f1f2-1f1f1" }, { "n": ["flag-mm", "myanmar (burma) flag"], "u": "1f1f2-1f1f2" }, { "n": ["flag-mn", "mongolia flag"], "u": "1f1f2-1f1f3" }, { "n": ["flag-mo", "macao sar china flag"], "u": "1f1f2-1f1f4" }, { "n": ["flag-mp", "northern mariana islands flag"], "u": "1f1f2-1f1f5" }, { "n": ["flag-mq", "martinique flag"], "u": "1f1f2-1f1f6" }, { "n": ["flag-mr", "mauritania flag"], "u": "1f1f2-1f1f7" }, { "n": ["flag-ms", "montserrat flag"], "u": "1f1f2-1f1f8" }, { "n": ["flag-mt", "malta flag"], "u": "1f1f2-1f1f9" }, { "n": ["flag-mu", "mauritius flag"], "u": "1f1f2-1f1fa" }, { "n": ["flag-mv", "maldives flag"], "u": "1f1f2-1f1fb" }, { "n": ["flag-mw", "malawi flag"], "u": "1f1f2-1f1fc" }, { "n": ["flag-mx", "mexico flag"], "u": "1f1f2-1f1fd" }, { "n": ["flag-my", "malaysia flag"], "u": "1f1f2-1f1fe" }, { "n": ["flag-mz", "mozambique flag"], "u": "1f1f2-1f1ff" }, { "n": ["flag-na", "namibia flag"], "u": "1f1f3-1f1e6" }, { "n": ["flag-nc", "new caledonia flag"], "u": "1f1f3-1f1e8" }, { "n": ["flag-ne", "niger flag"], "u": "1f1f3-1f1ea" }, { "n": ["flag-nf", "norfolk island flag"], "u": "1f1f3-1f1eb" }, { "n": ["flag-ng", "nigeria flag"], "u": "1f1f3-1f1ec" }, { "n": ["flag-ni", "nicaragua flag"], "u": "1f1f3-1f1ee" }, { "n": ["flag-nl", "netherlands flag"], "u": "1f1f3-1f1f1" }, { "n": ["flag-no", "norway flag"], "u": "1f1f3-1f1f4" }, { "n": ["flag-np", "nepal flag"], "u": "1f1f3-1f1f5" }, { "n": ["flag-nr", "nauru flag"], "u": "1f1f3-1f1f7" }, { "n": ["flag-nu", "niue flag"], "u": "1f1f3-1f1fa" }, { "n": ["flag-nz", "new zealand flag"], "u": "1f1f3-1f1ff" }, { "n": ["flag-om", "oman flag"], "u": "1f1f4-1f1f2" }, { "n": ["flag-pa", "panama flag"], "u": "1f1f5-1f1e6" }, { "n": ["flag-pe", "peru flag"], "u": "1f1f5-1f1ea" }, { "n": ["flag-pf", "french polynesia flag"], "u": "1f1f5-1f1eb" }, { "n": ["flag-pg", "papua new guinea flag"], "u": "1f1f5-1f1ec" }, { "n": ["flag-ph", "philippines flag"], "u": "1f1f5-1f1ed" }, { "n": ["flag-pk", "pakistan flag"], "u": "1f1f5-1f1f0" }, { "n": ["flag-pl", "poland flag"], "u": "1f1f5-1f1f1" }, { "n": ["flag-pm", "st. pierre & miquelon flag"], "u": "1f1f5-1f1f2" }, { "n": ["flag-pn", "pitcairn islands flag"], "u": "1f1f5-1f1f3" }, { "n": ["flag-pr", "puerto rico flag"], "u": "1f1f5-1f1f7" }, { "n": ["flag-ps", "palestinian territories flag"], "u": "1f1f5-1f1f8" }, { "n": ["flag-pt", "portugal flag"], "u": "1f1f5-1f1f9" }, { "n": ["flag-pw", "palau flag"], "u": "1f1f5-1f1fc" }, { "n": ["flag-py", "paraguay flag"], "u": "1f1f5-1f1fe" }, { "n": ["flag-qa", "qatar flag"], "u": "1f1f6-1f1e6" }, { "n": ["flag-re", "r\xE9union flag"], "u": "1f1f7-1f1ea" }, { "n": ["flag-ro", "romania flag"], "u": "1f1f7-1f1f4" }, { "n": ["flag-rs", "serbia flag"], "u": "1f1f7-1f1f8" }, { "n": ["ru", "flag-ru", "russia flag"], "u": "1f1f7-1f1fa" }, { "n": ["flag-rw", "rwanda flag"], "u": "1f1f7-1f1fc" }, { "n": ["flag-sa", "saudi arabia flag"], "u": "1f1f8-1f1e6" }, { "n": ["flag-sb", "solomon islands flag"], "u": "1f1f8-1f1e7" }, { "n": ["flag-sc", "seychelles flag"], "u": "1f1f8-1f1e8" }, { "n": ["flag-sd", "sudan flag"], "u": "1f1f8-1f1e9" }, { "n": ["flag-se", "sweden flag"], "u": "1f1f8-1f1ea" }, { "n": ["flag-sg", "singapore flag"], "u": "1f1f8-1f1ec" }, { "n": ["flag-sh", "st. helena flag"], "u": "1f1f8-1f1ed" }, { "n": ["flag-si", "slovenia flag"], "u": "1f1f8-1f1ee" }, { "n": ["flag-sj", "svalbard & jan mayen flag"], "u": "1f1f8-1f1ef" }, { "n": ["flag-sk", "slovakia flag"], "u": "1f1f8-1f1f0" }, { "n": ["flag-sl", "sierra leone flag"], "u": "1f1f8-1f1f1" }, { "n": ["flag-sm", "san marino flag"], "u": "1f1f8-1f1f2" }, { "n": ["flag-sn", "senegal flag"], "u": "1f1f8-1f1f3" }, { "n": ["flag-so", "somalia flag"], "u": "1f1f8-1f1f4" }, { "n": ["flag-sr", "suriname flag"], "u": "1f1f8-1f1f7" }, { "n": ["flag-ss", "south sudan flag"], "u": "1f1f8-1f1f8" }, { "n": ["flag-st", "s\xE3o tom\xE9 & pr\xEDncipe flag"], "u": "1f1f8-1f1f9" }, { "n": ["flag-sv", "el salvador flag"], "u": "1f1f8-1f1fb" }, { "n": ["flag-sx", "sint maarten flag"], "u": "1f1f8-1f1fd" }, { "n": ["flag-sy", "syria flag"], "u": "1f1f8-1f1fe" }, { "n": ["flag-sz", "eswatini flag"], "u": "1f1f8-1f1ff" }, { "n": ["flag-ta", "tristan da cunha flag"], "u": "1f1f9-1f1e6" }, { "n": ["flag-tc", "turks & caicos islands flag"], "u": "1f1f9-1f1e8" }, { "n": ["flag-td", "chad flag"], "u": "1f1f9-1f1e9" }, { "n": ["flag-tf", "french southern territories flag"], "u": "1f1f9-1f1eb" }, { "n": ["flag-tg", "togo flag"], "u": "1f1f9-1f1ec" }, { "n": ["flag-th", "thailand flag"], "u": "1f1f9-1f1ed" }, { "n": ["flag-tj", "tajikistan flag"], "u": "1f1f9-1f1ef" }, { "n": ["flag-tk", "tokelau flag"], "u": "1f1f9-1f1f0" }, { "n": ["flag-tl", "timor-leste flag"], "u": "1f1f9-1f1f1" }, { "n": ["flag-tm", "turkmenistan flag"], "u": "1f1f9-1f1f2" }, { "n": ["flag-tn", "tunisia flag"], "u": "1f1f9-1f1f3" }, { "n": ["flag-to", "tonga flag"], "u": "1f1f9-1f1f4" }, { "n": ["flag-tr", "turkey flag"], "u": "1f1f9-1f1f7" }, { "n": ["flag-tt", "trinidad & tobago flag"], "u": "1f1f9-1f1f9" }, { "n": ["flag-tv", "tuvalu flag"], "u": "1f1f9-1f1fb" }, { "n": ["flag-tw", "taiwan flag"], "u": "1f1f9-1f1fc" }, { "n": ["flag-tz", "tanzania flag"], "u": "1f1f9-1f1ff" }, { "n": ["flag-ua", "ukraine flag"], "u": "1f1fa-1f1e6" }, { "n": ["flag-ug", "uganda flag"], "u": "1f1fa-1f1ec" }, { "n": ["flag-um", "u.s. outlying islands flag"], "u": "1f1fa-1f1f2" }, { "n": ["flag-un", "united nations flag"], "u": "1f1fa-1f1f3" }, { "n": ["us", "flag-us", "united states flag"], "u": "1f1fa-1f1f8" }, { "n": ["flag-uy", "uruguay flag"], "u": "1f1fa-1f1fe" }, { "n": ["flag-uz", "uzbekistan flag"], "u": "1f1fa-1f1ff" }, { "n": ["flag-va", "vatican city flag"], "u": "1f1fb-1f1e6" }, { "n": ["flag-vc", "st. vincent & grenadines flag"], "u": "1f1fb-1f1e8" }, { "n": ["flag-ve", "venezuela flag"], "u": "1f1fb-1f1ea" }, { "n": ["flag-vg", "british virgin islands flag"], "u": "1f1fb-1f1ec" }, { "n": ["flag-vi", "u.s. virgin islands flag"], "u": "1f1fb-1f1ee" }, { "n": ["flag-vn", "vietnam flag"], "u": "1f1fb-1f1f3" }, { "n": ["flag-vu", "vanuatu flag"], "u": "1f1fb-1f1fa" }, { "n": ["flag-wf", "wallis & futuna flag"], "u": "1f1fc-1f1eb" }, { "n": ["flag-ws", "samoa flag"], "u": "1f1fc-1f1f8" }, { "n": ["flag-xk", "kosovo flag"], "u": "1f1fd-1f1f0" }, { "n": ["flag-ye", "yemen flag"], "u": "1f1fe-1f1ea" }, { "n": ["flag-yt", "mayotte flag"], "u": "1f1fe-1f1f9" }, { "n": ["flag-za", "south africa flag"], "u": "1f1ff-1f1e6" }, { "n": ["flag-zm", "zambia flag"], "u": "1f1ff-1f1f2" }, { "n": ["flag-zw", "zimbabwe flag"], "u": "1f1ff-1f1fc" }, { "n": ["england flag", "flag-england"], "u": "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f" }, { "n": ["scotland flag", "flag-scotland"], "u": "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f" }, { "n": ["wales flag", "flag-wales"], "u": "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f" }] };

// src/components/Spaces/FileStickerMenu/FileStickerMenu.tsx
var import_obsidian6 = require("obsidian");
var StickerModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, setIcon3) {
    super(app2);
    this.setIcon = setIcon3;
    this.resultContainerEl.toggleClass("mk-sticker-modal", true);
    this.inputEl.focus();
    this.emptyStateText = i18n_default.labels.findStickers;
    this.limit = 0;
  }
  renderSuggestion(item, el) {
    el.innerHTML = unifiedToNative(item.item.unicode);
    el.setAttr("aria-label", item.item.label);
  }
  getItemText(item) {
    return item.label + item.desc;
  }
  getItems() {
    const allEmojis = Object.keys(emojis).reduce((p3, c3) => [...p3, ...emojis[c3].map((e3) => ({ label: e3.n[0], desc: e3.n[1], variants: e3.v, unicode: e3.u }))], []);
    return allEmojis;
  }
  onChooseItem(item, evt) {
    this.setIcon(item.unicode);
  }
};

// node_modules/react-popper/lib/esm/utils.js
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref) {
    var key2 = _ref[0], value = _ref[1];
    acc[key2] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" && window.document && window.document.createElement ? s2 : h2;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow3(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow3(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement2(node) {
  var OwnElement = getWindow3(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow3(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement2(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement2(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement2(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow3(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x4 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x4 + width,
    bottom: y3 + height,
    left: x4,
    x: x4,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow3(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement2(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement2(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement2(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow3(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v3 = within(min2, value, max2);
  return v3 > max2 ? max2 : v3;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement2(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x4 = _ref.x, y3 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x4 * dpr) / dpr || 0,
    y: round(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed2 = _ref2.isFixed;
  var _offsets$x = offsets.x, x4 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x4,
    y: y3
  }) : {
    x: x4,
    y: y3
  };
  x4 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow3(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x4 -= offsetX - popperRect.width;
      x4 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x4,
    y: y3
  }) : {
    x: x4,
    y: y3
  };
  x4 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x4 + "px, " + y3 + "px)" : "translate3d(" + x4 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x4 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty2 = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty2.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow3(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow3(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow3(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x4 = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4 + getWindowScrollBarX(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x4 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x4 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement2(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow3(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement2(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b3) {
    return overflows[a3] - overflows[b3];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x4 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x4;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow3(node) || !isHTMLElement2(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed2) {
  if (isFixed2 === void 0) {
    isFixed2 = false;
  }
  var isOffsetParentAnElement = isHTMLElement2(offsetParent);
  var offsetParentIsScaled = isHTMLElement2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed2);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p3, c3) {
    return p3.replace(/%s/, c3);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key2) {
      switch (key2) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s3) {
            return '"' + s3 + '"';
          }).join(", ") + '; but "' + key2 + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn3) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/react-popper/lib/esm/usePopper.js
var import_react_fast_compare = __toESM(require_react_fast_compare());
var EMPTY_MODIFIERS = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = _2(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  var _React$useState = p2({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = F(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn3(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        hn(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = F(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = _2();
  useIsomorphicLayoutEffect3(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect3(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper2 = options.createPopper || createPopper;
    var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// src/components/Spaces/TreeView/FolderTreeView.tsx
var animateLayoutChanges = ({ isSorting, wasDragging }) => isSorting || wasDragging ? false : true;
var SortableTreeItem = ({ id, data, depth, disabled, style, ...props }) => {
  const {
    attributes,
    isDragging,
    isSorting,
    listeners,
    setDraggableNodeRef,
    setDroppableNodeRef,
    transform,
    transition
  } = useSortable({
    id,
    animateLayoutChanges,
    disabled,
    data
  });
  const memoListeners = F(() => {
    return {
      ...attributes,
      ...listeners
    };
  }, [isSorting]);
  if (data.parentId == null) {
    return /* @__PURE__ */ bn.createElement(SectionItem, {
      ref: setDraggableNodeRef,
      wrapperRef: setDroppableNodeRef,
      data,
      depth,
      ghost: isDragging,
      disableInteraction: isSorting,
      disabled,
      style,
      handleProps: memoListeners,
      ...props
    });
  } else {
    return /* @__PURE__ */ bn.createElement(TreeItem, {
      ref: setDraggableNodeRef,
      wrapperRef: setDroppableNodeRef,
      data,
      depth,
      ghost: isDragging,
      disableInteraction: isSorting,
      disabled,
      style,
      handleProps: memoListeners,
      ...props
    });
  }
};
var TreeItem = k3(({
  childCount,
  clone,
  data,
  depth,
  disableSelection,
  disableInteraction,
  ghost,
  handleProps,
  indentationWidth,
  indicator,
  collapsed,
  onCollapse,
  wrapperRef,
  style,
  plugin,
  disabled
}, ref) => {
  const [activeFile2, setActiveFile] = Recoil_index_14(activeFile);
  const [sections2, setSections] = Recoil_index_14(sections);
  const [fileIcons2, setFileIcons] = Recoil_index_14(fileIcons);
  const [referenceElement, setReferenceElement] = bn.useState(null);
  const [popperElement, setPopperElement] = p2(null);
  const { styles, attributes } = usePopper(referenceElement, popperElement);
  const openFile2 = (file, e3) => {
    openFile(file, plugin.app, e3.ctrlKey || e3.metaKey);
    setActiveFile(file.path);
  };
  const updateSections = (sections3) => {
    plugin.settings.spaces = sections3;
    plugin.saveSettings();
  };
  const triggerStickerMenu = (e3) => {
    e3.stopPropagation();
    let vaultChangeModal = new StickerModal(plugin.app, (emoji) => saveFileIcon(emoji));
    vaultChangeModal.open();
  };
  const triggerContextMenu = (file, isFolder, e3) => {
    const fileMenu = new import_obsidian7.Menu();
    if (isFolder) {
      fileMenu.addSeparator();
      fileMenu.addItem((menuItem) => {
        menuItem.setIcon("edit");
        menuItem.setTitle(i18n_default.buttons.createNote);
        menuItem.onClick((ev) => {
          newFileInFolder();
        });
      });
      fileMenu.addItem((menuItem) => {
        menuItem.setIcon("folder-plus");
        menuItem.setTitle(i18n_default.buttons.createFolder);
        menuItem.onClick((ev) => {
          let vaultChangeModal = new VaultChangeModal(plugin, data, "create folder", -1);
          vaultChangeModal.open();
        });
      });
    }
    fileMenu.addSeparator();
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.spaceTitle);
      menuItem.setDisabled(true);
    });
    sections2.map((f4, i3) => {
      fileMenu.addItem((menuItem) => {
        menuItem.setIcon("pin");
        if (f4.children.contains(file.path)) {
          menuItem.setIcon("checkmark");
          menuItem.setTitle(f4.section);
        } else {
          menuItem.setTitle(f4.section);
          menuItem.setIcon("plus");
        }
        menuItem.onClick((ev) => {
          updateSections(!sections2[i3].children.contains(file.path) ? sections2.map((s3, k4) => {
            return k4 == i3 ? {
              ...s3,
              children: [file.path, ...s3.children]
            } : s3;
          }) : sections2.map((s3, k4) => {
            return k4 == i3 ? {
              ...s3,
              children: s3.children.filter((g4) => g4 != file.path)
            } : s3;
          }));
        });
      });
    });
    if (plugin.settings.spacesStickers) {
      fileMenu.addSeparator();
      fileMenu.addItem((menuItem) => {
        menuItem.setTitle(i18n_default.buttons.changeIcon);
        menuItem.setIcon("lucide-sticker");
        menuItem.onClick((ev) => {
          let vaultChangeModal = new StickerModal(plugin.app, (emoji) => saveFileIcon(emoji));
          vaultChangeModal.open();
        });
      });
      fileMenu.addItem((menuItem) => {
        menuItem.setTitle(i18n_default.buttons.removeIcon);
        menuItem.setIcon("lucide-file-minus");
        menuItem.onClick((ev) => {
          removeFileIcon();
        });
      });
    }
    fileMenu.addSeparator();
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.rename);
      menuItem.setIcon("pencil");
      menuItem.onClick((ev) => {
        let vaultChangeModal = new VaultChangeModal(plugin, file, "rename");
        vaultChangeModal.open();
      });
    });
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle("Delete");
      menuItem.setIcon("trash");
      menuItem.onClick((ev) => {
        let deleteOption = plugin.settings.deleteFileOption;
        if (deleteOption === "permanent") {
          plugin.app.vault.delete(file, true);
        } else if (deleteOption === "system-trash") {
          plugin.app.vault.trash(file, true);
        } else if (deleteOption === "trash") {
          plugin.app.vault.trash(file, false);
        }
      });
    });
    fileMenu.addItem((menuItem) => {
      menuItem.setIcon("go-to-file");
      menuItem.setTitle(i18n_default.menu.openFilePane);
      menuItem.onClick((ev) => {
        openFileInNewPane(plugin, { ...file, isFolder });
      });
    });
    fileMenu.addItem((menuItem) => {
      menuItem.setTitle(i18n_default.menu.duplicate);
      menuItem.setIcon("documents");
      menuItem.onClick((ev) => {
        if (file.basename && file.extension)
          plugin.app.vault.copy(file, `${file.parent.path}/${file.basename} 1.${file.extension}`);
      });
    });
    if (!internalPluginLoaded("file-explorer", plugin.app)) {
      fileMenu.addItem((menuItem) => {
        menuItem.setTitle(i18n_default.menu.moveFile);
        menuItem.setIcon("paper-plane");
        menuItem.onClick((ev) => {
          let fileMoveSuggester = new MoveSuggestionModal(plugin.app, file);
          fileMoveSuggester.open();
        });
      });
    }
    plugin.app.workspace.trigger("file-menu", fileMenu, file, "file-explorer");
    if (isMouseEvent(e3)) {
      fileMenu.showAtPosition({ x: e3.pageX, y: e3.pageY });
    } else {
      fileMenu.showAtPosition({ x: e3.nativeEvent.locationX, y: e3.nativeEvent.locationY });
    }
    return false;
  };
  const newFileInFolder = async () => {
    await createNewMarkdownFile(plugin.app, data.parent.children.find((f4) => f4.name == data.name), "", "");
  };
  const fileIcon = fileIcons2.find(([path, icon]) => path == data.path);
  const saveFileIcon = (icon) => {
    const newFileIcons = [...fileIcons2.filter((f4) => f4[0] != data.path), [data.path, icon]];
    plugin.settings.fileIcons = newFileIcons;
    plugin.saveSettings();
  };
  const removeFileIcon = () => {
    const newFileIcons = [...fileIcons2.filter((f4) => f4[0] != data.path)];
    plugin.settings.fileIcons = newFileIcons;
    plugin.saveSettings();
  };
  return /* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement("div", {
    className: (0, import_classnames2.default)("mk-tree-wrapper", clone && "mk-clone", ghost && "mk-ghost", disableSelection && "mk-disable-selection", disableInteraction && "mk-disable-interaction", activeFile2 === data.path && " mk-is-active"),
    ref: wrapperRef,
    style
  }, /* @__PURE__ */ bn.createElement("div", {
    className: indicator && (0, import_classnames2.default)(indicator.state == 2 /* Bottom */ ? "mk-indicator-bottom" : indicator.state == 1 /* Top */ ? "mk-indicator-top" : indicator.state == 3 /* Row */ ? "mk-indicator-row" : ""),
    style: indicator ? {
      "--spacing": `${indentationWidth * indicator.depth - 12}px`
    } : {},
    ...handleProps
  }, /* @__PURE__ */ bn.createElement("div", {
    className: (0, import_classnames2.default)(`mk-tree-item`),
    ref,
    style: {
      "--spacing": `${indentationWidth * depth - 12}px`
    },
    onClick: (e3) => openFile2(data, e3),
    onContextMenu: (e3) => triggerContextMenu(plugin.app.vault.getAbstractFileByPath(data.path), data.isFolder, e3)
  }, data.isFolder && /* @__PURE__ */ bn.createElement("button", {
    "aria-label": `${collapsed ? i18n_default.labels.expand : i18n_default.labels.collapse}`,
    className: `mk-collapse ${collapsed ? "mk-collapsed" : ""}`,
    onClick: (e3) => {
      onCollapse(data);
      e3.stopPropagation();
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-collapse"] }
  }), plugin.settings.spacesStickers && /* @__PURE__ */ bn.createElement("div", {
    className: "mk-file-icon"
  }, /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.changeIcon,
    ref: setReferenceElement,
    dangerouslySetInnerHTML: fileIcon ? { __html: unifiedToNative(fileIcon[1]) } : data.isFolder ? { __html: uiIconSet["mk-ui-folder"] } : { __html: uiIconSet["mk-ui-file"] },
    onClick: (e3) => triggerStickerMenu(e3)
  })), /* @__PURE__ */ bn.createElement("div", {
    className: `mk-tree-text `
  }, data.isFolder ? data.name : data.name.substring(0, data.name.lastIndexOf(".")) || data.name)), !clone ? /* @__PURE__ */ bn.createElement("div", {
    className: "mk-folder-buttons"
  }, /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.moreOptions,
    onClick: (e3) => {
      triggerContextMenu(plugin.app.vault.getAbstractFileByPath(data.path), data.isFolder, e3);
      e3.stopPropagation();
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-options"] }
  }), data.isFolder && /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.newNote,
    onClick: (e3) => {
      newFileInFolder();
      e3.stopPropagation();
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-plus"] }
  })) : /* @__PURE__ */ bn.createElement(bn.Fragment, null))));
});
TreeItem.displayName = "TreeItem";

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o3, p3) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p4) {
    o4.__proto__ = p4;
    return o4;
  };
  return _setPrototypeOf(o3, p3);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/react-window/node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i3 = 0; i3 < newInputs.length; i3++) {
    if (!isEqual2(newInputs[i3], lastInputs[i3])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual3) {
  if (isEqual3 === void 0) {
    isEqual3 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual3(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key2 = sourceKeys[i3];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}

// node_modules/react-window/dist/index.esm.js
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start2 = now();
  function tick() {
    if (now() - start2 >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size = -1;
function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div = document.createElement("div");
    var style = div.style;
    style.width = "50px";
    style.height = "50px";
    style.overflow = "scroll";
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
var devWarningsOverscanCount = null;
var devWarningsOverscanRowsColumnsCount = null;
var devWarningsTagName = null;
if (true) {
  if (typeof window !== "undefined" && typeof window.WeakSet !== "undefined") {
    devWarningsOverscanCount = /* @__PURE__ */ new WeakSet();
    devWarningsOverscanRowsColumnsCount = /* @__PURE__ */ new WeakSet();
    devWarningsTagName = /* @__PURE__ */ new WeakSet();
  }
}
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey(index, data) {
  return index;
};
var devWarningsDirection = null;
var devWarningsTagName$1 = null;
if (true) {
  if (typeof window !== "undefined" && typeof window.WeakSet !== "undefined") {
    devWarningsDirection = /* @__PURE__ */ new WeakSet();
    devWarningsTagName$1 = /* @__PURE__ */ new WeakSet();
  }
}
function createListComponent(_ref) {
  var _class;
  var getItemOffset2 = _ref.getItemOffset, getEstimatedTotalSize3 = _ref.getEstimatedTotalSize, getItemSize2 = _ref.getItemSize, getOffsetForIndexAndAlignment2 = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset2 = _ref.getStartIndexForOffset, getStopIndexForStartIndex2 = _ref.getStopIndexForStartIndex, initInstanceProps2 = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps2 = _ref.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(List, _PureComponent);
    function List(props) {
      var _this;
      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps2(_this.props, _assertThisInitialized(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: _assertThisInitialized(_this),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = memoize_one_esm_default(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = memoize_one_esm_default(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;
      _this._getItemStyle = function(index) {
        var _this$props = _this.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;
        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);
        var style;
        if (itemStyleCache.hasOwnProperty(index)) {
          style = itemStyleCache[index];
        } else {
          var _offset = getItemOffset2(_this.props, index, _this._instanceProps);
          var size2 = getItemSize2(_this.props, index, _this._instanceProps);
          var isHorizontal = direction === "horizontal" || layout === "horizontal";
          var isRtl = direction === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index] = style = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style;
      };
      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = memoize_one_esm_default(function(_3, __, ___) {
        return {};
      });
      _this._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            return null;
          }
          var direction = _this.props.direction;
          var scrollOffset = scrollLeft;
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollLeft ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;
        _this.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };
      _this._outerRefSetter = function(ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this._resetIsScrollingDebounced = function() {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }
        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this._resetIsScrolling = function() {
        _this._resetIsScrollingTimeoutId = null;
        _this.setState({
          isScrolling: false
        }, function() {
          _this._getItemStyleCache(-1, null);
        });
      };
      return _this;
    }
    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps2(nextProps);
      return null;
    };
    var _proto = List.prototype;
    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index = Math.max(0, Math.min(index, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment2(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction = _this$props4.direction, layout = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction === "horizontal" || layout === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push(h(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize3(this.props, this._instanceProps);
      return h(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends({
          position: "relative",
          height,
          width,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction
        }, style)
      }, h(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset2(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex2(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List;
  }(w3), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
  var children = _ref2.children, direction = _ref2.direction, height = _ref2.height, layout = _ref2.layout, innerTagName = _ref2.innerTagName, outerTagName = _ref2.outerTagName, width = _ref2.width;
  var instance = _ref3.instance;
  if (true) {
    if (innerTagName != null || outerTagName != null) {
      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {
        devWarningsTagName$1.add(instance);
        console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead.");
      }
    }
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    switch (direction) {
      case "horizontal":
      case "vertical":
        if (devWarningsDirection && !devWarningsDirection.has(instance)) {
          devWarningsDirection.add(instance);
          console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.');
        }
        break;
      case "ltr":
      case "rtl":
        break;
      default:
        throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". ' + ('"' + direction + '" was specified.'));
    }
    switch (layout) {
      case "horizontal":
      case "vertical":
        break;
      default:
        throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". ' + ('"' + layout + '" was specified.'));
    }
    if (children == null) {
      throw Error('An invalid "children" prop has been specified. Value should be a React component. ' + ('"' + (children === null ? "null" : typeof children) + '" was specified.'));
    }
    if (isHorizontal && typeof width !== "number") {
      throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. ' + ('"' + (width === null ? "null" : typeof width) + '" was specified.'));
    } else if (!isHorizontal && typeof height !== "number") {
      throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. ' + ('"' + (height === null ? "null" : typeof height) + '" was specified.'));
    }
  }
};
var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;
var getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {
  var _ref = props, itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  if (index > lastMeasuredIndex) {
    var offset2 = 0;
    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset2 = itemMetadata.offset + itemMetadata.size;
    }
    for (var i3 = lastMeasuredIndex + 1; i3 <= index; i3++) {
      var size2 = itemSize(i3);
      itemMetadataMap[i3] = {
        offset: offset2,
        size: size2
      };
      offset2 += size2;
    }
    instanceProps.lastMeasuredIndex = index;
  }
  return itemMetadataMap[index];
};
var findNearestItem$1 = function findNearestItem(props, instanceProps, offset2) {
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;
  if (lastMeasuredItemOffset >= offset2) {
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset2);
  } else {
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset2);
  }
};
var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset2) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;
    if (currentOffset === offset2) {
      return middle;
    } else if (currentOffset < offset2) {
      low = middle + 1;
    } else if (currentOffset > offset2) {
      high = middle - 1;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset2) {
  var itemCount = props.itemCount;
  var interval = 1;
  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset2) {
    index += interval;
    interval *= 2;
  }
  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset2);
};
var getEstimatedTotalSize = function getEstimatedTotalSize2(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap, estimatedItemSize = _ref3.estimatedItemSize, lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0;
  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }
  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }
  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
var VariableSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset(props, index, instanceProps) {
    return getItemMetadata$1(props, index, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index, instanceProps) {
    return instanceProps.itemMetadataMap[index].size;
  },
  getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = props.direction, height = props.height, layout = props.layout, width = props.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, index, instanceProps);
    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size2 + itemMetadata.size + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset2, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset2);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction = props.direction, height = props.height, itemCount = props.itemCount, layout = props.layout, width = props.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size2;
    var offset2 = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;
    while (stopIndex < itemCount - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }
    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref4 = props, estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };
    instance.resetAfterIndex = function(index, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }
      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1);
      instance._getItemStyleCache(-1);
      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };
    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref5) {
    var itemSize = _ref5.itemSize;
    if (true) {
      if (typeof itemSize !== "function") {
        throw Error('An invalid "itemSize" prop has been specified. Value should be a function. ' + ('"' + (itemSize === null ? "null" : typeof itemSize) + '" was specified.'));
      }
    }
  }
});
function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }
  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }
  return false;
}
var _excluded = ["style"];
var _excluded2 = ["style"];
function areEqual(prevProps, nextProps) {
  var prevStyle = prevProps.style, prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);
  var nextStyle = nextProps.style, nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);
  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
}

// src/utils/detectElementResize.js
var windowObject;
if (typeof window !== "undefined") {
  windowObject = window;
} else if (typeof self !== "undefined") {
  windowObject = self;
} else {
  windowObject = global;
}
var cancelFrame = null;
var requestFrame = null;
var TIMEOUT_DURATION = 20;
var clearTimeoutFn = windowObject.clearTimeout;
var setTimeoutFn = windowObject.setTimeout;
var cancelAnimationFrameFn = windowObject.cancelAnimationFrame || windowObject.mozCancelAnimationFrame || windowObject.webkitCancelAnimationFrame;
var requestAnimationFrameFn = windowObject.requestAnimationFrame || windowObject.mozRequestAnimationFrame || windowObject.webkitRequestAnimationFrame;
if (cancelAnimationFrameFn == null || requestAnimationFrameFn == null) {
  cancelFrame = clearTimeoutFn;
  requestFrame = function requestAnimationFrameViaSetTimeout(callback) {
    return setTimeoutFn(callback, TIMEOUT_DURATION);
  };
} else {
  cancelFrame = function cancelFrame2([animationFrameID, timeoutID]) {
    cancelAnimationFrameFn(animationFrameID);
    clearTimeoutFn(timeoutID);
  };
  requestFrame = function requestAnimationFrameWithSetTimeoutFallback(callback) {
    const animationFrameID = requestAnimationFrameFn(function animationFrameCallback() {
      clearTimeoutFn(timeoutID);
      callback();
    });
    const timeoutID = setTimeoutFn(function timeoutCallback() {
      cancelAnimationFrameFn(animationFrameID);
      callback();
    }, TIMEOUT_DURATION);
    return [animationFrameID, timeoutID];
  };
}
function createDetectElementResize(nonce) {
  let animationKeyframes;
  let animationName;
  let animationStartEvent;
  let animationStyle;
  let checkTriggers;
  let resetTriggers;
  let scrollListener;
  const attachEvent = typeof document !== "undefined" && document.attachEvent;
  if (!attachEvent) {
    resetTriggers = function(element) {
      const triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + "px";
      expandChild.style.height = expand.offsetHeight + 1 + "px";
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };
    checkTriggers = function(element) {
      return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
    };
    scrollListener = function(e3) {
      if (e3.target.className && typeof e3.target.className.indexOf === "function" && e3.target.className.indexOf("contract-trigger") < 0 && e3.target.className.indexOf("expand-trigger") < 0) {
        return;
      }
      const element = this;
      resetTriggers(this);
      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }
      this.__resizeRAF__ = requestFrame(function animationFrame() {
        if (checkTriggers(element)) {
          element.__resizeLast__.width = element.offsetWidth;
          element.__resizeLast__.height = element.offsetHeight;
          element.__resizeListeners__.forEach(function forEachResizeListener(fn3) {
            fn3.call(element, e3);
          });
        }
      });
    };
    let animation = false;
    let keyframeprefix = "";
    animationStartEvent = "animationstart";
    const domPrefixes = "Webkit Moz O ms".split(" ");
    let startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" ");
    let pfx = "";
    {
      const elm = document.createElement("fakeelement");
      if (elm.style.animationName !== void 0) {
        animation = true;
      }
      if (animation === false) {
        for (let i3 = 0; i3 < domPrefixes.length; i3++) {
          if (elm.style[domPrefixes[i3] + "AnimationName"] !== void 0) {
            pfx = domPrefixes[i3];
            keyframeprefix = "-" + pfx.toLowerCase() + "-";
            animationStartEvent = startEvents[i3];
            animation = true;
            break;
          }
        }
      }
    }
    animationName = "resizeanim";
    animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
    animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  }
  const createStyles = function(doc) {
    if (!doc.getElementById("detectElementResize")) {
      const css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
      style.id = "detectElementResize";
      style.type = "text/css";
      if (nonce != null) {
        style.setAttribute("nonce", nonce);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(doc.createTextNode(css));
      }
      head.appendChild(style);
    }
  };
  const addResizeListener = function(element, fn3) {
    if (attachEvent) {
      element.attachEvent("onresize", fn3);
    } else {
      if (!element.__resizeTriggers__) {
        const doc = element.ownerDocument;
        const elementStyle = windowObject.getComputedStyle(element);
        if (elementStyle && elementStyle.position === "static") {
          element.style.position = "relative";
        }
        createStyles(doc);
        element.__resizeLast__ = {};
        element.__resizeListeners__ = [];
        (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
        const expandTrigger = doc.createElement("div");
        expandTrigger.className = "expand-trigger";
        expandTrigger.appendChild(doc.createElement("div"));
        const contractTrigger = doc.createElement("div");
        contractTrigger.className = "contract-trigger";
        element.__resizeTriggers__.appendChild(expandTrigger);
        element.__resizeTriggers__.appendChild(contractTrigger);
        element.appendChild(element.__resizeTriggers__);
        resetTriggers(element);
        element.addEventListener("scroll", scrollListener, true);
        if (animationStartEvent) {
          element.__resizeTriggers__.__animationListener__ = function animationListener(e3) {
            if (e3.animationName === animationName) {
              resetTriggers(element);
            }
          };
          element.__resizeTriggers__.addEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
        }
      }
      element.__resizeListeners__.push(fn3);
    }
  };
  const removeResizeListener = function(element, fn3) {
    if (attachEvent) {
      element.detachEvent("onresize", fn3);
    } else {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn3), 1);
      if (!element.__resizeListeners__.length) {
        element.removeEventListener("scroll", scrollListener, true);
        if (element.__resizeTriggers__.__animationListener__) {
          element.__resizeTriggers__.removeEventListener(animationStartEvent, element.__resizeTriggers__.__animationListener__);
          element.__resizeTriggers__.__animationListener__ = null;
        }
        try {
          element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
        } catch (e3) {
        }
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}

// src/utils/autosizer.tsx
var AutoSizer = class extends w3 {
  constructor() {
    super(...arguments);
    this.state = {
      height: this.props.defaultHeight || 0,
      width: this.props.defaultWidth || 0
    };
    this._onResize = () => {
      const { disableHeight, disableWidth, onResize } = this.props;
      if (this._parentNode) {
        const height = this._parentNode.offsetHeight || 0;
        const width = this._parentNode.offsetWidth || 0;
        const style = window.getComputedStyle(this._parentNode) || {};
        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;
        const paddingRight = parseInt(style.paddingRight, 10) || 0;
        const paddingTop = parseInt(style.paddingTop, 10) || 0;
        const paddingBottom = parseInt(style.paddingBottom, 10) || 0;
        const newHeight = height - paddingTop - paddingBottom;
        const newWidth = width - paddingLeft - paddingRight;
        if (height == 0 || width == 0) {
          return;
        }
        if (!disableHeight && this.state.height !== newHeight || !disableWidth && this.state.width !== newWidth) {
          this.setState({
            height: height - paddingTop - paddingBottom,
            width: width - paddingLeft - paddingRight
          });
          onResize({ height, width });
        }
      }
    };
    this._setRef = (autoSizer) => {
      this._autoSizer = autoSizer;
    };
  }
  componentDidMount() {
    const { nonce } = this.props;
    if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
      this._parentNode = this._autoSizer.parentNode;
      this._detectElementResize = createDetectElementResize(nonce);
      this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
      this._onResize();
    }
  }
  componentWillUnmount() {
    if (this._detectElementResize && this._parentNode) {
      this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
    }
  }
  render() {
    const {
      children,
      className,
      disableHeight,
      disableWidth,
      style
    } = this.props;
    const { height, width } = this.state;
    const outerStyle = { overflow: "visible" };
    const childParams = {};
    let bailoutOnChildren = false;
    if (!disableHeight) {
      if (height === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.height = 0;
      childParams.height = height;
    }
    if (!disableWidth) {
      if (width === 0) {
        bailoutOnChildren = true;
      }
      outerStyle.width = 0;
      childParams.width = width;
    }
    return /* @__PURE__ */ h("div", {
      className,
      ref: this._setRef,
      style: {
        ...outerStyle,
        ...style
      }
    }, !bailoutOnChildren && children(childParams));
  }
};
AutoSizer.defaultProps = {
  onResize: () => {
  },
  disableHeight: false,
  disableWidth: false,
  style: {}
};

// src/components/Spaces/FileExplorerVirtualized.tsx
var row = R(({ data, index, style }) => {
  const { flattenedItems, projected, handleCollapse, plugin, sections: sections2, openFolders: openFolders2, indentationWidth } = data;
  const f4 = flattenedItems[index];
  return /* @__PURE__ */ bn.createElement(SortableTreeItem, {
    key: f4.id,
    id: f4.id,
    data: f4,
    disabled: false,
    depth: f4.depth,
    childCount: 0,
    indentationWidth,
    indicator: (projected == null ? void 0 : projected.overId) == f4.id ? f4.parentId == null && projected.parentId == null ? { state: 1 /* Top */, depth: projected.depth } : { state: 2 /* Bottom */, depth: projected.depth } : null,
    plugin,
    style,
    collapsed: f4.parentId == null ? f4.id == "/" ? plugin.settings.vaultCollapsed : sections2[f4.index].collapsed : !openFolders2.find((i3) => i3 == f4.id),
    onCollapse: handleCollapse
  });
}, areEqual);
var FileExplorerComponent = (props) => {
  const { plugin } = props;
  const indentationWidth = 24;
  const isMobile = platformIsMobile();
  const [vaultCollapsed, setVaultCollapsed] = p2(plugin.settings.vaultCollapsed);
  const [openFolders2, setOpenFolders] = Recoil_index_14(openFolders);
  const [fileIcons2, setFileIcons] = Recoil_index_14(fileIcons);
  const [focusedFolder2, setFocusedFolder] = Recoil_index_14(focusedFolder);
  const [activeFile2, setActiveFile] = Recoil_index_14(activeFile);
  const [sections2, setSections] = Recoil_index_14(sections);
  const [_folderTree, setFolderTree] = Recoil_index_14(folderTree);
  const [selectedFiles, setSelectedFiles] = p2([]);
  const [offsetLeft, setOffsetLeft] = p2(0);
  const listRef = _2();
  const forceUpdate = useForceUpdate();
  const loadFolderTree = async (folder) => {
    setFolderTree(await sortFolderTree(folder, plugin));
  };
  h2(() => {
    window.addEventListener(eventTypes.vaultChange, vaultChangeEvent);
    window.addEventListener(eventTypes.activeFileChange, changeActiveFile);
    window.addEventListener(eventTypes.refreshView, forceUpdate);
    window.addEventListener(eventTypes.settingsChanged, settingsChanged);
    window.addEventListener(eventTypes.revealFile, handleRevealFileEvent);
    return () => {
      window.removeEventListener(eventTypes.vaultChange, vaultChangeEvent);
      window.removeEventListener(eventTypes.activeFileChange, changeActiveFile);
      window.removeEventListener(eventTypes.refreshView, forceUpdate);
      window.removeEventListener(eventTypes.settingsChanged, settingsChanged);
      window.removeEventListener(eventTypes.revealFile, handleRevealFileEvent);
    };
  }, []);
  const handleRevealFileEvent = (evt) => {
    if (evt.detail) {
      setSelectedFiles([evt.detail.file]);
      const folders = evt.detail.file.path.split("/");
      const openPaths = folders.reduce((p3, c3) => [...p3, `${p3}/${c3}`], ["/"]).slice(0, -1);
      const newOpenFolders = [...openFolders2.filter((f4) => !openPaths.find((g4) => g4 == f4)), ...openPaths];
      plugin.settings.openFolders = newOpenFolders;
      plugin.saveSettings();
    }
  };
  const vaultChangeEvent = (evt) => {
    if (evt.detail) {
      handleVaultChanges(evt.detail.file, evt.detail.changeType, evt.detail.oldPath);
    }
    const loadFolderTree2 = async () => {
      setFolderTree(await sortFolderTree(plugin.app.vault.getRoot(), plugin));
    };
    cleanData();
    plugin.saveSettings();
    loadFolderTree2();
  };
  const changeActiveFile = (evt) => {
    let filePath = evt.detail.filePath;
    const activeLeaf = plugin.app.workspace.activeLeaf;
    if (activeLeaf.view.getViewType() == FOLDER_VIEW_TYPE) {
      setActiveFile(activeLeaf.view.getState().folder);
    } else {
      let file = plugin.app.vault.getAbstractFileByPath(filePath);
      if (file) {
        setActiveFile(file.path);
      } else {
        setActiveFile(null);
      }
      ;
    }
  };
  function handleVaultChanges(file, changeType, oldPathBeforeRename) {
    if (changeType == "rename") {
      renamePathInStringTree(oldPathBeforeRename, file, plugin);
    }
    if (changeType == "delete") {
    }
  }
  const settingsChanged = () => {
    setSections(plugin.settings.spaces);
    setOpenFolders(plugin.settings.openFolders);
    setFileIcons(plugin.settings.fileIcons);
    setVaultCollapsed(plugin.settings.vaultCollapsed);
  };
  h2(() => {
    setInitialFocusedFolder();
    settingsChanged();
  }, []);
  const cleanData = () => {
    const cleanedSections = plugin.settings.spaces.map((f4) => {
      return {
        ...f4,
        children: f4.children.filter((f5) => plugin.app.vault.getAbstractFileByPath(f5))
      };
    });
    const cleanedCollapse = plugin.settings.openFolders;
    const cleanedFileIcons = plugin.settings.fileIcons.filter((f4) => plugin.app.vault.getAbstractFileByPath(f4[0]));
    plugin.settings.spaces = cleanedSections;
    plugin.settings.openFolders = cleanedCollapse;
    plugin.settings.fileIcons = cleanedFileIcons;
  };
  const setInitialFocusedFolder = () => {
    cleanData();
    loadFolderTree(plugin.app.vault.getRoot());
    setFocusedFolder(plugin.app.vault.getRoot());
  };
  const sensors = useSensors(useSensor(MouseSensor, {
    activationConstraint: {
      distance: 10
    }
  }), useSensor(TouchSensor, {
    activationConstraint: {
      delay: 250,
      tolerance: 5
    }
  }));
  const measuring = {
    droppable: {
      strategy: MeasuringStrategy.Always
    }
  };
  const [activeId, setActiveId] = p2(null);
  const [overId, setOverId] = p2(null);
  const [currentPosition, setCurrentPosition] = p2(null);
  const flattenSectionTree = (sectionTrees) => {
    const getChildren = (section, paths, sectionIndex) => {
      return flattenTrees(paths.map((f4) => plugin.app.vault.getAbstractFileByPath(f4)).filter((f4) => f4 != null), "/" + section + "/", sectionIndex, section, 1);
    };
    return sectionTrees.reduce((p3, c3, i3) => {
      return [...p3, {
        id: c3.section,
        parentId: null,
        name: c3.section,
        depth: 0,
        index: i3,
        section: i3,
        isFolder: true
      }, ...!c3.collapsed ? getChildren(c3.section, c3.children, i3) : []];
    }, []);
  };
  const flattenedItems = F(() => {
    const flattenedTree = [
      ...flattenSectionTree(sections2),
      ..._folderTree ? flattenTree(_folderTree, "/", -1, vaultCollapsed) : []
    ];
    return includeChildrenOf(flattenedTree, openFolders2);
  }, [_folderTree, openFolders2, sections2, vaultCollapsed]);
  const sortedIds = F(() => flattenedItems.map(({ id }) => id), [flattenedItems]);
  const activeItem = activeId ? flattenedItems.find(({ id }) => id === activeId) : null;
  const overIndex = overId ? flattenedItems.findIndex(({ id }) => id === overId) : null;
  const overItem = flattenedItems[overIndex];
  const nextItem = flattenedItems[overIndex + 1];
  const dragDepth = F(() => {
    return getDragDepth(offsetLeft, indentationWidth);
  }, [offsetLeft]);
  const projected = F(() => {
    return activeId && overId ? getProjection(flattenedItems, activeItem, overIndex, overItem, nextItem, dragDepth) : null;
  }, [flattenedItems, activeItem, overItem, nextItem, overIndex, dragDepth]);
  function handleDragStart(event) {
    const { active: { id: activeId2 } } = event;
    const activeItem2 = flattenedItems.find(({ id }) => id === activeId2);
    if (activeItem2.parentId == null && activeItem2.section == -1)
      return;
    setActiveId(activeId2);
    setOverId(activeId2);
    if (activeItem2) {
      setCurrentPosition({
        parentId: activeItem2.parentId,
        overId: activeId2
      });
    }
    document.body.style.setProperty("cursor", "grabbing");
  }
  function handleDragMove({ delta }) {
    setOffsetLeft(Math.max(1, delta.x));
  }
  function handleDragOver({ over }) {
    var _a2;
    const overId2 = over == null ? void 0 : over.id;
    if (overId2) {
      setOverId((_a2 = over == null ? void 0 : over.id) != null ? _a2 : null);
    }
  }
  function handleDragEnd({ active, over }) {
    resetState();
    moveFile(active, over);
  }
  const moveFile = async (active, over) => {
    if (projected) {
      const clonedItems = [
        ...flattenSectionTree(sections2),
        ..._folderTree ? flattenTree(_folderTree, "/", -1, false) : []
      ];
      const overIndex2 = clonedItems.findIndex(({ id }) => id === over.id);
      const overItem2 = clonedItems[overIndex2];
      const activeIndex = clonedItems.findIndex(({ id }) => id === active.id);
      const activeTreeItem = clonedItems[activeIndex];
      const activeIsSection = activeTreeItem.parentId == null;
      const overIsSection = overItem2.parentId == null;
      if (activeIsSection) {
        if (overIsSection) {
          const newSections = overItem2.section == -1 ? arrayMove(sections2, activeTreeItem.index, sections2.length - 1) : overItem2.index > activeIndex ? arrayMove(sections2, activeTreeItem.index, overItem2.index - 1) : arrayMove(sections2, activeTreeItem.index, overItem2.index);
          plugin.settings.spaces = newSections;
          plugin.saveSettings();
          return;
        }
      }
      const { depth, overId: overId2, parentId } = projected;
      const parentItem = clonedItems.find(({ id }) => id === parentId);
      if (overItem2.section != activeItem.section || overItem2.section != -1) {
        if (overItem2.section == -1) {
          return;
        }
        if (parentId != sections2[overItem2.section].section && parentId != null) {
          return;
        }
        const newSections = sections2.map((s3, k4) => {
          if (k4 == overItem2.section) {
            const index = sections2[overItem2.section].children.findIndex((f4) => f4 == overItem2.path) + 1;
            const activeIndex2 = s3.children.findIndex((g4) => g4 == activeItem.path);
            const children = s3.children.filter((g4) => g4 != activeItem.path);
            const toIndex = activeIndex2 <= index && activeIndex2 != -1 ? index - 1 : index;
            if (activeIndex2 == -1) {
              new import_obsidian8.Notice(i18n_default.notice.addedToSection);
            }
            return {
              ...s3,
              children: [...children.slice(0, toIndex), activeItem.path, ...children.slice(toIndex)]
            };
          }
          return s3;
        });
        plugin.settings.spaces = newSections;
        plugin.saveSettings();
        return;
      }
      if (parentId != activeTreeItem.parentId) {
        const newPath = `${parentItem.isFolder ? parentItem.path : parentItem.parent.path}/${activeItem.name}`;
        if (plugin.app.vault.getAbstractFileByPath(newPath)) {
          new import_obsidian8.Notice(i18n_default.notice.duplicateFile);
          return;
        }
        await props.plugin.app.vault.rename(activeTreeItem, newPath);
        clonedItems[activeIndex] = { ...activeTreeItem, depth, parentId, ...plugin.app.vault.getAbstractFileByPath(newPath) };
      } else {
        clonedItems[activeIndex] = { ...activeTreeItem, depth, parentId };
      }
      const sortedItems = overIndex2 > activeIndex ? arrayMove(clonedItems, activeIndex, overIndex2) : overIndex2 < activeIndex ? arrayMove(clonedItems, activeIndex, overIndex2 + 1) : clonedItems;
      const newItems = buildTree(sortedItems);
      const newFolderRank = folderTreeToStringTree(newItems);
      plugin.settings.folderRank = newFolderRank;
      await plugin.saveSettings();
      loadFolderTree(plugin.app.vault.getRoot());
    }
  };
  const adjustTranslate = ({ transform }) => {
    return {
      ...transform,
      x: transform.x,
      y: transform.y - 10
    };
  };
  function handleDragCancel() {
    resetState();
  }
  const handleCollapse = T2((folder) => {
    if (folder.parentId == null) {
      if (folder.id == "/") {
        plugin.settings.vaultCollapsed = !plugin.settings.vaultCollapsed;
        plugin.saveSettings();
        return;
      }
      const newSections = sections2.map((s3, i3) => {
        return i3 == folder.index ? { ...s3, collapsed: !s3.collapsed } : s3;
      });
      plugin.settings.spaces = newSections;
      plugin.saveSettings();
    } else {
      const folderOpen = openFolders2.find((f4) => f4 == folder.id);
      const newOpenFolders = !folderOpen ? [...openFolders2, folder.id] : openFolders2.filter((openFolder) => folder.id !== openFolder);
      plugin.settings.openFolders = newOpenFolders;
      plugin.saveSettings();
    }
  }, [plugin, openFolders2, sections2]);
  function resetState() {
    setOverId(null);
    setActiveId(null);
    setOffsetLeft(0);
    document.body.style.setProperty("cursor", "");
  }
  const itemData = F(() => {
    if (listRef == null ? void 0 : listRef.current)
      listRef.current.resetAfterIndex(0);
    return { flattenedItems, projected, handleCollapse, plugin, sections: sections2, openFolders: openFolders2, indentationWidth };
  }, [flattenedItems, projected, handleCollapse, plugin, sections2, openFolders2, indentationWidth]);
  const rowHeight = (index) => isMobile ? flattenedItems[index].parentId == null ? 60 : 40 : flattenedItems[index].parentId == null ? 44 : 29;
  return /* @__PURE__ */ bn.createElement("div", {
    className: "mk-file-tree"
  }, /* @__PURE__ */ bn.createElement(DndContext, {
    sensors,
    collisionDetection: closestCenter,
    measuring,
    onDragStart: handleDragStart,
    onDragMove: handleDragMove,
    onDragOver: handleDragOver,
    onDragEnd: handleDragEnd,
    onDragCancel: handleDragCancel
  }, /* @__PURE__ */ bn.createElement(SortableContext, {
    items: sortedIds,
    strategy: verticalListSortingStrategy
  }, /* @__PURE__ */ bn.createElement(AutoSizer, null, ({ height, width }) => /* @__PURE__ */ bn.createElement(VariableSizeList, {
    ref: listRef,
    height,
    itemSize: rowHeight,
    itemCount: itemData.flattenedItems.length,
    itemData,
    width,
    overscanCount: plugin.settings.spacesPerformance ? 0 : 20
  }, row)), j3(/* @__PURE__ */ bn.createElement(DragOverlay, {
    dropAnimation: null,
    modifiers: [adjustTranslate],
    zIndex: 1600
  }, activeId ? /* @__PURE__ */ bn.createElement(SortableTreeItem, {
    id: activeId,
    data: flattenedItems.find((f4) => f4.id == activeId),
    indicator: null,
    depth: 0,
    disabled: false,
    plugin,
    clone: true,
    childCount: 0,
    style: {},
    indentationWidth
  }) : null), document.body))));
};

// src/components/Spaces/NewNote.tsx
var NewNotes = (props) => {
  const [focusedFolder2, setFocusedFolder] = Recoil_index_14(focusedFolder);
  const { plugin } = props;
  const newFile = async () => {
    await createNewMarkdownFile(props.plugin.app, focusedFolder2, "", "");
  };
  return /* @__PURE__ */ bn.createElement("div", {
    className: "mk-flow-bar"
  }, /* @__PURE__ */ bn.createElement("button", {
    "aria-label": i18n_default.buttons.newNote,
    className: "mk-new-note",
    onClick: () => newFile()
  }, /* @__PURE__ */ bn.createElement("div", {
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-new-note"] }
  }), /* @__PURE__ */ bn.createElement("p", null, i18n_default.buttons.newNote)));
};

// src/components/Spaces/MainMenu.tsx
var import_obsidian9 = require("obsidian");
var replaceMobileMainMenu = (plugin) => {
  if (platformIsMobile()) {
    const header = app.workspace.containerEl.querySelector(".workspace-drawer.mod-left .workspace-drawer-header-left");
    const reactEl = createRoot(header);
    reactEl.render(/* @__PURE__ */ bn.createElement(MainMenu, {
      plugin
    }));
  }
};
var MainMenu = (props) => {
  const { plugin } = props;
  const ref = _2();
  const toggleSections = (collapse) => {
    const newSections = plugin.settings.spaces.map((s3) => {
      return { ...s3, collapsed: collapse };
    });
    plugin.settings.spaces = newSections;
    plugin.saveSettings();
  };
  const newSection = () => {
    let vaultChangeModal = new SectionChangeModal(plugin, "", 0, "create");
    vaultChangeModal.open();
  };
  h2(() => {
    refreshLeafs();
  }, []);
  const refreshLeafs = () => {
    let ribbons = [];
    let leafs = [];
    let spaceActive = true;
    if (plugin.app.workspace.leftSplit && platformIsMobile()) {
      const mobileDrawer = plugin.app.workspace.leftSplit;
      const leaves = mobileDrawer.children;
      const index = leaves.reduce((p3, c3, i3) => {
        return c3.getViewState().type == FILE_TREE_VIEW_TYPE ? i3 : p3;
      }, -1);
      spaceActive = index == mobileDrawer.currentTab;
      leafs.push(...leaves.filter((l3, i3) => i3 != index));
    }
    if (plugin.app.workspace.leftRibbon && !props.plugin.settings.sidebarRibbon) {
      ribbons.push(...plugin.app.workspace.leftRibbon.orderedRibbonActions);
    }
    return { ribbons, leafs, spaceActive };
  };
  const showMenu = (e3) => {
    const { ribbons, spaceActive, leafs } = refreshLeafs();
    const menu = new import_obsidian9.Menu();
    !spaceActive && menu.addItem((menuItem) => {
      menuItem.setIcon("lucide-arrow-left");
      menuItem.setTitle(i18n_default.menu.backToSpace);
      menuItem.onClick((ev) => {
        const leaves = plugin.app.workspace.getLeavesOfType(FILE_TREE_VIEW_TYPE);
        if (leaves.length > 0) {
          plugin.app.workspace.revealLeaf(leaves[0]);
        }
      });
    });
    menu.addItem((menuItem) => {
      menuItem.setIcon("plus");
      menuItem.setTitle(i18n_default.menu.newSpace);
      menuItem.onClick((ev) => {
        newSection();
      });
    });
    menu.addItem((menuItem) => {
      menuItem.setIcon("lucide-chevrons-down-up");
      menuItem.setTitle(i18n_default.menu.collapseAllSections);
      menuItem.onClick((ev) => {
        toggleSections(true);
      });
    });
    menu.addItem((menuItem) => {
      menuItem.setIcon("lucide-chevrons-up-down");
      menuItem.setTitle(i18n_default.menu.expandAllSections);
      menuItem.onClick((ev) => {
        toggleSections(false);
      });
    });
    menu.addSeparator();
    leafs.map((l3) => menu.addItem((menuItem) => {
      menuItem.setIcon(l3.view.icon);
      menuItem.setTitle(l3.getDisplayText());
      menuItem.onClick((ev) => {
        plugin.app.workspace.revealLeaf(l3);
      });
    }));
    menu.addItem((menuItem) => {
      menuItem.setIcon("lucide-settings");
      menuItem.setTitle(i18n_default.menu.obSettings);
      menuItem.onClick((ev) => {
        plugin.app.commands.commands["app:open-settings"].callback();
      });
    });
    menu.addItem((menuItem) => {
      menuItem.setIcon("vault");
      menuItem.setTitle(i18n_default.menu.openVault);
      menuItem.onClick((ev) => {
        plugin.app.commands.commands["app:open-vault"].callback();
      });
    });
    menu.addSeparator();
    ribbons.map((r3) => menu.addItem((menuItem) => {
      menuItem.setIcon(r3.icon);
      menuItem.setTitle(r3.title);
      menuItem.onClick((ev) => {
        r3.callback();
      });
    }));
    menu.addSeparator();
    menu.addItem((menuItem) => {
      menuItem.setIcon("mk-logo");
      menuItem.setTitle(i18n_default.menu.getHelp);
      menuItem.onClick((ev) => {
        window.open("https://make.md/community");
      });
    });
    const offset2 = ref.current.getBoundingClientRect();
    menu.showAtPosition({ x: offset2.left, y: offset2.top + 30 });
  };
  return /* @__PURE__ */ bn.createElement("div", {
    className: "mk-main-menu-container"
  }, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-main-menu-button",
    ref,
    onClick: (e3) => showMenu(e3)
  }, plugin.app.vault.getName(), /* @__PURE__ */ bn.createElement("div", {
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-expand"] }
  })));
};

// src/components/Spaces/FileTreeView.tsx
var FILE_TREE_VIEW_TYPE = "mk-file-view";
var VIEW_DISPLAY_TEXT = "Spaces";
var ICON = "layout-grid";
var FileTreeView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.navigation = false;
    this.plugin = plugin;
  }
  revealInFolder(file) {
    if (file instanceof import_obsidian10.TFolder) {
      this.plugin.app.workspace.activeLeaf.setViewState({ type: FOLDER_VIEW_TYPE, state: { folder: file.path } });
      this.plugin.app.workspace.requestSaveLayout();
    } else {
      let evt = new CustomEvent(eventTypes.revealFile, { detail: { file } });
      window.dispatchEvent(evt);
    }
  }
  getViewType() {
    return FILE_TREE_VIEW_TYPE;
  }
  getDisplayText() {
    return VIEW_DISPLAY_TEXT;
  }
  getIcon() {
    return ICON;
  }
  async onClose() {
    let leafs = this.app.workspace.getLeavesOfType(FILE_TREE_VIEW_TYPE);
    if (leafs.length == 0) {
      let leaf = this.app.workspace.getLeftLeaf(false);
      await leaf.setViewState({ type: FILE_TREE_VIEW_TYPE });
    }
    this.destroy();
  }
  destroy() {
    if (this.root)
      this.root.unmount();
  }
  async onOpen() {
    this.destroy();
    this.constructFileTree(this.app.vault.getRoot().path, "");
  }
  constructFileTree(folderPath, vaultChange) {
    this.destroy();
    this.root = createRoot(this.contentEl);
    this.root.render(/* @__PURE__ */ bn.createElement("div", {
      className: "mk-sidebar"
    }, /* @__PURE__ */ bn.createElement(Recoil_index_2, null, !platformIsMobile() ? /* @__PURE__ */ bn.createElement(MainMenu, {
      plugin: this.plugin
    }) : null, /* @__PURE__ */ bn.createElement(NewNotes, {
      plugin: this.plugin
    }), /* @__PURE__ */ bn.createElement(FileExplorerComponent, {
      fileTreeView: this,
      plugin: this.plugin
    }))));
  }
};

// src/settings.ts
var import_obsidian11 = require("obsidian");
var DEFAULT_SETTINGS = {
  filePreviewOnHover: false,
  markSans: true,
  makeMenuPlaceholder: true,
  mobileMakeBar: true,
  inlineStyler: true,
  inlineStylerColors: false,
  editorFlow: true,
  editorFlowStyle: "seamless",
  spacesEnabled: true,
  spacesPerformance: false,
  spacesStickers: true,
  spacesDisablePatch: false,
  sidebarRibbon: false,
  sidebarTabs: false,
  deleteFileOption: "trash",
  folderRank: {
    node: "root",
    children: [],
    isFolder: true
  },
  openFolders: [],
  fileIcons: [],
  spaces: [],
  vaultCollapsed: false,
  menuTriggerChar: "/",
  emojiTriggerChar: ":"
};
var MakeMDPluginSettingsTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  refreshView() {
    let evt = new CustomEvent(eventTypes.refreshView, {});
    window.dispatchEvent(evt);
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: i18n_default.settings.sectionSidebar });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.spaces.name).setDesc(i18n_default.settings.spaces.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.spacesEnabled).onChange((value) => {
      this.plugin.settings.spacesEnabled = value;
      this.plugin.saveSettings();
      if (value) {
        this.plugin.openFileTreeLeaf(true);
      } else {
        this.plugin.detachFileTreeLeafs();
      }
      this.refreshView();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.spacesStickers.name).setDesc(i18n_default.settings.spacesStickers.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.spacesStickers).onChange((value) => {
      this.plugin.settings.spacesStickers = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    containerEl.createEl("h2", { text: i18n_default.settings.sectionFlow });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.editorFlowReplace.name).setDesc(i18n_default.settings.editorFlowReplace.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.editorFlow).onChange((value) => {
      this.plugin.settings.editorFlow = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.editorFlowStyle.name).setDesc(i18n_default.settings.editorFlowStyle.desc).addDropdown((dropdown) => {
      dropdown.addOption("classic", i18n_default.settings.editorFlowStyle.classic);
      dropdown.addOption("seamless", i18n_default.settings.editorFlowStyle.seamless);
      dropdown.setValue(this.plugin.settings.editorFlowStyle).onChange(async (value) => {
        this.plugin.settings.editorFlowStyle = value;
        document.body.classList.toggle("mk-flow-classic", false);
        document.body.classList.toggle("mk-flow-seamless", false);
        if (value == "seamless")
          document.body.classList.toggle("mk-flow-seamless", true);
        if (value == "classic")
          document.body.classList.toggle("mk-flow-classic", true);
      });
    });
    containerEl.createEl("h2", { text: i18n_default.settings.sectionEditor });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.makeChar.name).setDesc(i18n_default.settings.makeChar.desc).addText((text) => {
      text.setValue(this.plugin.settings.menuTriggerChar).onChange(async (value) => {
        if (value.trim().length < 1) {
          text.setValue(this.plugin.settings.menuTriggerChar);
          return;
        }
        let char = value[0];
        if (value.trim().length === 2) {
          char = value.replace(this.plugin.settings.menuTriggerChar, "");
        }
        text.setValue(char);
        this.plugin.settings.menuTriggerChar = char;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.editorMakePlacholder.name).setDesc(i18n_default.settings.editorMakePlacholder.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.makeMenuPlaceholder).onChange((value) => {
      this.plugin.settings.makeMenuPlaceholder = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.mobileMakeBar.name).setDesc(i18n_default.settings.mobileMakeBar.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.mobileMakeBar).onChange((value) => {
      this.plugin.settings.mobileMakeBar = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.inlineStyler.name).setDesc(i18n_default.settings.inlineStyler.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.inlineStyler).onChange((value) => {
      this.plugin.settings.inlineStyler = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    containerEl.createEl("h2", { text: i18n_default.settings.sectionAdvanced });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.sidebarRibbon.name).setDesc(i18n_default.settings.sidebarRibbon.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.sidebarRibbon).onChange((value) => {
      this.plugin.settings.sidebarRibbon = value;
      this.plugin.saveSettings();
      document.body.classList.toggle("mk-hide-ribbon", !value);
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.sidebarTabs.name).setDesc(i18n_default.settings.sidebarTabs.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.sidebarTabs).onChange((value) => {
      this.plugin.settings.sidebarTabs = value;
      this.plugin.saveSettings();
      document.body.classList.toggle("mk-hide-tabs", !value);
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.spacesFileExplorerDual.name).setDesc(i18n_default.settings.spacesFileExplorerDual.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.spacesDisablePatch).onChange((value) => {
      this.plugin.settings.spacesDisablePatch = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.spacesPerformance.name).setDesc(i18n_default.settings.spacesPerformance.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.spacesPerformance).onChange((value) => {
      this.plugin.settings.spacesPerformance = value;
      this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.spacesDeleteOption.name).setDesc(i18n_default.settings.spacesDeleteOption.desc).addDropdown((dropdown) => {
      dropdown.addOption("permanent", i18n_default.settings.spacesDeleteOptions.permanant);
      dropdown.addOption("trash", i18n_default.settings.spacesDeleteOptions.trash);
      dropdown.addOption("system-trash", i18n_default.settings.spacesDeleteOptions["system-trash"]);
      dropdown.setValue(this.plugin.settings.deleteFileOption);
      dropdown.onChange((option) => {
        this.plugin.settings.deleteFileOption = option;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.inlineStylerColor.name).setDesc(i18n_default.settings.inlineStylerColor.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.inlineStylerColors).onChange((value) => {
      this.plugin.settings.inlineStylerColors = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
    new import_obsidian11.Setting(containerEl).setName(i18n_default.settings.editorMarkSans.name).setDesc(i18n_default.settings.editorMarkSans.desc).addToggle((toggle) => toggle.setValue(this.plugin.settings.markSans).onChange((value) => {
      this.plugin.settings.markSans = value;
      this.plugin.saveSettings();
      this.refreshView();
    }));
  }
};

// src/components/MakeMenu/MakeMenu.tsx
var import_obsidian12 = require("obsidian");

// src/components/MakeMenu/commands/default.ts
var default_default = [
  {
    label: "todo",
    value: "- [ ] ",
    icon: "mk-make-todo"
  },
  {
    label: "list",
    value: `- `,
    icon: "mk-make-list"
  },
  {
    label: "ordered-list",
    value: `1. `,
    icon: "mk-make-ordered"
  },
  {
    label: "h1",
    value: "# ",
    icon: "mk-make-h1"
  },
  {
    label: "h2",
    value: "## ",
    icon: "mk-make-h2"
  },
  {
    label: "h3",
    value: "### ",
    icon: "mk-make-h3"
  },
  {
    label: "quote",
    value: "> ",
    icon: "mk-make-quote"
  },
  {
    label: "divider",
    value: `
---
`,
    icon: "mk-make-hr"
  },
  {
    label: "link",
    value: "<Paste Link>",
    offset: [-1, 1],
    icon: "mk-make-link"
  },
  {
    label: "image",
    value: "![](Paste Link)",
    offset: [-1, 4],
    icon: "mk-make-image"
  },
  {
    label: "codeblock",
    value: `
\`\`\`
Type/Paste Your Code
\`\`\``,
    offset: [-4, 5],
    icon: "mk-make-codeblock"
  },
  {
    label: "callout",
    value: `> [!NOTE]
> Content`,
    offset: [-7, 12],
    icon: "mk-make-callout"
  },
  {
    label: "note",
    value: "[[Note Name]]",
    offset: [-2, 2],
    icon: "mk-make-note"
  },
  {
    label: "flow",
    value: `!![[Note Name]]`,
    offset: [-2, 4],
    icon: "mk-make-flow"
  },
  {
    label: "tag",
    value: "#tag",
    offset: [0, 1],
    icon: "mk-make-tag"
  }
];

// src/components/MakeMenu/commands/index.ts
function resolveCommands(plugin) {
  return default_default;
}

// src/components/MakeMenu/MakeMenu.tsx
var MakeMenu = class extends import_obsidian12.EditorSuggest {
  constructor(app2, plugin) {
    super(app2);
    this.inCmd = false;
    this.cmdStartCh = 0;
    this.plugin = plugin;
  }
  resetInfos() {
    this.cmdStartCh = 0;
    this.inCmd = false;
  }
  onTrigger(cursor, editor, _file) {
    const currentLine = editor.getLine(cursor.line).slice(0, cursor.ch);
    const triggerCharLength = this.plugin.settings.menuTriggerChar.length;
    if (!this.inCmd && currentLine.slice(0, triggerCharLength) !== this.plugin.settings.menuTriggerChar && currentLine.slice(-2 - triggerCharLength) !== "- " + this.plugin.settings.menuTriggerChar) {
      this.resetInfos();
      return null;
    }
    if (!this.inCmd) {
      this.cmdStartCh = currentLine.length - triggerCharLength;
      this.inCmd = true;
    }
    const currentCmd = currentLine.slice(this.cmdStartCh, cursor.ch);
    if (currentCmd.includes(" ") || !currentCmd.includes(this.plugin.settings.menuTriggerChar)) {
      this.resetInfos();
      return null;
    }
    return { start: cursor, end: cursor, query: currentCmd.slice(triggerCharLength) };
  }
  getSuggestions(context) {
    const suggestions = resolveCommands(this.plugin).filter(({ label }) => label.toLowerCase().includes(context.query.toLowerCase()) || i18n_default.commands[label] && i18n_default.commands[label].toLowerCase().includes(context.query.toLowerCase()));
    return suggestions.length > 0 ? suggestions : [{ label: i18n_default.commandsSuggest.noResult, value: "", icon: "" }];
  }
  renderSuggestion(value, el) {
    const div = el.createDiv("mk-slash-item");
    const icon = div.createDiv("mk-slash-icon");
    icon.innerHTML = makeIconSet[value.icon];
    const title = div.createDiv();
    title.setText(i18n_default.commands[value.label]);
  }
  selectSuggestion(cmd, _evt) {
    if (cmd.label === i18n_default.commandsSuggest.noResult)
      return;
    this.context.editor.replaceRange(cmd.value, { ...this.context.start, ch: this.cmdStartCh }, this.context.end);
    if (cmd.offset) {
      this.context.editor.setSelection({ ...this.context.start, ch: this.cmdStartCh + cmd.offset[1] }, { ...this.context.end, ch: this.cmdStartCh + cmd.value.length + cmd.offset[0] });
    }
    this.resetInfos();
    this.close();
  }
};

// src/components/StickerMenu/StickerMenu.tsx
var import_obsidian13 = require("obsidian");
var StickerMenu = class extends import_obsidian13.EditorSuggest {
  constructor(app2, plugin) {
    super(app2);
    this.inCmd = false;
    this.cmdStartCh = 0;
    this.plugin = plugin;
    this.emojis = Object.keys(emojis).reduce((p3, c3) => [...p3, ...emojis[c3].map((e3) => ({ label: e3.n[0], desc: e3.n[1], variants: e3.v, unicode: e3.u }))], []);
  }
  resetInfos() {
    this.cmdStartCh = 0;
    this.inCmd = false;
  }
  onTrigger(cursor, editor, _file) {
    const currentLine = editor.getLine(cursor.line).slice(0, cursor.ch);
    if (!this.inCmd && !(currentLine.slice(-2) == " " + this.plugin.settings.emojiTriggerChar || currentLine[0] == this.plugin.settings.emojiTriggerChar)) {
      this.resetInfos();
      return null;
    }
    if (!this.inCmd) {
      this.cmdStartCh = currentLine.length - 1;
      this.inCmd = true;
    }
    const currentCmd = currentLine.slice(this.cmdStartCh, cursor.ch);
    if (currentCmd.includes(" ") || !currentCmd.includes(this.plugin.settings.emojiTriggerChar)) {
      this.resetInfos();
      return null;
    }
    this.suggestEl.classList.toggle("mk-emoji-menu", true);
    return { start: cursor, end: cursor, query: currentCmd.slice(1) };
  }
  getSuggestions(context) {
    const suggestions = this.emojis.filter(({ label, desc }) => label.includes(context.query) || (desc == null ? void 0 : desc.includes(context.query)));
    return suggestions.length > 0 ? suggestions : [{ label: i18n_default.commandsSuggest.noResult, unicode: "", desc: "" }];
  }
  renderSuggestion(value, el) {
    const div = document.createElement("div");
    div.setAttribute("aria-label", value.label);
    const reactElement = createRoot(div);
    reactElement.render(/* @__PURE__ */ bn.createElement(bn.Fragment, null, value.unicode.length > 0 ? unifiedToNative(value.unicode) : i18n_default.commandsSuggest.noResult));
    el.appendChild(div);
  }
  selectSuggestion(cmd, _evt) {
    if (cmd.label === i18n_default.commandsSuggest.noResult)
      return;
    this.context.editor.replaceRange(unifiedToNative(cmd.unicode), { ...this.context.start, ch: this.cmdStartCh }, this.context.end);
    this.resetInfos();
    this.close();
  }
};

// src/cm-extensions/markSans/hr.ts
var import_view5 = require("@codemirror/view");
var import_state7 = require("@codemirror/state");
var resetLine = import_view5.Decoration.line({ class: "mk-reset" });
var needsReset = (state, typeString, from, to) => {
  const length = to - from;
  if (typeString.contains("HyperMD-header")) {
    if (parseInt(typeString.replace(/.*HyperMD-header-(\d+).*/, "$1")) == length) {
      return true;
    }
    let truefalse = true;
    iterateTreeInSelection({ from, to }, state, {
      enter: ({ type, from: from2, to: to2 }) => {
        if (type.name.contains("formatting-header")) {
          truefalse = false;
        }
      }
    });
    return truefalse;
  }
  return false;
};
var hrResetFix = import_state7.StateField.define({
  create() {
    return import_view5.Decoration.none;
  },
  update(value, tr) {
    let builder = new import_state7.RangeSetBuilder();
    iterateTreeInDocument(tr.state, {
      enter: ({ type, from, to }) => {
        if (needsReset(tr.state, type.name, from, to)) {
          builder.add(from, from, resetLine);
        }
      }
    });
    const dec = builder.finish();
    return dec;
  },
  provide: (f4) => import_view5.EditorView.decorations.from(f4)
});
var hrDecorations = (state) => {
  let builder = new import_state7.RangeSetBuilder();
  let nodes2 = [];
  iterateTreeInDocument(state, {
    enter: ({ name, from, to }) => {
      if (name.contains("formatting-header") && state.sliceDoc(from, to) == "---" && !(state.selection.main.from >= from && state.selection.main.to <= to)) {
        builder.add(from, to, hr);
      }
    }
  });
  const dec = builder.finish();
  return dec;
};
var hrField = import_state7.StateField.define({
  create(state) {
    return hrDecorations(state);
  },
  update(value, tr) {
    if (!tr.docChanged)
      return value;
    return hrDecorations(tr.state);
  },
  provide: (f4) => import_view5.EditorView.decorations.from(f4)
});
var HRWidget = class extends import_view5.WidgetType {
  constructor() {
    super();
  }
  eq(other) {
    return true;
  }
  toDOM() {
    const div = document.createElement("hr");
    return div;
  }
};
var hr = import_view5.Decoration.replace({
  widget: new HRWidget(),
  block: false
});

// src/cm-extensions/inlineStylerView/marks.ts
var import_state8 = require("@codemirror/state");

// src/cm-extensions/markSans/obsidianSyntax.ts
var oMarks = [
  {
    mark: "em",
    formatting: "formatting-em",
    altFormatting: "em_formatting_formatting-strong",
    formatChar: "*"
  },
  {
    mark: "strong",
    formatting: "formatting-strong",
    formatChar: "**"
  },
  {
    mark: "strikethrough",
    formatting: "formatting-strikethrough",
    formatChar: "~~"
  },
  {
    mark: "inline-code",
    formatting: "formatting-code",
    formatChar: "`"
  }
];

// src/cm-extensions/inlineStylerView/marks.ts
var toggleMark = import_state8.Annotation.define();
var trimSpace = (pos, moveDirLeft, state) => {
  if (moveDirLeft && state.sliceDoc(pos, pos + 1) == " ")
    return pos + 1;
  if (!moveDirLeft && state.sliceDoc(pos - 1, pos) == " ")
    return pos - 1;
  return pos;
};
var newPosAfterFormatting = (pos, moveDirLeft, state) => {
  const line = state.doc.lineAt(pos);
  const start2 = moveDirLeft ? line.from : pos;
  const end2 = moveDirLeft ? pos : line.to;
  let newPos = start2;
  let lastFormatPos = start2;
  let exitFormatRange = false;
  iterateTreeInSelection({ from: start2, to: end2 }, state, {
    enter: (node) => {
      if (exitFormatRange)
        return false;
      if (node.name.contains("formatting")) {
        if (!moveDirLeft && node.from > start2) {
          return false;
        }
        if (moveDirLeft) {
          newPos = node.from;
          lastFormatPos = node.to;
        } else {
          newPos = node.to;
        }
      }
    }
  });
  if (moveDirLeft && lastFormatPos < pos) {
    newPos = pos;
  }
  return newPos;
};
var expandRange = (selection, state) => {
  const from = trimSpace(newPosAfterFormatting(selection.from, true, state), true, state);
  const to = trimSpace(newPosAfterFormatting(selection.to, false, state), false, state);
  return { from, to };
};
var addMarkAtPos = (pos, mark) => ({ changes: { from: pos, to: pos, insert: mark.formatChar } });
var rangeIsMark = (state, mark, selection) => posIsMark(selection.from, state, mark.mark) && posIsMark(selection.to, state, mark.mark);
var posIsMark = (pos, state, markString) => {
  let isMark = false;
  iterateTreeAtPos(pos, state, {
    enter: ({ name, from, to }) => {
      if (nodeNameContainsMark(name, markString))
        isMark = true;
    }
  });
  return isMark;
};
var nodeNameContainsMark = (name, markString) => {
  return name.contains(markString);
};
var edgeIsMark = (pos, state, mark) => posIsMark(pos, state, mark.mark);
var edgeIsMarkFormat = (pos, state, mark) => posIsMark(pos, state, mark.formatting) ? true : mark.altFormatting ? posIsMark(pos, state, mark.altFormatting) : false;
var transactionChangesForMark = (range, mark, state) => {
  let newTrans = [];
  if (rangeIsMark(state, mark, range)) {
    if (edgeIsMarkFormat(range.from, state, mark) && !edgeIsMarkFormat(range.to, state, mark)) {
      newTrans.push(addMarkAtPos(range.to, mark));
    }
    if (edgeIsMarkFormat(range.to, state, mark) && !edgeIsMarkFormat(range.from, state, mark)) {
      newTrans.push(addMarkAtPos(range.from, mark));
    }
  } else if (edgeIsMark(range.from, state, mark)) {
    if (edgeIsMarkFormat(range.from, state, mark) && !edgeIsMark(range.from - 1, state, mark)) {
      newTrans.push(addMarkAtPos(range.from, mark));
    }
    newTrans.push(addMarkAtPos(range.to, mark));
  } else if (edgeIsMark(range.to, state, mark)) {
    if (edgeIsMarkFormat(range.to, state, mark) && !edgeIsMark(range.to + 1, state, mark)) {
      newTrans.push(addMarkAtPos(range.to, mark));
    }
    newTrans.push(addMarkAtPos(range.from, mark));
  } else {
    newTrans.push(addMarkAtPos(range.to, mark));
    newTrans.push(addMarkAtPos(range.from, mark));
  }
  return newTrans;
};
var removeAllInternalMarks = (sel, state, mark) => {
  let returnTrans = [];
  iterateTreeInSelection({ from: sel.from, to: sel.to }, state, {
    enter: ({ name, from, to }) => {
      if (nodeNameContainsMark(name, mark.formatting) || (mark.altFormatting ? nodeNameContainsMark(name, mark.altFormatting) : false))
        returnTrans.push({
          from,
          to: from + mark.formatChar.length
        });
    }
  });
  return {
    changes: returnTrans
  };
};
var toggleMarkExtension = import_state8.EditorState.transactionFilter.of((tr) => {
  if (!tr.annotation(toggleMark))
    return tr;
  const markToggle = tr.annotation(toggleMark);
  const mark = oMarks.find((f4) => f4.mark == markToggle);
  if (!mark) {
    return tr;
  }
  const selection = tr.startState.selection.main;
  let newTrans = [];
  if (selection.head == selection.anchor) {
    if (tr.startState.sliceDoc(selection.head - mark.formatChar.length, selection.head) == mark.formatChar && tr.startState.sliceDoc(selection.head, selection.head + mark.formatChar.length) == mark.formatChar) {
      newTrans.push({
        changes: {
          from: selection.head - mark.formatChar.length,
          to: selection.head + mark.formatChar.length
        }
      });
    } else {
      newTrans.push({
        changes: {
          from: selection.head,
          insert: mark.formatChar + mark.formatChar
        },
        selection: {
          anchor: selection.head + mark.formatChar.length,
          head: selection.head + mark.formatChar.length
        }
      });
    }
    return [tr, ...newTrans];
  }
  const range = expandRange(selection, tr.startState);
  newTrans.push(removeAllInternalMarks(range, tr.startState, mark));
  let newFrom = range.from;
  let newTo = range.to;
  newTrans.push(...transactionChangesForMark(range, mark, tr.startState));
  return [tr, ...newTrans, { selection: { anchor: newFrom, head: newTo } }];
});

// src/cm-extensions/markSans/selection.ts
var import_state9 = require("@codemirror/state");
var makerDelete = import_state9.EditorState.transactionFilter.of((tr) => {
  let newTrans = [];
  if (tr.isUserEvent("delete.forward")) {
  }
  if (tr.isUserEvent("delete.backward") && !tr.isUserEvent("delete.selection") && !tr.isUserEvent("delete.selection.smart")) {
    const selection = tr.newSelection.main;
    iterateTreeInSelection(selection, tr.startState, {
      enter: ({ type, from, to }) => {
        const mark = positionMarkOffset(type.name, from, to, tr.startState);
        if (mark) {
          if (!hasReset(tr.startState, from, to)) {
            newTrans.push(pointDeletion(tr, mark.from, mark.to, selection.from));
          }
        }
      }
    });
  }
  return [tr, ...newTrans];
});
var reverseSel = (t3) => {
  const sel = t3.selection;
  return {
    selection: import_state9.EditorSelection.single(sel.main.head, sel.main.anchor)
  };
};
var selFromTo = (from, to) => {
  return {
    selection: import_state9.EditorSelection.single(from, to)
  };
};
var delFromTo = (tr, from, to) => {
  return {
    changes: { from, to },
    annotations: import_state9.Transaction.userEvent.of(`${tr.annotation(import_state9.Transaction.userEvent)}.smart`)
  };
};
var pointDeletion = (tr, from, to, pos) => checkMarkMiddle(from, to, pos) ? deleteMark(tr, from, pos) : {};
var deleteMark = (tr, from, pos) => from == 0 ? delFromTo(tr, from, pos) : delFromTo(tr, from, pos);
var changeSelectionToEndPrevLine = (from, head) => selFromTo(from, head - 1);
var changeSelectionToAfterMark = (head, to) => selFromTo(head, to);
var changeSelectionToMark = (to, head) => selFromTo(to, head);
var rangeBeginsInMark = (from, to, pos) => pos >= from && pos < to;
var rangeEndsAtMark = (from, to, pos) => pos == from;
var pointSelection = (from, to, pos, left2) => checkLineStart(from, pos) ? to - from == 1 && left2 ? selectPreviousLine(from, pos) : selectLineStart(to) : checkMarkMiddle(from, to, pos) ? left2 && checkMarkMiddleRightMost(from, to, pos) ? selectPreviousLine(from, pos) : selectLineStart(to) : {};
var checkLineStart = (from, pos) => from == pos;
var checkMarkMiddle = (from, to, pos) => pos > from && pos < to;
var checkMarkMiddleRightMost = (from, to, pos) => pos == to - 1;
var selectPreviousLine = (from, pos) => from == 0 ? selFromTo(pos, pos) : selFromTo(from - 1, from - 1);
var selectLineStart = (to) => selFromTo(to, to);
var positionMarkOffset = (typeString, from, to, state) => {
  if (typeString.contains("HyperMD-header")) {
    return { from, to: from + parseInt(typeString.replace(/.*HyperMD-header-(\d+).*/, "$1")) + 1 };
  }
  if (typeString.contains("HyperMD-task-line")) {
    return { from, to: from + parseInt(typeString.replace(/.*HyperMD-list-line-(\d+).*/, "$1")) + 5 };
  }
  if (typeString.contains("formatting-list-ol")) {
    let returnMark = void 0;
    iterateTreeInSelection({ from, to }, state, {
      enter: ({ type, from: from2, to: to2 }) => {
        if (type.name.contains("HyperMD-list-line")) {
          returnMark = { from: from2, to: from2 + parseInt(type.name.replace(/.*HyperMD-list-line-(\d+).*/, "$1")) + 2 };
        }
      }
    });
    return returnMark;
  }
  if (typeString.contains("HyperMD-list-line")) {
    return { from, to: from + parseInt(typeString.replace(/.*HyperMD-list-line-(\d+).*/, "$1")) + 1 };
  }
  if (typeString.contains("HyperMD-quote") && !typeString.contains("HyperMD-quote-lazy")) {
    return { from, to: from + 1 };
  }
  return void 0;
};
var rangeSelection = (from, to, anchor, head) => {
  const minFrom = Math.min(anchor, head);
  const maxTo = Math.max(anchor, head);
  if (rangeEndsAtMark(from, to, maxTo)) {
    const newSel = changeSelectionToAfterMark(minFrom, to);
    return minFrom == anchor ? newSel : reverseSel(newSel);
  }
  if (rangeBeginsInMark(from, to, maxTo)) {
    const newSel = changeSelectionToEndPrevLine(minFrom, from);
    return minFrom == anchor ? newSel : reverseSel(newSel);
  }
  if (rangeBeginsInMark(from, to, minFrom)) {
    const newSel = changeSelectionToMark(to, maxTo);
    return minFrom == head ? newSel : reverseSel(newSel);
  }
  return {};
};
var hasReset = (state, from, to) => {
  var _a2;
  let trueFalse = false;
  (_a2 = state.field(hrResetFix, false)) == null ? void 0 : _a2.between(from, to, (f4, t3, v3) => {
    trueFalse = true;
  });
  return trueFalse;
};
var makerSelect = import_state9.EditorState.transactionFilter.of((tr) => {
  let newTrans = [];
  if (tr.isUserEvent("delete") || tr.isUserEvent("input")) {
    return tr;
  }
  const selection = tr.newSelection.main;
  if (selection.from == 0 && selection.to == 0)
    return tr;
  iterateTreeInSelection(selection, tr.state, {
    enter: ({ type, from, to }) => {
      const mark = positionMarkOffset(type.name, from, to, tr.state);
      if (mark) {
        if (!hasReset(tr.state, from, to))
          newTrans.push(selection.from != selection.to ? rangeSelection(mark.from, mark.to, selection.from, selection.to) : pointSelection(mark.from, mark.to, selection.from, tr.startState.selection.main.from == selection.from + 1));
      }
    }
  });
  return [tr, ...newTrans];
});

// src/cm-extensions/inlineStylerView/inlineStyler.tsx
var import_state10 = require("@codemirror/state");

// src/cm-extensions/inlineStylerView/styles/default.ts
var default_default2 = [
  {
    label: "bold",
    value: `****`,
    insertOffset: 2,
    icon: "mk-mark-strong",
    mark: "strong"
  },
  {
    label: "italics",
    value: "**",
    insertOffset: 1,
    icon: "mk-mark-em",
    mark: "em"
  },
  {
    label: "strikethrough",
    value: "~~~~",
    insertOffset: 2,
    icon: "mk-mark-strikethrough",
    mark: "strikethrough"
  },
  {
    label: "code",
    value: "``",
    insertOffset: 1,
    icon: "mk-mark-code",
    mark: "inline-code"
  },
  {
    label: "link",
    value: "[]()",
    insertOffset: 1,
    cursorOffset: 2,
    icon: "mk-mark-link"
  },
  {
    label: "blocklink",
    value: "[[]]",
    insertOffset: 2,
    icon: "mk-mark-blocklink"
  }
];

// src/cm-extensions/inlineStylerView/styles/index.ts
function resolveStyles() {
  return default_default2;
}

// src/cm-extensions/inlineStylerView/Mark.tsx
var Mark = (props) => {
  const { i: i3, style, active, toggleMarkAction } = props;
  return /* @__PURE__ */ bn.createElement("div", {
    key: i3,
    "aria-label": !platformIsMobile() ? i18n_default.styles[style.label] : void 0,
    className: `mk-mark ${style.mark && active ? "mk-mark-active" : ""}`,
    dangerouslySetInnerHTML: { __html: markIconSet[style.icon] },
    onMouseDown: (e3) => toggleMarkAction(e3, style)
  });
};

// src/cm-extensions/inlineStylerView/InlineMenu.tsx
var import_classnames3 = __toESM(require_classnames());
var loadStylerIntoContainer = (el) => {
  const root = createRoot(el);
  root.render(/* @__PURE__ */ bn.createElement(InlineMenuComponent, {
    mobile: true,
    activeMarks: []
  }));
};
var InlineMenuComponent = (props) => {
  const [mode, setMode] = p2(props.mobile ? 0 : 1);
  const [colorMode, setColorMode] = p2(null);
  const colors = ["#eb3b5a", "#fa8231", "#f7b731", "#20bf6b", "#0fb9b1", "#2d98da", "#3867d6", "#8854d0", "#4b6584"];
  const makeMenu = (e3) => {
    var _a2;
    e3.preventDefault();
    const cm = (_a2 = props.cm) != null ? _a2 : getActiveCM();
    if (!cm)
      return;
    const end2 = cm.state.selection.main.to;
    const insertChars = cm.state.sliceDoc(end2 - 1, end2) == cm.state.lineBreak ? window.make.settings.menuTriggerChar : cm.state.lineBreak + window.make.settings.menuTriggerChar;
    cm.dispatch({
      changes: {
        from: end2,
        to: end2,
        insert: insertChars
      },
      selection: {
        head: end2 + insertChars.length,
        anchor: end2 + insertChars.length
      }
    });
  };
  const toggleMarkAction = (e3, s3) => {
    var _a2;
    e3.preventDefault();
    const cm = (_a2 = props.cm) != null ? _a2 : getActiveCM();
    if (!cm)
      return;
    if (s3.mark) {
      cm.dispatch({
        annotations: toggleMark.of(s3.mark)
      });
      return;
    }
    const selection = cm.state.selection.main;
    const selectedText = cm.state.sliceDoc(selection.from, selection.to);
    cm.dispatch({
      changes: { from: selection.from, to: selection.to, insert: s3.value.substring(0, s3.insertOffset) + selectedText + s3.value.substring(s3.insertOffset) },
      selection: s3.cursorOffset ? { anchor: selection.from + s3.value.substring(0, s3.insertOffset).length + selectedText.length + s3.cursorOffset, head: selection.from + s3.value.substring(0, s3.insertOffset).length + selectedText.length + s3.cursorOffset } : { anchor: selection.from + s3.value.substring(0, s3.insertOffset).length, head: selection.from + s3.value.substring(0, s3.insertOffset).length + selectedText.length }
    });
  };
  const makeMode = () => /* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.commands.makeMenu : void 0,
    onMouseDown: (e3) => {
      makeMenu(e3);
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-make-slash"] }
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.commands.selectStyle : void 0,
    onMouseDown: () => {
      setMode(1);
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-make-style"] }
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.commands.image : void 0,
    onMouseDown: () => {
      const view = getActiveMarkdownView();
      window.make.app.commands.commands["editor:attach-file"].editorCallback(view.editor, view);
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-make-attach"] }
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.commands.toggleKeyboard : void 0,
    onMouseDown: () => {
      const view = getActiveMarkdownView();
      window.make.app.commands.commands["editor:toggle-keyboard"].editorCallback(view.editor, view);
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-make-keyboard"] }
  }));
  const colorsMode = () => /* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-mark",
    onMouseDown: () => {
      setColorMode(null);
      setMode(1);
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-close"] }
  }), colors.map((c3, i3) => /* @__PURE__ */ bn.createElement("div", {
    key: i3,
    onMouseDown: () => {
      var _a2;
      setMode(1);
      setColorMode(null);
      const cm = (_a2 = props.cm) != null ? _a2 : getActiveCM();
      if (!cm)
        return;
      const selection = cm.state.selection.main;
      const selectedText = cm.state.sliceDoc(selection.from, selection.to);
      cm.dispatch({
        changes: { from: selection.from, to: selection.to, insert: colorMode.prefix + c3 + colorMode.suffix + selectedText + colorMode.closeTag }
      });
    },
    className: "mk-color",
    style: { background: c3 }
  })));
  const marksMode = () => /* @__PURE__ */ bn.createElement(bn.Fragment, null, props.mobile ? /* @__PURE__ */ bn.createElement("div", {
    className: "mk-mark",
    onMouseDown: () => {
      setMode(0);
    },
    dangerouslySetInnerHTML: { __html: uiIconSet["mk-ui-close"] }
  }) : /* @__PURE__ */ bn.createElement(bn.Fragment, null), resolveStyles().map((s3, i3) => {
    return /* @__PURE__ */ bn.createElement(Mark, {
      i: i3,
      style: s3,
      active: props.activeMarks.find((f4) => f4 == s3.mark) ? true : false,
      toggleMarkAction
    });
  }), window.make.settings.inlineStylerColors ? /* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement("div", {
    className: "mk-divider"
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.styles.textColor : void 0,
    onMouseDown: () => {
      setMode(2);
      setColorMode({ prefix: `<span style='color:`, suffix: `'>`, closeTag: "</span>" });
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-mark-color"] }
  }), /* @__PURE__ */ bn.createElement("div", {
    "aria-label": !platformIsMobile() ? i18n_default.styles.highlight : void 0,
    onMouseDown: () => {
      setMode(2);
      setColorMode({ prefix: `<mark style='background:`, suffix: `'>`, closeTag: "</mark>" });
    },
    className: "mk-mark",
    dangerouslySetInnerHTML: { __html: markIconSet["mk-mark-highlight"] }
  })) : /* @__PURE__ */ bn.createElement(bn.Fragment, null));
  return /* @__PURE__ */ bn.createElement("div", {
    className: (0, import_classnames3.default)("mk-style-menu", props.mobile ? "" : "menu"),
    onMouseDown: (e3) => e3.preventDefault()
  }, mode == 0 && props.mobile ? makeMode() : mode == 2 ? colorsMode() : marksMode());
};

// src/cm-extensions/inlineStylerView/inlineStyler.tsx
var cursorTooltipField = import_state10.StateField.define({
  create: getCursorTooltips,
  update(tooltips3, tr) {
    if (!tr.docChanged && !tr.selection)
      return tooltips3;
    return getCursorTooltips(tr.state);
  },
  provide: (f4) => showTooltip.computeN([f4], (state) => state.field(f4))
});
function getCursorTooltips(state) {
  return state.selection.ranges.filter((range) => !range.empty).map((range) => {
    const expandedRange = expandRange(range, state);
    let line = state.doc.lineAt(range.head);
    let activeMarks = oMarks.map((f4) => rangeIsMark(state, f4, expandedRange) ? f4.mark : "").filter((f4) => f4 != "");
    return {
      pos: Math.min(range.head, range.anchor),
      above: true,
      strictSide: true,
      arrow: false,
      create: (view) => {
        let dom = document.createElement("div");
        dom.className = "cm-tooltip-cursor";
        const reactElement = createRoot(dom);
        reactElement.render(/* @__PURE__ */ bn.createElement(bn.Fragment, null, /* @__PURE__ */ bn.createElement(InlineMenuComponent, {
          cm: view,
          activeMarks,
          mobile: false
        })));
        return { dom };
      }
    };
  });
}
function cursorTooltip() {
  return cursorTooltipField;
}

// src/cm-extensions/flowEditor/flowViewUpdates.ts
var import_view6 = require("@codemirror/view");
var flowViewUpdates = import_view6.EditorView.updateListener.of((v3) => {
  if (v3.heightChanged) {
    app.workspace.iterateRootLeaves((leaf) => {
      var _a2, _b2;
      const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
      if (cm && v3.view.dom == cm.dom && cm.state.field(flowTypeStateField, false)) {
        if ((_b2 = leaf.containerEl.parentElement) == null ? void 0 : _b2.hasClass("workspace-tab-container")) {
          if (cm.state.field(flowTypeStateField, false) != "doc") {
            cm.dispatch({
              annotations: portalTypeAnnotation.of("doc")
            });
          }
        }
      }
    });
  }
  if (v3.heightChanged) {
    const flowID = v3.state.field(flowIDStateField, false);
    if (flowID) {
      app.workspace.iterateLeaves((leaf) => {
        var _a2;
        const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
        if (cm) {
          const stateField = cm.state.field(flowEditorInfo, false);
          if (stateField) {
            if (stateField.find((f4) => f4.id == flowID)) {
              cm.dispatch({
                annotations: cacheFlowEditorHeight.of([flowID, v3.view.contentHeight])
              });
            }
          }
        }
      }, app.workspace["rootSplit"]);
    }
  }
});

// src/cm-extensions/placeholder.ts
var import_view7 = require("@codemirror/view");
var import_state11 = require("@codemirror/state");
var placeholderLine = import_view7.Decoration.line({ attributes: { "data-ph": i18n_default.labels.placeholder }, class: "cm-placeholder" });
var placeholder = import_state11.StateField.define({
  create() {
    return import_view7.Decoration.none;
  },
  update(value, tr) {
    let builder = new import_state11.RangeSetBuilder();
    const currentLine = tr.state.doc.lineAt(tr.state.selection.main.head);
    if ((currentLine == null ? void 0 : currentLine.length) == 0)
      builder.add(currentLine.from, currentLine.from, placeholderLine);
    const dec = builder.finish();
    return dec;
  },
  provide: (f4) => import_view7.EditorView.decorations.from(f4)
});

// src/cm-extensions/cmExtensions.ts
var cmExtensions = (plugin, mobile) => {
  let extensions = [toggleMarkExtension, tooltips({ parent: document.body })];
  if (!mobile && plugin.settings.inlineStyler) {
    extensions.push(cursorTooltip());
  }
  if (plugin.settings.markSans) {
    if (!mobile) {
      extensions.push(hrResetFix, makerSelect, makerDelete, hrField);
    }
  }
  if (plugin.settings.makeMenuPlaceholder)
    extensions.push(placeholder);
  if (plugin.settings.editorFlow) {
    extensions.push(flowTypeStateField, atomicSelect, editBlockExtensions(), preloadFlowEditor, flowEditorField, flowEditorInfo, flowIDStateField, internalLinkHover, flowViewUpdates);
  }
  return extensions;
};

// src/utils/markdownPost.tsx
var getCMFromElement = (el) => {
  let dom = el;
  while (!dom.hasClass("cm-editor") && dom.parentElement) {
    dom = dom.parentElement;
  }
  if (!dom.hasClass("cm-editor")) {
    return;
  }
  let rcm;
  app.workspace.iterateLeaves((leaf) => {
    var _a2;
    const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
    if (cm && dom == cm.dom) {
      rcm = cm;
      return true;
    }
  }, app.workspace["rootSplit"]);
  return rcm;
};
var replaceAllEmbed = (el, ctx) => {
  let dom = el;
  setTimeout(async () => {
    let counter = 0;
    while (!el.parentElement && counter++ <= 50)
      await sleep(50);
    if (!el.parentElement)
      return;
    while (!dom.hasClass("markdown-embed") && dom.parentElement) {
      dom = dom.parentElement;
    }
    if (dom) {
      var nodes2 = dom.querySelectorAll(".markdown-embed-link");
      for (var i3 = 0; i3 < nodes2.length; i3++) {
        if (nodes2[i3].parentNode === dom) {
          dom.removeChild(nodes2[i3]);
          const div = dom.createDiv("mk-floweditor-selector");
          const reactEl = createRoot(div);
          reactEl.render(/* @__PURE__ */ bn.createElement(FlowEditorHover, {
            toggle: ctx.remainingNestLevel == 4,
            toggleState: false,
            toggleFlow: (e3) => {
              const cm = getCMFromElement(dom);
              const pos = cm.posAtDOM(dom);
              iterateTreeInSelection({ from: pos - 3, to: pos + 4 }, cm.state, {
                enter: (node) => {
                  if (node.name.contains("hmd-internal-link")) {
                    if (cm.state.sliceDoc(node.from - 4, node.from - 3) != "!") {
                      if (cm.state.sliceDoc(node.to + 2, node.to + 3) != cm.state.lineBreak) {
                        cm.dispatch({
                          changes: [
                            {
                              from: node.from - 3,
                              to: node.from - 3,
                              insert: "!"
                            },
                            {
                              from: node.to + 2,
                              to: node.to + 2,
                              insert: cm.state.lineBreak
                            }
                          ]
                        });
                      } else {
                        cm.dispatch({
                          changes: {
                            from: node.from - 3,
                            to: node.from - 3,
                            insert: "!"
                          }
                        });
                      }
                    }
                  }
                }
              });
              e3.stopPropagation();
            },
            openLink: (e3) => {
              e3.stopPropagation();
              openFileFlowEditor(ctx.sourcePath, "/");
            }
          }));
        }
        ;
      }
    }
  });
};

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key2) => around1(obj, key2, factories[key2]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r3) => r3());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/utils/patches.ts
var import_obsidian14 = require("obsidian");
var patchFileExplorer = (plugin) => {
  plugin.register(around(import_obsidian14.Workspace.prototype, {
    getLeavesOfType(old) {
      return function(type) {
        if (type == "file-explorer") {
          return old.call(this, FILE_TREE_VIEW_TYPE);
        }
        return old.call(this, type);
      };
    }
  }));
};
var patchWorkspace = (plugin) => {
  let layoutChanging = false;
  const uninstaller = around(import_obsidian14.Workspace.prototype, {
    changeLayout(old) {
      return async function(workspace) {
        layoutChanging = true;
        try {
          await old.call(this, workspace);
        } finally {
          layoutChanging = false;
        }
      };
    },
    iterateLeaves(old) {
      return function(arg1, arg2) {
        if (old.call(this, arg1, arg2))
          return true;
        let cb = typeof arg1 === "function" ? arg1 : arg2;
        let parent = typeof arg1 === "function" ? arg2 : arg1;
        if (!parent)
          return false;
        if (layoutChanging)
          return false;
        if (parent === app.workspace.rootSplit || import_obsidian14.WorkspaceContainer && parent instanceof import_obsidian14.WorkspaceContainer) {
          for (const popover of FlowEditor.popoversForWindow(parent.win)) {
            if (old.call(this, cb, popover.rootSplit))
              return true;
          }
        }
        return false;
      };
    },
    getDropLocation(old) {
      return function getDropLocation(event) {
        for (const popover of FlowEditor.activePopovers()) {
          const dropLoc = this.recursiveGetTarget(event, popover.rootSplit);
          if (dropLoc) {
            return dropLoc;
          }
        }
        return old.call(this, event);
      };
    },
    onDragLeaf(old) {
      return function(event, leaf) {
        const hoverPopover = FlowEditor.forLeaf(leaf);
        return old.call(this, event, leaf);
      };
    }
  });
  plugin.register(uninstaller);
};

// src/main.ts
var MakeMDPlugin = class extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    this.triggerVaultChangeEvent = (file, changeType, oldPath) => {
      let event = new CustomEvent(eventTypes.vaultChange, {
        detail: {
          file,
          changeType,
          oldPath: oldPath ? oldPath : ""
        }
      });
      window.dispatchEvent(event);
    };
    this.onCreate = (file) => this.triggerVaultChangeEvent(file, "create", "");
    this.onDelete = (file) => this.triggerVaultChangeEvent(file, "delete", "");
    this.onRename = (file, oldPath) => this.triggerVaultChangeEvent(file, "rename", oldPath);
    this.openFileTreeLeaf = async (showAfterAttach) => {
      let leafs = this.app.workspace.getLeavesOfType(FILE_TREE_VIEW_TYPE);
      if (leafs.length == 0) {
        let leaf = this.app.workspace.getLeftLeaf(false);
        await leaf.setViewState({ type: FILE_TREE_VIEW_TYPE });
        if (showAfterAttach)
          this.app.workspace.revealLeaf(leaf);
      } else {
        leafs.forEach((leaf) => this.app.workspace.revealLeaf(leaf));
      }
      replaceMobileMainMenu(this);
    };
    this.detachFileTreeLeafs = () => {
      let leafs = this.app.workspace.getLeavesOfType(FILE_TREE_VIEW_TYPE);
      for (let leaf of leafs) {
        if (leaf.view.destroy)
          leaf.view.destroy();
        leaf.detach();
      }
    };
    this.refreshTreeLeafs = () => {
      this.detachFileTreeLeafs();
      this.openFileTreeLeaf(true);
    };
  }
  openFlow() {
    const cm = getActiveCM();
    if (cm) {
      const value = cm.state.field(flowEditorInfo, false);
      const currPosition = cm.state.selection.main;
      for (let flowEditor of value) {
        if (flowEditor.from < currPosition.to && flowEditor.to > currPosition.from) {
          cm.dispatch({
            annotations: toggleFlowEditor.of([flowEditor.id, 2])
          });
        }
      }
    }
  }
  closeFlow() {
    const cm = getActiveCM();
    if (cm) {
      const value = cm.state.field(flowEditorInfo, false);
      const currPosition = cm.state.selection.main;
      for (let flowEditor of value) {
        if (flowEditor.from < currPosition.to && flowEditor.to > currPosition.from) {
          cm.dispatch({
            annotations: toggleFlowEditor.of([flowEditor.id, 0])
          });
        }
      }
    }
  }
  toggleBold() {
    const cm = getActiveCM();
    if (cm) {
      cm.dispatch({
        annotations: toggleMark.of("strong")
      });
    }
  }
  toggleEm() {
    const cm = getActiveCM();
    if (cm) {
      cm.dispatch({
        annotations: toggleMark.of("em")
      });
    }
  }
  loadSpaces() {
    patchWorkspace(this);
    document.body.classList.toggle("mk-hide-ribbon", !this.settings.sidebarRibbon);
    document.body.classList.toggle("mk-hide-ribbon", !this.settings.sidebarRibbon);
    document.body.classList.toggle("mk-hide-tabs", !this.settings.sidebarTabs);
    this.registerView(FOLDER_VIEW_TYPE, (leaf) => {
      return new FlowView(leaf, this);
    });
    if (this.settings.spacesEnabled) {
      if (!this.settings.spacesDisablePatch)
        patchFileExplorer(this);
      this.registerView(FILE_TREE_VIEW_TYPE, (leaf) => {
        return new FileTreeView(leaf, this);
      });
      this.app.workspace.onLayoutReady(async () => {
        await this.openFileTreeLeaf(true);
      });
    }
    this.app.vault.on("create", this.onCreate);
    this.app.vault.on("delete", this.onDelete);
    this.app.vault.on("rename", this.onRename);
  }
  loadFlowEditor() {
    document.body.classList.toggle("mk-flow-replace", this.settings.editorFlow);
    document.body.classList.toggle("mk-flow-" + this.settings.editorFlowStyle, true);
    this.addCommand({
      id: "mk-open-flow",
      name: i18n_default.commandPalette.openFlow,
      callback: () => this.openFlow()
    });
    this.addCommand({
      id: "mk-close-flow",
      name: i18n_default.commandPalette.closeFlow,
      callback: () => this.closeFlow()
    });
    if (this.settings.editorFlow) {
      this.registerMarkdownPostProcessor((element, context) => {
        const removeAllFlowMarks = (el) => {
          const embeds = el.querySelectorAll(".internal-embed");
          for (let index = 0; index < embeds.length; index++) {
            const embed = embeds.item(index);
            if (embed.previousSibling && embed.previousSibling.textContent.slice(-1) == "!")
              embed.previousSibling.textContent = embed.previousSibling.textContent.slice(0, -1);
          }
        };
        removeAllFlowMarks(element);
        replaceAllEmbed(element, context);
      });
      window.addEventListener(eventTypes.spawnPortal, this.spawnPortal);
      window.addEventListener(eventTypes.focusPortal, this.focusPortal);
      window.addEventListener(eventTypes.openFilePortal, this.openFileFromPortal);
    }
  }
  loadMakerMode() {
    document.body.classList.toggle("mk-mark-sans", this.settings.markSans);
    this.addCommand({
      id: "mk-toggle-bold",
      name: i18n_default.commandPalette.toggleBold,
      callback: () => this.toggleBold(),
      hotkeys: [
        {
          modifiers: ["Mod"],
          key: "b"
        }
      ]
    });
    this.addCommand({
      id: "mk-toggle-italics",
      name: i18n_default.commandPalette.toggleItalics,
      callback: () => this.toggleEm(),
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "i"
        }
      ]
    });
    this.registerEditorSuggest(new MakeMenu(this.app, this));
    this.registerEditorSuggest(new StickerMenu(this.app, this));
    if (platformIsMobile() && this.settings.mobileMakeBar)
      loadStylerIntoContainer(app.mobileToolbar.containerEl);
  }
  async onload() {
    window.make = this;
    (0, import_obsidian15.addIcon)("mk-logo", mkLogo);
    console.log("Loading Make.md");
    this.addSettingTab(new MakeMDPluginSettingsTab(this.app, this));
    await this.loadSettings();
    this.loadSpaces();
    this.loadFlowEditor();
    this.loadMakerMode();
    this.registerEditorExtension(cmExtensions(this, platformIsMobile()));
  }
  openFileFromPortal(e3) {
    openFileFromPortal(this, e3);
  }
  spawnPortal(e3) {
    spawnNewPortal(this, e3);
  }
  focusPortal(e3) {
    focusPortal(this, e3);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings(refresh = true) {
    await this.saveData(this.settings);
    if (refresh) {
      let evt = new CustomEvent(eventTypes.settingsChanged, {});
      window.dispatchEvent(evt);
    }
  }
  onunload() {
    console.log("Unloading Make.md");
    window.removeEventListener(eventTypes.spawnPortal, this.spawnPortal);
    window.removeEventListener(eventTypes.focusPortal, this.focusPortal);
    window.removeEventListener(eventTypes.openFilePortal, this.openFileFromPortal);
    this.detachFileTreeLeafs();
    this.app.vault.off("create", this.onCreate);
    this.app.vault.off("delete", this.onDelete);
    this.app.vault.off("rename", this.onRename);
  }
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
